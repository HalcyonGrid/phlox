//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 Gen.g 2012-05-22 12:14:59

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
using Antlr3.ST;
using Antlr3.ST.Language;
namespace  Halcyon.Phlox.Compiler 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class Gen : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN_EQ", "COMMA", "COMMENT_BLOCK", "COMMENT_SINGLE", "DO_WHILE_STMT", "ELIST", "ELSE_PART", "ESC_SEQ", "EVENT_DEF", "EXPONENT", "EXPR", "FLOAT_LITERAL", "FOR_STMT", "FUNC_BLOCK", "GT", "ID", "IF_STMT", "INDEX", "INTEGER_LITERAL", "JUMP_STMT", "LABEL", "LIST_LITERAL", "LPAREN", "LT", "METHOD_CALL", "METHOD_DEF", "MINUS", "NEWLINE", "PARAM_DECL", "POST_DECREMENT", "POST_INCREMENT", "PRE_DECREMENT", "PRE_INCREMENT", "RETURN_STMT", "ROTATION_LITERAL", "RPAREN", "SEMI", "STATE_BLOCK", "STATE_CHG", "STATE_DEF", "STRING_LITERAL", "SUBSCRIPT", "TYPE", "TYPE_CAST", "UNARY_BIT_NOT", "UNARY_BOOL_NOT", "UNARY_MINUS", "VAR_DECL", "VECTOR_LITERAL", "WHILE_STMT", "WS", "'!'", "'!='", "'%'", "'%='", "'&&'", "'&'", "'*'", "'*='", "'+'", "'++'", "'+='", "'--'", "'-='", "'.'", "'/'", "'/='", "'<<'", "'<<='", "'<='", "'=='", "'>='", "'>>'", "'>>='", "'@'", "'['", "']'", "'^'", "'default'", "'do'", "'else'", "'for'", "'if'", "'jump'", "'return'", "'state'", "'while'", "'{'", "'|'", "'||'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int ASSIGN_EQ=4;
	public const int COMMA=5;
	public const int COMMENT_BLOCK=6;
	public const int COMMENT_SINGLE=7;
	public const int DO_WHILE_STMT=8;
	public const int ELIST=9;
	public const int ELSE_PART=10;
	public const int ESC_SEQ=11;
	public const int EVENT_DEF=12;
	public const int EXPONENT=13;
	public const int EXPR=14;
	public const int FLOAT_LITERAL=15;
	public const int FOR_STMT=16;
	public const int FUNC_BLOCK=17;
	public const int GT=18;
	public const int ID=19;
	public const int IF_STMT=20;
	public const int INDEX=21;
	public const int INTEGER_LITERAL=22;
	public const int JUMP_STMT=23;
	public const int LABEL=24;
	public const int LIST_LITERAL=25;
	public const int LPAREN=26;
	public const int LT=27;
	public const int METHOD_CALL=28;
	public const int METHOD_DEF=29;
	public const int MINUS=30;
	public const int NEWLINE=31;
	public const int PARAM_DECL=32;
	public const int POST_DECREMENT=33;
	public const int POST_INCREMENT=34;
	public const int PRE_DECREMENT=35;
	public const int PRE_INCREMENT=36;
	public const int RETURN_STMT=37;
	public const int ROTATION_LITERAL=38;
	public const int RPAREN=39;
	public const int SEMI=40;
	public const int STATE_BLOCK=41;
	public const int STATE_CHG=42;
	public const int STATE_DEF=43;
	public const int STRING_LITERAL=44;
	public const int SUBSCRIPT=45;
	public const int TYPE=46;
	public const int TYPE_CAST=47;
	public const int UNARY_BIT_NOT=48;
	public const int UNARY_BOOL_NOT=49;
	public const int UNARY_MINUS=50;
	public const int VAR_DECL=51;
	public const int VECTOR_LITERAL=52;
	public const int WHILE_STMT=53;
	public const int WS=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;

	// delegates
	// delegators

	public Gen( ITreeNodeStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public Gen(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		
	private StringTemplateGroup _templateGroup = new StringTemplateGroup("GenTemplates", typeof(AngleBracketTemplateLexer) );

	public StringTemplateGroup TemplateGroup
	{
		get { return _templateGroup; }
		set { _templateGroup = value; }
	}

	public override string[] TokenNames { get { return Gen.tokenNames; } }
	public override string GrammarFileName { get { return "Gen.g"; } }


		SymbolTable symtab;
		private int LabelId = 0;

		int ErrorCount = 0;

		public override void Recover(IIntStream input, RecognitionException re)
	    {
			if (++ErrorCount == 10) throw new Halcyon.Phlox.Types.TooManyErrorsException("Too many errors", re);
	        base.Recover(input, re);
	    }
		
		public Gen(ITreeNodeStream input, SymbolTable symtab) : this(input) 
		{
			this.symtab = symtab;
		}

		private string FormatFloat(string floatLiteral)
		{
			return float.Parse(floatLiteral).ToString("0.0##############");
		}
		
		private StringTemplate DoPromotion(LSLAst expr, StringTemplate st)
		{
			if (expr.promoteToType != null)
			{
				if (expr.promoteToType == SymbolTable.FLOAT)
				{
					StringTemplate promoSt = TemplateGroup.GetInstanceOf("fcast", new Dictionary<string, object> { { "expr", st } });
					//type has been promoted
					expr.promoteToType = null;
					return promoSt;
				}

				//the only other promotion is key to string but internally keys are
				//strings anyways so no cast is needed
			}
	            
			return st;
		}

		private int CalcSubIndex(string subscript)
		{
			switch (subscript)
			{
				case "x":
					return 0;
				
				case "y":
					return 1;
				
				case "z":
					return 2;
				
				case "s":
					return 3;
					
				default:
					throw new System.Exception("Invalid subscript index");
			}
		}

		//protected override void Topdown() { topdown(); }
		//protected override void Bottomup() { bottomup(); }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	public sealed partial class script_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public script_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// Gen.g:81:8: public script : (g+= globalInits |f+= functions |s+= states )+ -> file(globalCount=symtab.NumGlobalsstatenames=symtab.Statesglobals=$gfunctions=$fstates=$s);
	[GrammarRule("script")]
	public Gen.script_return script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		Gen.script_return retval = new Gen.script_return(this);
		retval.Start = (LSLAst)input.LT(1);

		List<StringTemplate> list_g = null;
		List<StringTemplate> list_f = null;
		List<StringTemplate> list_s = null;
		Gen.globalInits_return g = default(Gen.globalInits_return);
		Gen.functions_return f = default(Gen.functions_return);
		Gen.states_return s = default(Gen.states_return);
		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(81, 2);
		try
		{
			// Gen.g:81:15: ( (g+= globalInits |f+= functions |s+= states )+ -> file(globalCount=symtab.NumGlobalsstatenames=symtab.Statesglobals=$gfunctions=$fstates=$s))
			DebugEnterAlt(1);
			// Gen.g:81:17: (g+= globalInits |f+= functions |s+= states )+
			{
			DebugLocation(81, 17);
			// Gen.g:81:17: (g+= globalInits |f+= functions |s+= states )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=4;
				try { DebugEnterDecision(1, false);
				switch (input.LA(1))
				{
				case VAR_DECL:
					{
					alt1 = 1;
					}
					break;
				case METHOD_DEF:
					{
					alt1 = 2;
					}
					break;
				case STATE_DEF:
					{
					alt1 = 3;
					}
					break;

				}

				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:81:18: g+= globalInits
					{
					DebugLocation(81, 19);
					PushFollow(Follow._globalInits_in_script85);
					g=globalInits();
					PopFollow();
					if (state.failed) return retval;
					if (list_g==null) list_g=new List<StringTemplate>();
					list_g.Add(g.Template);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:81:35: f+= functions
					{
					DebugLocation(81, 36);
					PushFollow(Follow._functions_in_script91);
					f=functions();
					PopFollow();
					if (state.failed) return retval;
					if (list_f==null) list_f=new List<StringTemplate>();
					list_f.Add(f.Template);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Gen.g:81:50: s+= states
					{
					DebugLocation(81, 51);
					PushFollow(Follow._states_in_script97);
					s=states();
					PopFollow();
					if (state.failed) return retval;
					if (list_s==null) list_s=new List<StringTemplate>();
					list_s.Add(s.Template);


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }



			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 82:4: -> file(globalCount=symtab.NumGlobalsstatenames=symtab.Statesglobals=$gfunctions=$fstates=$s)
				{
					retval.Template = TemplateGroup.GetInstanceOf("file",
					new Dictionary<string, object>() { {"globalCount", symtab.NumGlobals}, {"statenames", symtab.States}, {"globals", list_g}, {"functions", list_f}, {"states", list_s} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(89, 2);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	private sealed partial class states_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public states_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_states();
	partial void LeaveRule_states();

	// $ANTLR start "states"
	// Gen.g:91:1: states : ( ^( STATE_DEF ID ^( STATE_BLOCK (sbc+= eventDef )+ ) ) | ^( STATE_DEF ID STATE_BLOCK ) ) -> dump(content=$sbc);
	[GrammarRule("states")]
	private Gen.states_return states()
	{
		EnterRule_states();
		EnterRule("states", 2);
		TraceIn("states", 2);
		Gen.states_return retval = new Gen.states_return(this);
		retval.Start = (LSLAst)input.LT(1);

		List<StringTemplate> list_sbc = null;
		Gen.eventDef_return sbc = default(Gen.eventDef_return);
		try { DebugEnterRule(GrammarFileName, "states");
		DebugLocation(91, 1);
		try
		{
			// Gen.g:92:2: ( ( ^( STATE_DEF ID ^( STATE_BLOCK (sbc+= eventDef )+ ) ) | ^( STATE_DEF ID STATE_BLOCK ) ) -> dump(content=$sbc))
			DebugEnterAlt(1);
			// Gen.g:92:4: ( ^( STATE_DEF ID ^( STATE_BLOCK (sbc+= eventDef )+ ) ) | ^( STATE_DEF ID STATE_BLOCK ) )
			{
			DebugLocation(92, 4);
			// Gen.g:92:4: ( ^( STATE_DEF ID ^( STATE_BLOCK (sbc+= eventDef )+ ) ) | ^( STATE_DEF ID STATE_BLOCK ) )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==STATE_DEF))
			{
				int LA3_1 = input.LA(2);

				if ((LA3_1==DOWN))
				{
					int LA3_2 = input.LA(3);

					if ((LA3_2==ID))
					{
						int LA3_3 = input.LA(4);

						if ((LA3_3==STATE_BLOCK))
						{
							int LA3_4 = input.LA(5);

							if ((LA3_4==DOWN))
							{
								alt3 = 1;
							}
							else if ((LA3_4==UP))
							{
								alt3 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 3, 4, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 3, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 3, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:92:5: ^( STATE_DEF ID ^( STATE_BLOCK (sbc+= eventDef )+ ) )
				{
				DebugLocation(92, 5);
				DebugLocation(92, 7);
				Match(input,STATE_DEF,Follow._STATE_DEF_in_states170); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(92, 17);
				Match(input,ID,Follow._ID_in_states172); if (state.failed) return retval;
				DebugLocation(92, 20);
				DebugLocation(92, 22);
				Match(input,STATE_BLOCK,Follow._STATE_BLOCK_in_states175); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(92, 37);
				// Gen.g:92:37: (sbc+= eventDef )+
				int cnt2=0;
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_0 = input.LA(1);

					if ((LA2_0==EVENT_DEF))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:92:37: sbc+= eventDef
						{
						DebugLocation(92, 37);
						PushFollow(Follow._eventDef_in_states179);
						sbc=eventDef();
						PopFollow();
						if (state.failed) return retval;
						if (list_sbc==null) list_sbc=new List<StringTemplate>();
						list_sbc.Add(sbc.Template);


						}
						break;

					default:
						if (cnt2 >= 1)
							goto loop2;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee2 = new EarlyExitException( 2, input );
						DebugRecognitionException(eee2);
						throw eee2;
					}
					cnt2++;
				}
				loop2:
					;

				} finally { DebugExitSubRule(2); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:92:53: ^( STATE_DEF ID STATE_BLOCK )
				{
				DebugLocation(92, 53);
				DebugLocation(92, 55);
				Match(input,STATE_DEF,Follow._STATE_DEF_in_states187); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(92, 65);
				Match(input,ID,Follow._ID_in_states189); if (state.failed) return retval;
				DebugLocation(92, 68);
				Match(input,STATE_BLOCK,Follow._STATE_BLOCK_in_states191); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }



			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 93:3: -> dump(content=$sbc)
				{
					retval.Template = TemplateGroup.GetInstanceOf("dump",
					new Dictionary<string, object>() { {"content", list_sbc} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("states", 2);
			LeaveRule("states", 2);
			LeaveRule_states();
		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "states"); }
		return retval;

	}
	// $ANTLR end "states"

	private sealed partial class eventDef_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public eventDef_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_eventDef();
	partial void LeaveRule_eventDef();

	// $ANTLR start "eventDef"
	// Gen.g:96:1: eventDef : ( ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) ) -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=$fbc)| ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK ) -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=null));
	[GrammarRule("eventDef")]
	private Gen.eventDef_return eventDef()
	{
		EnterRule_eventDef();
		EnterRule("eventDef", 3);
		TraceIn("eventDef", 3);
		Gen.eventDef_return retval = new Gen.eventDef_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst ID1 = default(LSLAst);
		LSLAst ID2 = default(LSLAst);
		List<StringTemplate> list_fbc = null;
		Gen.funcBlockContent_return fbc = default(Gen.funcBlockContent_return);
		EventSymbol es = null;
		try { DebugEnterRule(GrammarFileName, "eventDef");
		DebugLocation(96, 1);
		try
		{
			// Gen.g:98:2: ( ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) ) -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=$fbc)| ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK ) -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=null))
			int alt9=2;
			try { DebugEnterDecision(9, false);
			try
			{
				alt9 = dfa9.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:98:4: ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) )
				{
				DebugLocation(98, 4);
				DebugLocation(98, 6);
				Match(input,EVENT_DEF,Follow._EVENT_DEF_in_eventDef220); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(98, 16);
				ID1=(LSLAst)Match(input,ID,Follow._ID_in_eventDef222); if (state.failed) return retval;
				DebugLocation(98, 19);
				// Gen.g:98:19: ( ^( PARAM_DECL ( . )* ) )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==PARAM_DECL))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:98:20: ^( PARAM_DECL ( . )* )
						{
						DebugLocation(98, 20);
						DebugLocation(98, 22);
						Match(input,PARAM_DECL,Follow._PARAM_DECL_in_eventDef226); if (state.failed) return retval;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(98, 33);
							// Gen.g:98:33: ( . )*
							try { DebugEnterSubRule(4);
							while (true)
							{
								int alt4=2;
								try { DebugEnterDecision(4, false);
								int LA4_0 = input.LA(1);

								if (((LA4_0>=ASSIGN_EQ && LA4_0<=95)))
								{
									alt4 = 1;
								}


								} finally { DebugExitDecision(4); }
								switch ( alt4 )
								{
								case 1:
									DebugEnterAlt(1);
									// Gen.g:98:33: .
									{
									DebugLocation(98, 33);
									MatchAny(input); if (state.failed) return retval;

									}
									break;

								default:
									goto loop4;
								}
							}

							loop4:
								;

							} finally { DebugExitSubRule(4); }


							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
						}

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(98, 39);
				DebugLocation(98, 41);
				Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_eventDef235); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(98, 55);
				// Gen.g:98:55: (fbc+= funcBlockContent )+
				int cnt6=0;
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if ((LA6_0==ASSIGN_EQ||LA6_0==DO_WHILE_STMT||(LA6_0>=EXPR && LA6_0<=IF_STMT)||(LA6_0>=INTEGER_LITERAL && LA6_0<=LIST_LITERAL)||(LA6_0>=LT && LA6_0<=METHOD_CALL)||LA6_0==MINUS||(LA6_0>=POST_DECREMENT && LA6_0<=ROTATION_LITERAL)||LA6_0==SEMI||LA6_0==STATE_CHG||(LA6_0>=STRING_LITERAL && LA6_0<=SUBSCRIPT)||(LA6_0>=TYPE_CAST && LA6_0<=WHILE_STMT)||(LA6_0>=56 && LA6_0<=63)||LA6_0==65||LA6_0==67||(LA6_0>=69 && LA6_0<=77)||LA6_0==81||(LA6_0>=92 && LA6_0<=93)))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:98:55: fbc+= funcBlockContent
						{
						DebugLocation(98, 55);
						PushFollow(Follow._funcBlockContent_in_eventDef239);
						fbc=funcBlockContent();
						PopFollow();
						if (state.failed) return retval;
						if (list_fbc==null) list_fbc=new List<StringTemplate>();
						list_fbc.Add(fbc.Template);


						}
						break;

					default:
						if (cnt6 >= 1)
							goto loop6;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee6 = new EarlyExitException( 6, input );
						DebugRecognitionException(eee6);
						throw eee6;
					}
					cnt6++;
				}
				loop6:
					;

				} finally { DebugExitSubRule(6); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(98, 77);
				if (state.backtracking == 0)
				{
					es = (EventSymbol)ID1.symbol;
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 99:3: -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=$fbc)
					{
						retval.Template = TemplateGroup.GetInstanceOf("eventdef",
						new Dictionary<string, object>() { {"eventname", es.FullEventName}, {"argcount", es.Members.Count}, {"localscount", es.CurrentVariableIndex - es.Members.Count}, {"content", list_fbc} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:107:3: ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK )
				{
				DebugLocation(107, 3);
				DebugLocation(107, 5);
				Match(input,EVENT_DEF,Follow._EVENT_DEF_in_eventDef294); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(107, 15);
				ID2=(LSLAst)Match(input,ID,Follow._ID_in_eventDef296); if (state.failed) return retval;
				DebugLocation(107, 18);
				// Gen.g:107:18: ( ^( PARAM_DECL ( . )* ) )*
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_0 = input.LA(1);

					if ((LA8_0==PARAM_DECL))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch ( alt8 )
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:107:19: ^( PARAM_DECL ( . )* )
						{
						DebugLocation(107, 19);
						DebugLocation(107, 21);
						Match(input,PARAM_DECL,Follow._PARAM_DECL_in_eventDef300); if (state.failed) return retval;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(107, 32);
							// Gen.g:107:32: ( . )*
							try { DebugEnterSubRule(7);
							while (true)
							{
								int alt7=2;
								try { DebugEnterDecision(7, false);
								int LA7_0 = input.LA(1);

								if (((LA7_0>=ASSIGN_EQ && LA7_0<=95)))
								{
									alt7 = 1;
								}


								} finally { DebugExitDecision(7); }
								switch ( alt7 )
								{
								case 1:
									DebugEnterAlt(1);
									// Gen.g:107:32: .
									{
									DebugLocation(107, 32);
									MatchAny(input); if (state.failed) return retval;

									}
									break;

								default:
									goto loop7;
								}
							}

							loop7:
								;

							} finally { DebugExitSubRule(7); }


							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
						}

						}
						break;

					default:
						goto loop8;
					}
				}

				loop8:
					;

				} finally { DebugExitSubRule(8); }

				DebugLocation(107, 38);
				Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_eventDef308); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(107, 50);
				if (state.backtracking == 0)
				{
					es = (EventSymbol)ID2.symbol;
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 108:3: -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=null)
					{
						retval.Template = TemplateGroup.GetInstanceOf("eventdef",
						new Dictionary<string, object>() { {"eventname", es.FullEventName}, {"argcount", es.Members.Count}, {"localscount", es.CurrentVariableIndex - es.Members.Count}, {"content", null} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("eventDef", 3);
			LeaveRule("eventDef", 3);
			LeaveRule_eventDef();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "eventDef"); }
		return retval;

	}
	// $ANTLR end "eventDef"

	private sealed partial class functions_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public functions_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_functions();
	partial void LeaveRule_functions();

	// $ANTLR start "functions"
	// Gen.g:116:1: functions : ( ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) ) -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=$fbc)| ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK ) -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=null));
	[GrammarRule("functions")]
	private Gen.functions_return functions()
	{
		EnterRule_functions();
		EnterRule("functions", 4);
		TraceIn("functions", 4);
		Gen.functions_return retval = new Gen.functions_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst ID3 = default(LSLAst);
		LSLAst ID4 = default(LSLAst);
		List<StringTemplate> list_fbc = null;
		Gen.funcBlockContent_return fbc = default(Gen.funcBlockContent_return);
		MethodSymbol ms = null;
		try { DebugEnterRule(GrammarFileName, "functions");
		DebugLocation(116, 1);
		try
		{
			// Gen.g:118:2: ( ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) ) -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=$fbc)| ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK ) -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=null))
			int alt17=2;
			try { DebugEnterDecision(17, false);
			try
			{
				alt17 = dfa17.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:119:3: ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) )
				{
				DebugLocation(119, 3);
				DebugLocation(119, 5);
				Match(input,METHOD_DEF,Follow._METHOD_DEF_in_functions372); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(119, 16);
				// Gen.g:119:16: ( TYPE )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==TYPE))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:119:16: TYPE
					{
					DebugLocation(119, 16);
					Match(input,TYPE,Follow._TYPE_in_functions374); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(119, 22);
				ID3=(LSLAst)Match(input,ID,Follow._ID_in_functions377); if (state.failed) return retval;
				DebugLocation(119, 25);
				// Gen.g:119:25: ( ^( PARAM_DECL ( . )* ) )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_0 = input.LA(1);

					if ((LA12_0==PARAM_DECL))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:119:26: ^( PARAM_DECL ( . )* )
						{
						DebugLocation(119, 26);
						DebugLocation(119, 28);
						Match(input,PARAM_DECL,Follow._PARAM_DECL_in_functions381); if (state.failed) return retval;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(119, 39);
							// Gen.g:119:39: ( . )*
							try { DebugEnterSubRule(11);
							while (true)
							{
								int alt11=2;
								try { DebugEnterDecision(11, false);
								int LA11_0 = input.LA(1);

								if (((LA11_0>=ASSIGN_EQ && LA11_0<=95)))
								{
									alt11 = 1;
								}


								} finally { DebugExitDecision(11); }
								switch ( alt11 )
								{
								case 1:
									DebugEnterAlt(1);
									// Gen.g:119:39: .
									{
									DebugLocation(119, 39);
									MatchAny(input); if (state.failed) return retval;

									}
									break;

								default:
									goto loop11;
								}
							}

							loop11:
								;

							} finally { DebugExitSubRule(11); }


							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
						}

						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }

				DebugLocation(119, 45);
				DebugLocation(119, 47);
				Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_functions390); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(119, 61);
				// Gen.g:119:61: (fbc+= funcBlockContent )+
				int cnt13=0;
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_0 = input.LA(1);

					if ((LA13_0==ASSIGN_EQ||LA13_0==DO_WHILE_STMT||(LA13_0>=EXPR && LA13_0<=IF_STMT)||(LA13_0>=INTEGER_LITERAL && LA13_0<=LIST_LITERAL)||(LA13_0>=LT && LA13_0<=METHOD_CALL)||LA13_0==MINUS||(LA13_0>=POST_DECREMENT && LA13_0<=ROTATION_LITERAL)||LA13_0==SEMI||LA13_0==STATE_CHG||(LA13_0>=STRING_LITERAL && LA13_0<=SUBSCRIPT)||(LA13_0>=TYPE_CAST && LA13_0<=WHILE_STMT)||(LA13_0>=56 && LA13_0<=63)||LA13_0==65||LA13_0==67||(LA13_0>=69 && LA13_0<=77)||LA13_0==81||(LA13_0>=92 && LA13_0<=93)))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:119:61: fbc+= funcBlockContent
						{
						DebugLocation(119, 61);
						PushFollow(Follow._funcBlockContent_in_functions394);
						fbc=funcBlockContent();
						PopFollow();
						if (state.failed) return retval;
						if (list_fbc==null) list_fbc=new List<StringTemplate>();
						list_fbc.Add(fbc.Template);


						}
						break;

					default:
						if (cnt13 >= 1)
							goto loop13;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee13 = new EarlyExitException( 13, input );
						DebugRecognitionException(eee13);
						throw eee13;
					}
					cnt13++;
				}
				loop13:
					;

				} finally { DebugExitSubRule(13); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(119, 83);
				if (state.backtracking == 0)
				{
					ms = (MethodSymbol)ID3.symbol;
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 120:3: -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=$fbc)
					{
						retval.Template = TemplateGroup.GetInstanceOf("methoddef",
						new Dictionary<string, object>() { {"methodname", ms.RawName}, {"argcount", ms.Members.Count}, {"localscount", ms.CurrentVariableIndex - ms.Members.Count}, {"content", list_fbc} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:123:3: ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK )
				{
				DebugLocation(123, 3);
				DebugLocation(123, 5);
				Match(input,METHOD_DEF,Follow._METHOD_DEF_in_functions435); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(123, 16);
				// Gen.g:123:16: ( TYPE )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==TYPE))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:123:16: TYPE
					{
					DebugLocation(123, 16);
					Match(input,TYPE,Follow._TYPE_in_functions437); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(14); }

				DebugLocation(123, 22);
				ID4=(LSLAst)Match(input,ID,Follow._ID_in_functions440); if (state.failed) return retval;
				DebugLocation(123, 25);
				// Gen.g:123:25: ( ^( PARAM_DECL ( . )* ) )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_0 = input.LA(1);

					if ((LA16_0==PARAM_DECL))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:123:26: ^( PARAM_DECL ( . )* )
						{
						DebugLocation(123, 26);
						DebugLocation(123, 28);
						Match(input,PARAM_DECL,Follow._PARAM_DECL_in_functions444); if (state.failed) return retval;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(123, 39);
							// Gen.g:123:39: ( . )*
							try { DebugEnterSubRule(15);
							while (true)
							{
								int alt15=2;
								try { DebugEnterDecision(15, false);
								int LA15_0 = input.LA(1);

								if (((LA15_0>=ASSIGN_EQ && LA15_0<=95)))
								{
									alt15 = 1;
								}


								} finally { DebugExitDecision(15); }
								switch ( alt15 )
								{
								case 1:
									DebugEnterAlt(1);
									// Gen.g:123:39: .
									{
									DebugLocation(123, 39);
									MatchAny(input); if (state.failed) return retval;

									}
									break;

								default:
									goto loop15;
								}
							}

							loop15:
								;

							} finally { DebugExitSubRule(15); }


							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
						}

						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }

				DebugLocation(123, 45);
				Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_functions452); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(123, 57);
				if (state.backtracking == 0)
				{
					ms = (MethodSymbol)ID4.symbol;
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 124:3: -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=null)
					{
						retval.Template = TemplateGroup.GetInstanceOf("methoddef",
						new Dictionary<string, object>() { {"methodname", ms.RawName}, {"argcount", ms.Members.Count}, {"localscount", ms.CurrentVariableIndex - ms.Members.Count}, {"content", null} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functions", 4);
			LeaveRule("functions", 4);
			LeaveRule_functions();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "functions"); }
		return retval;

	}
	// $ANTLR end "functions"

	private sealed partial class funcBlock_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public funcBlock_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_funcBlock();
	partial void LeaveRule_funcBlock();

	// $ANTLR start "funcBlock"
	// Gen.g:128:1: funcBlock : ( ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) | FUNC_BLOCK ) -> dump(content=$fbc);
	[GrammarRule("funcBlock")]
	private Gen.funcBlock_return funcBlock()
	{
		EnterRule_funcBlock();
		EnterRule("funcBlock", 5);
		TraceIn("funcBlock", 5);
		Gen.funcBlock_return retval = new Gen.funcBlock_return(this);
		retval.Start = (LSLAst)input.LT(1);

		List<StringTemplate> list_fbc = null;
		Gen.funcBlockContent_return fbc = default(Gen.funcBlockContent_return);
		try { DebugEnterRule(GrammarFileName, "funcBlock");
		DebugLocation(128, 1);
		try
		{
			// Gen.g:129:2: ( ( ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) | FUNC_BLOCK ) -> dump(content=$fbc))
			DebugEnterAlt(1);
			// Gen.g:129:5: ( ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) | FUNC_BLOCK )
			{
			DebugLocation(129, 5);
			// Gen.g:129:5: ( ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) | FUNC_BLOCK )
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==FUNC_BLOCK))
			{
				int LA19_1 = input.LA(2);

				if ((LA19_1==DOWN))
				{
					alt19 = 1;
				}
				else if ((LA19_1==EOF||(LA19_1>=UP && LA19_1<=ASSIGN_EQ)||LA19_1==DO_WHILE_STMT||LA19_1==ELSE_PART||(LA19_1>=EXPR && LA19_1<=IF_STMT)||(LA19_1>=INTEGER_LITERAL && LA19_1<=LIST_LITERAL)||(LA19_1>=LT && LA19_1<=METHOD_CALL)||LA19_1==MINUS||(LA19_1>=POST_DECREMENT && LA19_1<=ROTATION_LITERAL)||LA19_1==SEMI||LA19_1==STATE_CHG||(LA19_1>=STRING_LITERAL && LA19_1<=SUBSCRIPT)||(LA19_1>=TYPE_CAST && LA19_1<=WHILE_STMT)||(LA19_1>=56 && LA19_1<=63)||LA19_1==65||LA19_1==67||(LA19_1>=69 && LA19_1<=77)||LA19_1==81||(LA19_1>=92 && LA19_1<=93)))
				{
					alt19 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 19, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:129:6: ^( FUNC_BLOCK (fbc+= funcBlockContent )+ )
				{
				DebugLocation(129, 6);
				DebugLocation(129, 8);
				Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_funcBlock498); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(129, 22);
				// Gen.g:129:22: (fbc+= funcBlockContent )+
				int cnt18=0;
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					int LA18_0 = input.LA(1);

					if ((LA18_0==ASSIGN_EQ||LA18_0==DO_WHILE_STMT||(LA18_0>=EXPR && LA18_0<=IF_STMT)||(LA18_0>=INTEGER_LITERAL && LA18_0<=LIST_LITERAL)||(LA18_0>=LT && LA18_0<=METHOD_CALL)||LA18_0==MINUS||(LA18_0>=POST_DECREMENT && LA18_0<=ROTATION_LITERAL)||LA18_0==SEMI||LA18_0==STATE_CHG||(LA18_0>=STRING_LITERAL && LA18_0<=SUBSCRIPT)||(LA18_0>=TYPE_CAST && LA18_0<=WHILE_STMT)||(LA18_0>=56 && LA18_0<=63)||LA18_0==65||LA18_0==67||(LA18_0>=69 && LA18_0<=77)||LA18_0==81||(LA18_0>=92 && LA18_0<=93)))
					{
						alt18 = 1;
					}


					} finally { DebugExitDecision(18); }
					switch (alt18)
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:129:22: fbc+= funcBlockContent
						{
						DebugLocation(129, 22);
						PushFollow(Follow._funcBlockContent_in_funcBlock502);
						fbc=funcBlockContent();
						PopFollow();
						if (state.failed) return retval;
						if (list_fbc==null) list_fbc=new List<StringTemplate>();
						list_fbc.Add(fbc.Template);


						}
						break;

					default:
						if (cnt18 >= 1)
							goto loop18;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee18 = new EarlyExitException( 18, input );
						DebugRecognitionException(eee18);
						throw eee18;
					}
					cnt18++;
				}
				loop18:
					;

				} finally { DebugExitSubRule(18); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:129:45: FUNC_BLOCK
				{
				DebugLocation(129, 45);
				Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_funcBlock508); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(19); }



			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 130:3: -> dump(content=$fbc)
				{
					retval.Template = TemplateGroup.GetInstanceOf("dump",
					new Dictionary<string, object>() { {"content", list_fbc} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcBlock", 5);
			LeaveRule("funcBlock", 5);
			LeaveRule_funcBlock();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "funcBlock"); }
		return retval;

	}
	// $ANTLR end "funcBlock"

	private sealed partial class statement_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public statement_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// Gen.g:133:1: statement : ( funcBlock -> {$funcBlock.st}| funcBlockContent -> {$funcBlockContent.st});
	[GrammarRule("statement")]
	private Gen.statement_return statement()
	{
		EnterRule_statement();
		EnterRule("statement", 6);
		TraceIn("statement", 6);
		Gen.statement_return retval = new Gen.statement_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.funcBlock_return funcBlock5 = default(Gen.funcBlock_return);
		Gen.funcBlockContent_return funcBlockContent6 = default(Gen.funcBlockContent_return);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(133, 1);
		try
		{
			// Gen.g:134:2: ( funcBlock -> {$funcBlock.st}| funcBlockContent -> {$funcBlockContent.st})
			int alt20=2;
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==FUNC_BLOCK))
			{
				int LA20_1 = input.LA(2);

				if ((EvaluatePredicate(synpred22_Gen_fragment)))
				{
					alt20 = 1;
				}
				else if ((true))
				{
					alt20 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA20_0==ASSIGN_EQ||LA20_0==DO_WHILE_STMT||(LA20_0>=EXPR && LA20_0<=FOR_STMT)||(LA20_0>=GT && LA20_0<=IF_STMT)||(LA20_0>=INTEGER_LITERAL && LA20_0<=LIST_LITERAL)||(LA20_0>=LT && LA20_0<=METHOD_CALL)||LA20_0==MINUS||(LA20_0>=POST_DECREMENT && LA20_0<=ROTATION_LITERAL)||LA20_0==SEMI||LA20_0==STATE_CHG||(LA20_0>=STRING_LITERAL && LA20_0<=SUBSCRIPT)||(LA20_0>=TYPE_CAST && LA20_0<=WHILE_STMT)||(LA20_0>=56 && LA20_0<=63)||LA20_0==65||LA20_0==67||(LA20_0>=69 && LA20_0<=77)||LA20_0==81||(LA20_0>=92 && LA20_0<=93)))
			{
				alt20 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:134:4: funcBlock
				{
				DebugLocation(134, 4);
				PushFollow(Follow._funcBlock_in_statement531);
				funcBlock5=funcBlock();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 134:14: -> {$funcBlock.st}
					{
						retval.Template = (funcBlock5!=null?funcBlock5.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:135:4: funcBlockContent
				{
				DebugLocation(135, 4);
				PushFollow(Follow._funcBlockContent_in_statement540);
				funcBlockContent6=funcBlockContent();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 135:21: -> {$funcBlockContent.st}
					{
						retval.Template = (funcBlockContent6!=null?funcBlockContent6.Template:null);
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 6);
			LeaveRule("statement", 6);
			LeaveRule_statement();
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	private sealed partial class funcBlockContent_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public funcBlockContent_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_funcBlockContent();
	partial void LeaveRule_funcBlockContent();

	// $ANTLR start "funcBlockContent"
	// Gen.g:138:1: funcBlockContent : ( SEMI | ^( VAR_DECL TYPE ID e= expression ) -> lstore(expression=$e.stgindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( VAR_DECL TYPE ID ) -> linit(subtemplate=TemplateMapping.Init[$ID.symbol.Type.TypeIndex] + \"l\"lindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( RETURN_STMT (e= expression )? ) -> return(expression=$e.st)| ^( LABEL ID ) -> label(id=((LabelSymbol)$ID.symbol).DecoratedName)| ^( JUMP_STMT ID ) -> jump(id=((LabelSymbol)$ID.symbol).DecoratedName)| funcBlock -> {$funcBlock.st}| ^( IF_STMT e= expression stmt= statement ( ^( ELSE_PART eelse= statement ) | ELSE_PART ) ) -> ifelse(evalexpr=$e.ststmt=$stmt.staltstmt=$eelse.stendlabel=System.String.Format(\"if_end_{0}\", LabelId++)altlabel=System.String.Format(\"if_else_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( WHILE_STMT e= expression stmt= statement ) -> while(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( DO_WHILE_STMT e= expression stmt= statement ) -> dowhile(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"do_while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"do_while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( FOR_STMT body= statement (inits= SEMI |init= expression ) (conds= SEMI |cond= expression ) (eloop= expression )? ) -> forloop(initexpr=$init.stcondexpr=$cond.stloopexpr=$eloop.ststmt=$body.stloopstartlabel=System.String.Format(\"forloop_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"forloop_out_{0}\", LabelId++)needsBoolEval=cond != null && $cond.start.evalType != SymbolTable.INT)| ( ^( STATE_CHG ID ) | STATE_CHG ) -> statechg(id=$ID)| ^( EXPR methodCall[true, true] ) -> {$methodCall.st}| ^( EXPR preIncrement ) -> pop(expression=$preIncrement.st)| ^( EXPR postIncrement ) -> pop(expression=$postIncrement.st)| ^( EXPR preDecrement ) -> pop(expression=$preDecrement.st)| ^( EXPR postDecrement ) -> pop(expression=$postDecrement.st)| assignmentExpression[false] -> {$assignmentExpression.st});
	[GrammarRule("funcBlockContent")]
	private Gen.funcBlockContent_return funcBlockContent()
	{
		EnterRule_funcBlockContent();
		EnterRule("funcBlockContent", 7);
		TraceIn("funcBlockContent", 7);
		Gen.funcBlockContent_return retval = new Gen.funcBlockContent_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst inits = default(LSLAst);
		LSLAst conds = default(LSLAst);
		LSLAst ID7 = default(LSLAst);
		LSLAst ID8 = default(LSLAst);
		LSLAst ID9 = default(LSLAst);
		LSLAst ID10 = default(LSLAst);
		LSLAst ID12 = default(LSLAst);
		Gen.expression_return e = default(Gen.expression_return);
		Gen.statement_return stmt = default(Gen.statement_return);
		Gen.statement_return eelse = default(Gen.statement_return);
		Gen.statement_return body = default(Gen.statement_return);
		Gen.expression_return init = default(Gen.expression_return);
		Gen.expression_return cond = default(Gen.expression_return);
		Gen.expression_return eloop = default(Gen.expression_return);
		Gen.funcBlock_return funcBlock11 = default(Gen.funcBlock_return);
		Gen.methodCall_return methodCall13 = default(Gen.methodCall_return);
		Gen.preIncrement_return preIncrement14 = default(Gen.preIncrement_return);
		Gen.postIncrement_return postIncrement15 = default(Gen.postIncrement_return);
		Gen.preDecrement_return preDecrement16 = default(Gen.preDecrement_return);
		Gen.postDecrement_return postDecrement17 = default(Gen.postDecrement_return);
		Gen.assignmentExpression_return assignmentExpression18 = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "funcBlockContent");
		DebugLocation(138, 1);
		try
		{
			// Gen.g:139:2: ( SEMI | ^( VAR_DECL TYPE ID e= expression ) -> lstore(expression=$e.stgindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( VAR_DECL TYPE ID ) -> linit(subtemplate=TemplateMapping.Init[$ID.symbol.Type.TypeIndex] + \"l\"lindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( RETURN_STMT (e= expression )? ) -> return(expression=$e.st)| ^( LABEL ID ) -> label(id=((LabelSymbol)$ID.symbol).DecoratedName)| ^( JUMP_STMT ID ) -> jump(id=((LabelSymbol)$ID.symbol).DecoratedName)| funcBlock -> {$funcBlock.st}| ^( IF_STMT e= expression stmt= statement ( ^( ELSE_PART eelse= statement ) | ELSE_PART ) ) -> ifelse(evalexpr=$e.ststmt=$stmt.staltstmt=$eelse.stendlabel=System.String.Format(\"if_end_{0}\", LabelId++)altlabel=System.String.Format(\"if_else_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( WHILE_STMT e= expression stmt= statement ) -> while(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( DO_WHILE_STMT e= expression stmt= statement ) -> dowhile(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"do_while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"do_while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( FOR_STMT body= statement (inits= SEMI |init= expression ) (conds= SEMI |cond= expression ) (eloop= expression )? ) -> forloop(initexpr=$init.stcondexpr=$cond.stloopexpr=$eloop.ststmt=$body.stloopstartlabel=System.String.Format(\"forloop_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"forloop_out_{0}\", LabelId++)needsBoolEval=cond != null && $cond.start.evalType != SymbolTable.INT)| ( ^( STATE_CHG ID ) | STATE_CHG ) -> statechg(id=$ID)| ^( EXPR methodCall[true, true] ) -> {$methodCall.st}| ^( EXPR preIncrement ) -> pop(expression=$preIncrement.st)| ^( EXPR postIncrement ) -> pop(expression=$postIncrement.st)| ^( EXPR preDecrement ) -> pop(expression=$preDecrement.st)| ^( EXPR postDecrement ) -> pop(expression=$postDecrement.st)| assignmentExpression[false] -> {$assignmentExpression.st})
			int alt27=18;
			try { DebugEnterDecision(27, false);
			try
			{
				alt27 = dfa27.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:140:3: SEMI
				{
				DebugLocation(140, 3);
				Match(input,SEMI,Follow._SEMI_in_funcBlockContent558); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:142:4: ^( VAR_DECL TYPE ID e= expression )
				{
				DebugLocation(142, 4);
				DebugLocation(142, 6);
				Match(input,VAR_DECL,Follow._VAR_DECL_in_funcBlockContent565); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(142, 15);
				Match(input,TYPE,Follow._TYPE_in_funcBlockContent567); if (state.failed) return retval;
				DebugLocation(142, 20);
				ID7=(LSLAst)Match(input,ID,Follow._ID_in_funcBlockContent569); if (state.failed) return retval;
				DebugLocation(142, 24);
				PushFollow(Follow._expression_in_funcBlockContent573);
				e=expression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 143:3: -> lstore(expression=$e.stgindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("lstore",
						new Dictionary<string, object>() { {"expression", (e!=null?e.Template:null)}, {"gindex", ((VariableSymbol)ID7.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:148:3: ^( VAR_DECL TYPE ID )
				{
				DebugLocation(148, 3);
				DebugLocation(148, 5);
				Match(input,VAR_DECL,Follow._VAR_DECL_in_funcBlockContent607); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(148, 14);
				Match(input,TYPE,Follow._TYPE_in_funcBlockContent609); if (state.failed) return retval;
				DebugLocation(148, 19);
				ID8=(LSLAst)Match(input,ID,Follow._ID_in_funcBlockContent611); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 149:3: -> linit(subtemplate=TemplateMapping.Init[$ID.symbol.Type.TypeIndex] + \"l\"lindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("linit",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Init[ID8.symbol.Type.TypeIndex] + "l"}, {"lindex", ((VariableSymbol)ID8.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:154:3: ^( RETURN_STMT (e= expression )? )
				{
				DebugLocation(154, 3);
				DebugLocation(154, 5);
				Match(input,RETURN_STMT,Follow._RETURN_STMT_in_funcBlockContent645); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(154, 18);
					// Gen.g:154:18: (e= expression )?
					int alt21=2;
					try { DebugEnterSubRule(21);
					try { DebugEnterDecision(21, false);
					int LA21_0 = input.LA(1);

					if ((LA21_0==EXPR))
					{
						alt21 = 1;
					}
					} finally { DebugExitDecision(21); }
					switch (alt21)
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:154:18: e= expression
						{
						DebugLocation(154, 18);
						PushFollow(Follow._expression_in_funcBlockContent649);
						e=expression();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(21); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 155:3: -> return(expression=$e.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("return",
						new Dictionary<string, object>() { {"expression", (e!=null?e.Template:null)} });
					}

				}
				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Gen.g:157:3: ^( LABEL ID )
				{
				DebugLocation(157, 3);
				DebugLocation(157, 5);
				Match(input,LABEL,Follow._LABEL_in_funcBlockContent670); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(157, 11);
				ID9=(LSLAst)Match(input,ID,Follow._ID_in_funcBlockContent672); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 158:3: -> label(id=((LabelSymbol)$ID.symbol).DecoratedName)
					{
						retval.Template = TemplateGroup.GetInstanceOf("label",
						new Dictionary<string, object>() { {"id", ((LabelSymbol)ID9.symbol).DecoratedName} });
					}

				}
				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Gen.g:160:3: ^( JUMP_STMT ID )
				{
				DebugLocation(160, 3);
				DebugLocation(160, 5);
				Match(input,JUMP_STMT,Follow._JUMP_STMT_in_funcBlockContent692); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(160, 15);
				ID10=(LSLAst)Match(input,ID,Follow._ID_in_funcBlockContent694); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 161:3: -> jump(id=((LabelSymbol)$ID.symbol).DecoratedName)
					{
						retval.Template = TemplateGroup.GetInstanceOf("jump",
						new Dictionary<string, object>() { {"id", ((LabelSymbol)ID10.symbol).DecoratedName} });
					}

				}
				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Gen.g:163:4: funcBlock
				{
				DebugLocation(163, 4);
				PushFollow(Follow._funcBlock_in_funcBlockContent712);
				funcBlock11=funcBlock();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 163:14: -> {$funcBlock.st}
					{
						retval.Template = (funcBlock11!=null?funcBlock11.Template:null);
					}

				}
				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Gen.g:166:3: ^( IF_STMT e= expression stmt= statement ( ^( ELSE_PART eelse= statement ) | ELSE_PART ) )
				{
				DebugLocation(166, 3);
				DebugLocation(166, 5);
				Match(input,IF_STMT,Follow._IF_STMT_in_funcBlockContent726); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(166, 14);
				PushFollow(Follow._expression_in_funcBlockContent730);
				e=expression();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(166, 30);
				PushFollow(Follow._statement_in_funcBlockContent734);
				stmt=statement();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(166, 41);
				// Gen.g:166:41: ( ^( ELSE_PART eelse= statement ) | ELSE_PART )
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==ELSE_PART))
				{
					int LA22_1 = input.LA(2);

					if ((LA22_1==DOWN))
					{
						alt22 = 1;
					}
					else if ((LA22_1==UP))
					{
						alt22 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 22, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:166:42: ^( ELSE_PART eelse= statement )
					{
					DebugLocation(166, 42);
					DebugLocation(166, 44);
					Match(input,ELSE_PART,Follow._ELSE_PART_in_funcBlockContent738); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(166, 59);
					PushFollow(Follow._statement_in_funcBlockContent742);
					eelse=statement();
					PopFollow();
					if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:166:73: ELSE_PART
					{
					DebugLocation(166, 73);
					Match(input,ELSE_PART,Follow._ELSE_PART_in_funcBlockContent747); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(22); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 167:3: -> ifelse(evalexpr=$e.ststmt=$stmt.staltstmt=$eelse.stendlabel=System.String.Format(\"if_end_{0}\", LabelId++)altlabel=System.String.Format(\"if_else_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)
					{
						retval.Template = TemplateGroup.GetInstanceOf("ifelse",
						new Dictionary<string, object>() { {"evalexpr", (e!=null?e.Template:null)}, {"stmt", (stmt!=null?stmt.Template:null)}, {"altstmt", (eelse!=null?eelse.Template:null)}, {"endlabel", System.String.Format("if_end_{0}", LabelId++)}, {"altlabel", System.String.Format("if_else_{0}", LabelId++)}, {"needsBoolEval", (e!=null?((LSLAst)e.Start):default(LSLAst)).evalType != SymbolTable.INT} });
					}

				}
				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Gen.g:176:3: ^( WHILE_STMT e= expression stmt= statement )
				{
				DebugLocation(176, 3);
				DebugLocation(176, 5);
				Match(input,WHILE_STMT,Follow._WHILE_STMT_in_funcBlockContent818); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(176, 17);
				PushFollow(Follow._expression_in_funcBlockContent822);
				e=expression();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(176, 33);
				PushFollow(Follow._statement_in_funcBlockContent826);
				stmt=statement();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 177:3: -> while(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)
					{
						retval.Template = TemplateGroup.GetInstanceOf("while",
						new Dictionary<string, object>() { {"evalexpr", (e!=null?e.Template:null)}, {"stmt", (stmt!=null?stmt.Template:null)}, {"loopstartlabel", System.String.Format("while_start_{0}", LabelId++)}, {"loopoutlabel", System.String.Format("while_out_{0}", LabelId++)}, {"needsBoolEval", (e!=null?((LSLAst)e.Start):default(LSLAst)).evalType != SymbolTable.INT} });
					}

				}
				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Gen.g:185:3: ^( DO_WHILE_STMT e= expression stmt= statement )
				{
				DebugLocation(185, 3);
				DebugLocation(185, 5);
				Match(input,DO_WHILE_STMT,Follow._DO_WHILE_STMT_in_funcBlockContent886); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(185, 20);
				PushFollow(Follow._expression_in_funcBlockContent890);
				e=expression();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(185, 36);
				PushFollow(Follow._statement_in_funcBlockContent894);
				stmt=statement();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 186:3: -> dowhile(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"do_while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"do_while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)
					{
						retval.Template = TemplateGroup.GetInstanceOf("dowhile",
						new Dictionary<string, object>() { {"evalexpr", (e!=null?e.Template:null)}, {"stmt", (stmt!=null?stmt.Template:null)}, {"loopstartlabel", System.String.Format("do_while_start_{0}", LabelId++)}, {"loopoutlabel", System.String.Format("do_while_out_{0}", LabelId++)}, {"needsBoolEval", (e!=null?((LSLAst)e.Start):default(LSLAst)).evalType != SymbolTable.INT} });
					}

				}
				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Gen.g:195:3: ^( FOR_STMT body= statement (inits= SEMI |init= expression ) (conds= SEMI |cond= expression ) (eloop= expression )? )
				{
				DebugLocation(195, 3);
				DebugLocation(195, 5);
				Match(input,FOR_STMT,Follow._FOR_STMT_in_funcBlockContent955); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(195, 18);
				PushFollow(Follow._statement_in_funcBlockContent959);
				body=statement();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(195, 29);
				// Gen.g:195:29: (inits= SEMI |init= expression )
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==SEMI))
				{
					alt23 = 1;
				}
				else if ((LA23_0==EXPR))
				{
					alt23 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:195:30: inits= SEMI
					{
					DebugLocation(195, 35);
					inits=(LSLAst)Match(input,SEMI,Follow._SEMI_in_funcBlockContent964); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:195:43: init= expression
					{
					DebugLocation(195, 47);
					PushFollow(Follow._expression_in_funcBlockContent970);
					init=expression();
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(23); }

				DebugLocation(195, 60);
				// Gen.g:195:60: (conds= SEMI |cond= expression )
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==SEMI))
				{
					alt24 = 1;
				}
				else if ((LA24_0==EXPR))
				{
					alt24 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:195:61: conds= SEMI
					{
					DebugLocation(195, 66);
					conds=(LSLAst)Match(input,SEMI,Follow._SEMI_in_funcBlockContent976); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:195:74: cond= expression
					{
					DebugLocation(195, 78);
					PushFollow(Follow._expression_in_funcBlockContent982);
					cond=expression();
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(195, 96);
				// Gen.g:195:96: (eloop= expression )?
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==EXPR))
				{
					alt25 = 1;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:195:96: eloop= expression
					{
					DebugLocation(195, 96);
					PushFollow(Follow._expression_in_funcBlockContent987);
					eloop=expression();
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(25); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 196:3: -> forloop(initexpr=$init.stcondexpr=$cond.stloopexpr=$eloop.ststmt=$body.stloopstartlabel=System.String.Format(\"forloop_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"forloop_out_{0}\", LabelId++)needsBoolEval=cond != null && $cond.start.evalType != SymbolTable.INT)
					{
						retval.Template = TemplateGroup.GetInstanceOf("forloop",
						new Dictionary<string, object>() { {"initexpr", (init!=null?init.Template:null)}, {"condexpr", (cond!=null?cond.Template:null)}, {"loopexpr", (eloop!=null?eloop.Template:null)}, {"stmt", (body!=null?body.Template:null)}, {"loopstartlabel", System.String.Format("forloop_start_{0}", LabelId++)}, {"loopoutlabel", System.String.Format("forloop_out_{0}", LabelId++)}, {"needsBoolEval", cond != null && (cond!=null?((LSLAst)cond.Start):default(LSLAst)).evalType != SymbolTable.INT} });
					}

				}
				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Gen.g:206:3: ( ^( STATE_CHG ID ) | STATE_CHG )
				{
				DebugLocation(206, 3);
				// Gen.g:206:3: ( ^( STATE_CHG ID ) | STATE_CHG )
				int alt26=2;
				try { DebugEnterSubRule(26);
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==STATE_CHG))
				{
					int LA26_1 = input.LA(2);

					if ((LA26_1==DOWN))
					{
						alt26 = 1;
					}
					else if ((LA26_1==EOF||(LA26_1>=UP && LA26_1<=ASSIGN_EQ)||LA26_1==DO_WHILE_STMT||LA26_1==ELSE_PART||(LA26_1>=EXPR && LA26_1<=IF_STMT)||(LA26_1>=INTEGER_LITERAL && LA26_1<=LIST_LITERAL)||(LA26_1>=LT && LA26_1<=METHOD_CALL)||LA26_1==MINUS||(LA26_1>=POST_DECREMENT && LA26_1<=ROTATION_LITERAL)||LA26_1==SEMI||LA26_1==STATE_CHG||(LA26_1>=STRING_LITERAL && LA26_1<=SUBSCRIPT)||(LA26_1>=TYPE_CAST && LA26_1<=WHILE_STMT)||(LA26_1>=56 && LA26_1<=63)||LA26_1==65||LA26_1==67||(LA26_1>=69 && LA26_1<=77)||LA26_1==81||(LA26_1>=92 && LA26_1<=93)))
					{
						alt26 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 26, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:206:4: ^( STATE_CHG ID )
					{
					DebugLocation(206, 4);
					DebugLocation(206, 6);
					Match(input,STATE_CHG,Follow._STATE_CHG_in_funcBlockContent1066); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(206, 16);
					ID12=(LSLAst)Match(input,ID,Follow._ID_in_funcBlockContent1068); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:206:22: STATE_CHG
					{
					DebugLocation(206, 22);
					Match(input,STATE_CHG,Follow._STATE_CHG_in_funcBlockContent1073); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(26); }



				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 207:3: -> statechg(id=$ID)
					{
						retval.Template = TemplateGroup.GetInstanceOf("statechg",
						new Dictionary<string, object>() { {"id", ID12} });
					}

				}
				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Gen.g:209:3: ^( EXPR methodCall[true, true] )
				{
				DebugLocation(209, 3);
				DebugLocation(209, 5);
				Match(input,EXPR,Follow._EXPR_in_funcBlockContent1093); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(209, 10);
				PushFollow(Follow._methodCall_in_funcBlockContent1095);
				methodCall13=methodCall(true, true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 209:34: -> {$methodCall.st}
					{
						retval.Template = (methodCall13!=null?methodCall13.Template:null);
					}

				}
				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Gen.g:211:3: ^( EXPR preIncrement )
				{
				DebugLocation(211, 3);
				DebugLocation(211, 5);
				Match(input,EXPR,Follow._EXPR_in_funcBlockContent1109); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(211, 10);
				PushFollow(Follow._preIncrement_in_funcBlockContent1111);
				preIncrement14=preIncrement();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 212:3: -> pop(expression=$preIncrement.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("pop",
						new Dictionary<string, object>() { {"expression", (preIncrement14!=null?preIncrement14.Template:null)} });
					}

				}
				}
				break;
			case 15:
				DebugEnterAlt(15);
				// Gen.g:214:3: ^( EXPR postIncrement )
				{
				DebugLocation(214, 3);
				DebugLocation(214, 5);
				Match(input,EXPR,Follow._EXPR_in_funcBlockContent1132); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(214, 10);
				PushFollow(Follow._postIncrement_in_funcBlockContent1134);
				postIncrement15=postIncrement();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 215:3: -> pop(expression=$postIncrement.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("pop",
						new Dictionary<string, object>() { {"expression", (postIncrement15!=null?postIncrement15.Template:null)} });
					}

				}
				}
				break;
			case 16:
				DebugEnterAlt(16);
				// Gen.g:217:3: ^( EXPR preDecrement )
				{
				DebugLocation(217, 3);
				DebugLocation(217, 5);
				Match(input,EXPR,Follow._EXPR_in_funcBlockContent1155); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(217, 10);
				PushFollow(Follow._preDecrement_in_funcBlockContent1157);
				preDecrement16=preDecrement();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 218:3: -> pop(expression=$preDecrement.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("pop",
						new Dictionary<string, object>() { {"expression", (preDecrement16!=null?preDecrement16.Template:null)} });
					}

				}
				}
				break;
			case 17:
				DebugEnterAlt(17);
				// Gen.g:220:3: ^( EXPR postDecrement )
				{
				DebugLocation(220, 3);
				DebugLocation(220, 5);
				Match(input,EXPR,Follow._EXPR_in_funcBlockContent1178); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(220, 10);
				PushFollow(Follow._postDecrement_in_funcBlockContent1180);
				postDecrement17=postDecrement();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 221:3: -> pop(expression=$postDecrement.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("pop",
						new Dictionary<string, object>() { {"expression", (postDecrement17!=null?postDecrement17.Template:null)} });
					}

				}
				}
				break;
			case 18:
				DebugEnterAlt(18);
				// Gen.g:223:3: assignmentExpression[false]
				{
				DebugLocation(223, 3);
				PushFollow(Follow._assignmentExpression_in_funcBlockContent1200);
				assignmentExpression18=assignmentExpression(false);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 223:31: -> {$assignmentExpression.st}
					{
						retval.Template = (assignmentExpression18!=null?assignmentExpression18.Template:null);
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcBlockContent", 7);
			LeaveRule("funcBlockContent", 7);
			LeaveRule_funcBlockContent();
		}
		DebugLocation(224, 1);
		} finally { DebugExitRule(GrammarFileName, "funcBlockContent"); }
		return retval;

	}
	// $ANTLR end "funcBlockContent"

	private sealed partial class globalInits_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public globalInits_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_globalInits();
	partial void LeaveRule_globalInits();

	// $ANTLR start "globalInits"
	// Gen.g:226:1: globalInits : ( ^( VAR_DECL TYPE ID e= expression ) -> gstore(expression=$e.stgindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( VAR_DECL TYPE ID ) -> ginit(subtemplate=TemplateMapping.Init[$ID.symbol.Type.TypeIndex] + \"g\"gindex=((VariableSymbol)$ID.symbol).ScopeIndex));
	[GrammarRule("globalInits")]
	private Gen.globalInits_return globalInits()
	{
		EnterRule_globalInits();
		EnterRule("globalInits", 8);
		TraceIn("globalInits", 8);
		Gen.globalInits_return retval = new Gen.globalInits_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst ID19 = default(LSLAst);
		LSLAst ID20 = default(LSLAst);
		Gen.expression_return e = default(Gen.expression_return);

		try { DebugEnterRule(GrammarFileName, "globalInits");
		DebugLocation(226, 1);
		try
		{
			// Gen.g:227:2: ( ^( VAR_DECL TYPE ID e= expression ) -> gstore(expression=$e.stgindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( VAR_DECL TYPE ID ) -> ginit(subtemplate=TemplateMapping.Init[$ID.symbol.Type.TypeIndex] + \"g\"gindex=((VariableSymbol)$ID.symbol).ScopeIndex))
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==VAR_DECL))
			{
				int LA28_1 = input.LA(2);

				if ((LA28_1==DOWN))
				{
					int LA28_2 = input.LA(3);

					if ((LA28_2==TYPE))
					{
						int LA28_3 = input.LA(4);

						if ((LA28_3==ID))
						{
							int LA28_4 = input.LA(5);

							if ((LA28_4==UP))
							{
								alt28 = 2;
							}
							else if ((LA28_4==EXPR))
							{
								alt28 = 1;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 28, 4, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 28, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 28, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 28, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:227:4: ^( VAR_DECL TYPE ID e= expression )
				{
				DebugLocation(227, 4);
				DebugLocation(227, 6);
				Match(input,VAR_DECL,Follow._VAR_DECL_in_globalInits1217); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(227, 15);
				Match(input,TYPE,Follow._TYPE_in_globalInits1219); if (state.failed) return retval;
				DebugLocation(227, 20);
				ID19=(LSLAst)Match(input,ID,Follow._ID_in_globalInits1221); if (state.failed) return retval;
				DebugLocation(227, 24);
				PushFollow(Follow._expression_in_globalInits1225);
				e=expression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 228:3: -> gstore(expression=$e.stgindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("gstore",
						new Dictionary<string, object>() { {"expression", (e!=null?e.Template:null)}, {"gindex", ((VariableSymbol)ID19.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:233:3: ^( VAR_DECL TYPE ID )
				{
				DebugLocation(233, 3);
				DebugLocation(233, 5);
				Match(input,VAR_DECL,Follow._VAR_DECL_in_globalInits1259); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(233, 14);
				Match(input,TYPE,Follow._TYPE_in_globalInits1261); if (state.failed) return retval;
				DebugLocation(233, 19);
				ID20=(LSLAst)Match(input,ID,Follow._ID_in_globalInits1263); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 234:3: -> ginit(subtemplate=TemplateMapping.Init[$ID.symbol.Type.TypeIndex] + \"g\"gindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("ginit",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Init[ID20.symbol.Type.TypeIndex] + "g"}, {"gindex", ((VariableSymbol)ID20.symbol).ScopeIndex} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("globalInits", 8);
			LeaveRule("globalInits", 8);
			LeaveRule_globalInits();
		}
		DebugLocation(238, 1);
		} finally { DebugExitRule(GrammarFileName, "globalInits"); }
		return retval;

	}
	// $ANTLR end "globalInits"

	private sealed partial class expression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public expression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// Gen.g:240:1: expression : ^( EXPR expr ) -> {$expr.st};
	[GrammarRule("expression")]
	private Gen.expression_return expression()
	{
		EnterRule_expression();
		EnterRule("expression", 9);
		TraceIn("expression", 9);
		Gen.expression_return retval = new Gen.expression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.expr_return expr21 = default(Gen.expr_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(240, 1);
		try
		{
			// Gen.g:243:2: ( ^( EXPR expr ) -> {$expr.st})
			DebugEnterAlt(1);
			// Gen.g:243:4: ^( EXPR expr )
			{
			DebugLocation(243, 4);
			DebugLocation(243, 6);
			Match(input,EXPR,Follow._EXPR_in_expression1311); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(243, 11);
			PushFollow(Follow._expr_in_expression1313);
			expr21=expr();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 243:17: -> {$expr.st}
				{
					retval.Template = (expr21!=null?expr21.Template:null);
				}

			}
			}

			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 9);
			LeaveRule("expression", 9);
			LeaveRule_expression();
		}
		DebugLocation(244, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	private sealed partial class expr_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public expr_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// Gen.g:246:1: expr : assignmentExpression[true] -> {$assignmentExpression.st};
	[GrammarRule("expr")]
	private Gen.expr_return expr()
	{
		EnterRule_expr();
		EnterRule("expr", 10);
		TraceIn("expr", 10);
		Gen.expr_return retval = new Gen.expr_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.assignmentExpression_return assignmentExpression22 = default(Gen.assignmentExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(246, 1);
		try
		{
			// Gen.g:249:3: ( assignmentExpression[true] -> {$assignmentExpression.st})
			DebugEnterAlt(1);
			// Gen.g:249:3: assignmentExpression[true]
			{
			DebugLocation(249, 3);
			PushFollow(Follow._assignmentExpression_in_expr1340);
			assignmentExpression22=assignmentExpression(true);
			PopFollow();
			if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 249:30: -> {$assignmentExpression.st}
				{
					retval.Template = (assignmentExpression22!=null?assignmentExpression22.Template:null);
				}

			}
			}

			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 10);
			LeaveRule("expr", 10);
			LeaveRule_expr();
		}
		DebugLocation(250, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	private sealed partial class assignmentExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public assignmentExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();

	// $ANTLR start "assignmentExpression"
	// Gen.g:252:1: assignmentExpression[bool pushfinal] : ( assign[pushfinal] -> {$assign.st}| addassign[pushfinal] -> {$addassign.st}| subtractassign[pushfinal] -> {$subtractassign.st}| multassign[pushfinal] -> {$multassign.st}| divassign[pushfinal] -> {$divassign.st}| modassign[pushfinal] -> {$modassign.st}| lshassign[pushfinal] -> {$lshassign.st}| rshassign[pushfinal] -> {$rshassign.st}| booleanExpression {...}? -> {$booleanExpression.st});
	[GrammarRule("assignmentExpression")]
	private Gen.assignmentExpression_return assignmentExpression(bool pushfinal)
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 11);
		TraceIn("assignmentExpression", 11);
		Gen.assignmentExpression_return retval = new Gen.assignmentExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.assign_return assign23 = default(Gen.assign_return);
		Gen.addassign_return addassign24 = default(Gen.addassign_return);
		Gen.subtractassign_return subtractassign25 = default(Gen.subtractassign_return);
		Gen.multassign_return multassign26 = default(Gen.multassign_return);
		Gen.divassign_return divassign27 = default(Gen.divassign_return);
		Gen.modassign_return modassign28 = default(Gen.modassign_return);
		Gen.lshassign_return lshassign29 = default(Gen.lshassign_return);
		Gen.rshassign_return rshassign30 = default(Gen.rshassign_return);
		Gen.booleanExpression_return booleanExpression31 = default(Gen.booleanExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(252, 1);
		try
		{
			// Gen.g:255:2: ( assign[pushfinal] -> {$assign.st}| addassign[pushfinal] -> {$addassign.st}| subtractassign[pushfinal] -> {$subtractassign.st}| multassign[pushfinal] -> {$multassign.st}| divassign[pushfinal] -> {$divassign.st}| modassign[pushfinal] -> {$modassign.st}| lshassign[pushfinal] -> {$lshassign.st}| rshassign[pushfinal] -> {$rshassign.st}| booleanExpression {...}? -> {$booleanExpression.st})
			int alt29=9;
			try { DebugEnterDecision(29, false);
			try
			{
				alt29 = dfa29.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:255:4: assign[pushfinal]
				{
				DebugLocation(255, 4);
				PushFollow(Follow._assign_in_assignmentExpression1367);
				assign23=assign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 255:22: -> {$assign.st}
					{
						retval.Template = (assign23!=null?assign23.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:256:4: addassign[pushfinal]
				{
				DebugLocation(256, 4);
				PushFollow(Follow._addassign_in_assignmentExpression1377);
				addassign24=addassign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 256:25: -> {$addassign.st}
					{
						retval.Template = (addassign24!=null?addassign24.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:257:4: subtractassign[pushfinal]
				{
				DebugLocation(257, 4);
				PushFollow(Follow._subtractassign_in_assignmentExpression1387);
				subtractassign25=subtractassign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 257:30: -> {$subtractassign.st}
					{
						retval.Template = (subtractassign25!=null?subtractassign25.Template:null);
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:258:4: multassign[pushfinal]
				{
				DebugLocation(258, 4);
				PushFollow(Follow._multassign_in_assignmentExpression1397);
				multassign26=multassign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 258:26: -> {$multassign.st}
					{
						retval.Template = (multassign26!=null?multassign26.Template:null);
					}

				}
				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Gen.g:259:4: divassign[pushfinal]
				{
				DebugLocation(259, 4);
				PushFollow(Follow._divassign_in_assignmentExpression1407);
				divassign27=divassign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 259:25: -> {$divassign.st}
					{
						retval.Template = (divassign27!=null?divassign27.Template:null);
					}

				}
				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Gen.g:260:4: modassign[pushfinal]
				{
				DebugLocation(260, 4);
				PushFollow(Follow._modassign_in_assignmentExpression1417);
				modassign28=modassign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 260:25: -> {$modassign.st}
					{
						retval.Template = (modassign28!=null?modassign28.Template:null);
					}

				}
				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Gen.g:261:4: lshassign[pushfinal]
				{
				DebugLocation(261, 4);
				PushFollow(Follow._lshassign_in_assignmentExpression1427);
				lshassign29=lshassign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 261:25: -> {$lshassign.st}
					{
						retval.Template = (lshassign29!=null?lshassign29.Template:null);
					}

				}
				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Gen.g:262:4: rshassign[pushfinal]
				{
				DebugLocation(262, 4);
				PushFollow(Follow._rshassign_in_assignmentExpression1437);
				rshassign30=rshassign(pushfinal);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 262:25: -> {$rshassign.st}
					{
						retval.Template = (rshassign30!=null?rshassign30.Template:null);
					}

				}
				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Gen.g:263:4: booleanExpression {...}?
				{
				DebugLocation(263, 4);
				PushFollow(Follow._booleanExpression_in_assignmentExpression1447);
				booleanExpression31=booleanExpression();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(263, 22);
				if (!((pushfinal)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "assignmentExpression", "pushfinal");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 263:35: -> {$booleanExpression.st}
					{
						retval.Template = (booleanExpression31!=null?booleanExpression31.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignmentExpression", 11);
			LeaveRule("assignmentExpression", 11);
			LeaveRule_assignmentExpression();
		}
		DebugLocation(264, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	private sealed partial class rshassign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public rshassign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_rshassign();
	partial void LeaveRule_rshassign();

	// $ANTLR start "rshassign"
	// Gen.g:266:1: rshassign[bool pushfinal] : ^( '>>=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.RSHAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal);
	[GrammarRule("rshassign")]
	private Gen.rshassign_return rshassign(bool pushfinal)
	{
		EnterRule_rshassign();
		EnterRule("rshassign", 12);
		TraceIn("rshassign", 12);
		Gen.rshassign_return retval = new Gen.rshassign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "rshassign");
		DebugLocation(266, 1);
		try
		{
			// Gen.g:267:2: ( ^( '>>=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.RSHAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal))
			DebugEnterAlt(1);
			// Gen.g:267:4: ^( '>>=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
			{
			DebugLocation(267, 4);
			DebugLocation(267, 6);
			Match(input,77,Follow._77_in_rshassign1466); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(267, 12);
			// Gen.g:267:12: (id1= ID | ^( EXPR id1= ID ) )
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_0 = input.LA(1);

			if ((LA30_0==ID))
			{
				alt30 = 1;
			}
			else if ((LA30_0==EXPR))
			{
				alt30 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:267:13: id1= ID
				{
				DebugLocation(267, 16);
				id1=(LSLAst)Match(input,ID,Follow._ID_in_rshassign1471); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:267:22: ^( EXPR id1= ID )
				{
				DebugLocation(267, 22);
				DebugLocation(267, 24);
				Match(input,EXPR,Follow._EXPR_in_rshassign1476); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(267, 32);
				id1=(LSLAst)Match(input,ID,Follow._ID_in_rshassign1480); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(30); }

			DebugLocation(267, 39);
			PushFollow(Follow._assignmentExpression_in_rshassign1486);
			r=assignmentExpression(true);
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 268:3: -> subassignop(subtemplate=TemplateMapping.RSHAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
				{
					retval.Template = TemplateGroup.GetInstanceOf("subassignop",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.RSHAssign[id1.evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rshassign", 12);
			LeaveRule("rshassign", 12);
			LeaveRule_rshassign();
		}
		DebugLocation(275, 1);
		} finally { DebugExitRule(GrammarFileName, "rshassign"); }
		return retval;

	}
	// $ANTLR end "rshassign"

	private sealed partial class lshassign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public lshassign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_lshassign();
	partial void LeaveRule_lshassign();

	// $ANTLR start "lshassign"
	// Gen.g:277:1: lshassign[bool pushfinal] : ^( '<<=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.LSHAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal);
	[GrammarRule("lshassign")]
	private Gen.lshassign_return lshassign(bool pushfinal)
	{
		EnterRule_lshassign();
		EnterRule("lshassign", 13);
		TraceIn("lshassign", 13);
		Gen.lshassign_return retval = new Gen.lshassign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "lshassign");
		DebugLocation(277, 1);
		try
		{
			// Gen.g:278:2: ( ^( '<<=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.LSHAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal))
			DebugEnterAlt(1);
			// Gen.g:278:4: ^( '<<=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
			{
			DebugLocation(278, 4);
			DebugLocation(278, 6);
			Match(input,72,Follow._72_in_lshassign1550); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(278, 12);
			// Gen.g:278:12: (id1= ID | ^( EXPR id1= ID ) )
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_0 = input.LA(1);

			if ((LA31_0==ID))
			{
				alt31 = 1;
			}
			else if ((LA31_0==EXPR))
			{
				alt31 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:278:13: id1= ID
				{
				DebugLocation(278, 16);
				id1=(LSLAst)Match(input,ID,Follow._ID_in_lshassign1555); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:278:22: ^( EXPR id1= ID )
				{
				DebugLocation(278, 22);
				DebugLocation(278, 24);
				Match(input,EXPR,Follow._EXPR_in_lshassign1560); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(278, 32);
				id1=(LSLAst)Match(input,ID,Follow._ID_in_lshassign1564); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(31); }

			DebugLocation(278, 39);
			PushFollow(Follow._assignmentExpression_in_lshassign1570);
			r=assignmentExpression(true);
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 279:3: -> subassignop(subtemplate=TemplateMapping.LSHAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
				{
					retval.Template = TemplateGroup.GetInstanceOf("subassignop",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.LSHAssign[id1.evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lshassign", 13);
			LeaveRule("lshassign", 13);
			LeaveRule_lshassign();
		}
		DebugLocation(286, 1);
		} finally { DebugExitRule(GrammarFileName, "lshassign"); }
		return retval;

	}
	// $ANTLR end "lshassign"

	private sealed partial class modassign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public modassign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_modassign();
	partial void LeaveRule_modassign();

	// $ANTLR start "modassign"
	// Gen.g:288:1: modassign[bool pushfinal] : ^( '%=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.ModulusAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal);
	[GrammarRule("modassign")]
	private Gen.modassign_return modassign(bool pushfinal)
	{
		EnterRule_modassign();
		EnterRule("modassign", 14);
		TraceIn("modassign", 14);
		Gen.modassign_return retval = new Gen.modassign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "modassign");
		DebugLocation(288, 1);
		try
		{
			// Gen.g:289:2: ( ^( '%=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.ModulusAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal))
			DebugEnterAlt(1);
			// Gen.g:289:4: ^( '%=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
			{
			DebugLocation(289, 4);
			DebugLocation(289, 6);
			Match(input,58,Follow._58_in_modassign1634); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(289, 11);
			// Gen.g:289:11: (id1= ID | ^( EXPR id1= ID ) )
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_0 = input.LA(1);

			if ((LA32_0==ID))
			{
				alt32 = 1;
			}
			else if ((LA32_0==EXPR))
			{
				alt32 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:289:12: id1= ID
				{
				DebugLocation(289, 15);
				id1=(LSLAst)Match(input,ID,Follow._ID_in_modassign1639); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:289:21: ^( EXPR id1= ID )
				{
				DebugLocation(289, 21);
				DebugLocation(289, 23);
				Match(input,EXPR,Follow._EXPR_in_modassign1644); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(289, 31);
				id1=(LSLAst)Match(input,ID,Follow._ID_in_modassign1648); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(32); }

			DebugLocation(289, 38);
			PushFollow(Follow._assignmentExpression_in_modassign1654);
			r=assignmentExpression(true);
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 290:3: -> subassignop(subtemplate=TemplateMapping.ModulusAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
				{
					retval.Template = TemplateGroup.GetInstanceOf("subassignop",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.ModulusAssign[id1.evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("modassign", 14);
			LeaveRule("modassign", 14);
			LeaveRule_modassign();
		}
		DebugLocation(297, 1);
		} finally { DebugExitRule(GrammarFileName, "modassign"); }
		return retval;

	}
	// $ANTLR end "modassign"

	private sealed partial class divassign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public divassign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_divassign();
	partial void LeaveRule_divassign();

	// $ANTLR start "divassign"
	// Gen.g:299:1: divassign[bool pushfinal] : ( ^( '/=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.DivisionAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '/=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.DivisionAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal));
	[GrammarRule("divassign")]
	private Gen.divassign_return divassign(bool pushfinal)
	{
		EnterRule_divassign();
		EnterRule("divassign", 15);
		TraceIn("divassign", 15);
		Gen.divassign_return retval = new Gen.divassign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "divassign");
		DebugLocation(299, 1);
		try
		{
			// Gen.g:300:2: ( ^( '/=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.DivisionAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '/=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.DivisionAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal))
			int alt35=2;
			try { DebugEnterDecision(35, false);
			int LA35_0 = input.LA(1);

			if ((LA35_0==70))
			{
				int LA35_1 = input.LA(2);

				if ((LA35_1==DOWN))
				{
					int LA35_2 = input.LA(3);

					if ((LA35_2==SUBSCRIPT))
					{
						alt35 = 2;
					}
					else if ((LA35_2==EXPR||LA35_2==ID))
					{
						alt35 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 35, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 35, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:300:4: ^( '/=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
				{
				DebugLocation(300, 4);
				DebugLocation(300, 6);
				Match(input,70,Follow._70_in_divassign1718); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(300, 11);
				// Gen.g:300:11: (id1= ID | ^( EXPR id1= ID ) )
				int alt33=2;
				try { DebugEnterSubRule(33);
				try { DebugEnterDecision(33, false);
				int LA33_0 = input.LA(1);

				if ((LA33_0==ID))
				{
					alt33 = 1;
				}
				else if ((LA33_0==EXPR))
				{
					alt33 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(33); }
				switch (alt33)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:300:12: id1= ID
					{
					DebugLocation(300, 15);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_divassign1723); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:300:21: ^( EXPR id1= ID )
					{
					DebugLocation(300, 21);
					DebugLocation(300, 23);
					Match(input,EXPR,Follow._EXPR_in_divassign1728); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(300, 31);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_divassign1732); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(33); }

				DebugLocation(300, 38);
				PushFollow(Follow._assignmentExpression_in_divassign1738);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 301:3: -> subassignop(subtemplate=TemplateMapping.DivisionAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.DivisionAssign[id1.evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:309:3: ^( '/=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] )
				{
				DebugLocation(309, 3);
				DebugLocation(309, 5);
				Match(input,70,Follow._70_in_divassign1797); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(309, 10);
				DebugLocation(309, 12);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_divassign1800); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(309, 22);
				// Gen.g:309:22: ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) )
				int alt34=2;
				try { DebugEnterSubRule(34);
				try { DebugEnterDecision(34, false);
				int LA34_0 = input.LA(1);

				if ((LA34_0==ID))
				{
					alt34 = 1;
				}
				else if ((LA34_0==EXPR))
				{
					alt34 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 34, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(34); }
				switch (alt34)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:309:23: (var= ID sub= ID )
					{
					DebugLocation(309, 23);
					// Gen.g:309:23: (var= ID sub= ID )
					DebugEnterAlt(1);
					// Gen.g:309:24: var= ID sub= ID
					{
					DebugLocation(309, 27);
					var=(LSLAst)Match(input,ID,Follow._ID_in_divassign1806); if (state.failed) return retval;
					DebugLocation(309, 34);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_divassign1810); if (state.failed) return retval;

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:309:41: ( ^( EXPR var= ID ) sub= ID )
					{
					DebugLocation(309, 41);
					// Gen.g:309:41: ( ^( EXPR var= ID ) sub= ID )
					DebugEnterAlt(1);
					// Gen.g:309:42: ^( EXPR var= ID ) sub= ID
					{
					DebugLocation(309, 42);
					DebugLocation(309, 44);
					Match(input,EXPR,Follow._EXPR_in_divassign1817); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(309, 52);
					var=(LSLAst)Match(input,ID,Follow._ID_in_divassign1821); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					DebugLocation(309, 60);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_divassign1826); if (state.failed) return retval;

					}


					}
					break;

				}
				} finally { DebugExitSubRule(34); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(309, 68);
				PushFollow(Follow._assignmentExpression_in_divassign1833);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 310:3: -> subassignop(subtemplate=TemplateMapping.DivisionAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.DivisionAssign[SymbolTable.FLOAT.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("divassign", 15);
			LeaveRule("divassign", 15);
			LeaveRule_divassign();
		}
		DebugLocation(318, 1);
		} finally { DebugExitRule(GrammarFileName, "divassign"); }
		return retval;

	}
	// $ANTLR end "divassign"

	private sealed partial class multassign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public multassign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_multassign();
	partial void LeaveRule_multassign();

	// $ANTLR start "multassign"
	// Gen.g:320:1: multassign[bool pushfinal] : ( ^( '*=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.MultiplicationAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '*=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.MultiplicationAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal));
	[GrammarRule("multassign")]
	private Gen.multassign_return multassign(bool pushfinal)
	{
		EnterRule_multassign();
		EnterRule("multassign", 16);
		TraceIn("multassign", 16);
		Gen.multassign_return retval = new Gen.multassign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "multassign");
		DebugLocation(320, 1);
		try
		{
			// Gen.g:321:2: ( ^( '*=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.MultiplicationAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '*=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.MultiplicationAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal))
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_0 = input.LA(1);

			if ((LA38_0==62))
			{
				int LA38_1 = input.LA(2);

				if ((LA38_1==DOWN))
				{
					int LA38_2 = input.LA(3);

					if ((LA38_2==SUBSCRIPT))
					{
						alt38 = 2;
					}
					else if ((LA38_2==EXPR||LA38_2==ID))
					{
						alt38 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 38, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 38, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:321:4: ^( '*=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
				{
				DebugLocation(321, 4);
				DebugLocation(321, 6);
				Match(input,62,Follow._62_in_multassign1905); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(321, 11);
				// Gen.g:321:11: (id1= ID | ^( EXPR id1= ID ) )
				int alt36=2;
				try { DebugEnterSubRule(36);
				try { DebugEnterDecision(36, false);
				int LA36_0 = input.LA(1);

				if ((LA36_0==ID))
				{
					alt36 = 1;
				}
				else if ((LA36_0==EXPR))
				{
					alt36 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 36, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(36); }
				switch (alt36)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:321:12: id1= ID
					{
					DebugLocation(321, 15);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_multassign1910); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:321:21: ^( EXPR id1= ID )
					{
					DebugLocation(321, 21);
					DebugLocation(321, 23);
					Match(input,EXPR,Follow._EXPR_in_multassign1915); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(321, 31);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_multassign1919); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(36); }

				DebugLocation(321, 38);
				PushFollow(Follow._assignmentExpression_in_multassign1925);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 322:3: -> subassignop(subtemplate=TemplateMapping.MultiplicationAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.MultiplicationAssign[id1.evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:330:3: ^( '*=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] )
				{
				DebugLocation(330, 3);
				DebugLocation(330, 5);
				Match(input,62,Follow._62_in_multassign1984); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(330, 10);
				DebugLocation(330, 12);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_multassign1987); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(330, 22);
				// Gen.g:330:22: ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) )
				int alt37=2;
				try { DebugEnterSubRule(37);
				try { DebugEnterDecision(37, false);
				int LA37_0 = input.LA(1);

				if ((LA37_0==ID))
				{
					alt37 = 1;
				}
				else if ((LA37_0==EXPR))
				{
					alt37 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(37); }
				switch (alt37)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:330:23: (var= ID sub= ID )
					{
					DebugLocation(330, 23);
					// Gen.g:330:23: (var= ID sub= ID )
					DebugEnterAlt(1);
					// Gen.g:330:24: var= ID sub= ID
					{
					DebugLocation(330, 27);
					var=(LSLAst)Match(input,ID,Follow._ID_in_multassign1993); if (state.failed) return retval;
					DebugLocation(330, 34);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_multassign1997); if (state.failed) return retval;

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:330:41: ( ^( EXPR var= ID ) sub= ID )
					{
					DebugLocation(330, 41);
					// Gen.g:330:41: ( ^( EXPR var= ID ) sub= ID )
					DebugEnterAlt(1);
					// Gen.g:330:42: ^( EXPR var= ID ) sub= ID
					{
					DebugLocation(330, 42);
					DebugLocation(330, 44);
					Match(input,EXPR,Follow._EXPR_in_multassign2004); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(330, 52);
					var=(LSLAst)Match(input,ID,Follow._ID_in_multassign2008); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					DebugLocation(330, 60);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_multassign2013); if (state.failed) return retval;

					}


					}
					break;

				}
				} finally { DebugExitSubRule(37); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(330, 68);
				PushFollow(Follow._assignmentExpression_in_multassign2020);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 331:3: -> subassignop(subtemplate=TemplateMapping.MultiplicationAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.MultiplicationAssign[SymbolTable.FLOAT.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multassign", 16);
			LeaveRule("multassign", 16);
			LeaveRule_multassign();
		}
		DebugLocation(339, 1);
		} finally { DebugExitRule(GrammarFileName, "multassign"); }
		return retval;

	}
	// $ANTLR end "multassign"

	private sealed partial class subtractassign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public subtractassign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_subtractassign();
	partial void LeaveRule_subtractassign();

	// $ANTLR start "subtractassign"
	// Gen.g:341:1: subtractassign[bool pushfinal] : ( ^( '-=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.SubtractAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '-=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.SubtractAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal));
	[GrammarRule("subtractassign")]
	private Gen.subtractassign_return subtractassign(bool pushfinal)
	{
		EnterRule_subtractassign();
		EnterRule("subtractassign", 17);
		TraceIn("subtractassign", 17);
		Gen.subtractassign_return retval = new Gen.subtractassign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "subtractassign");
		DebugLocation(341, 1);
		try
		{
			// Gen.g:342:2: ( ^( '-=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.SubtractAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '-=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.SubtractAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal))
			int alt41=2;
			try { DebugEnterDecision(41, false);
			int LA41_0 = input.LA(1);

			if ((LA41_0==67))
			{
				int LA41_1 = input.LA(2);

				if ((LA41_1==DOWN))
				{
					int LA41_2 = input.LA(3);

					if ((LA41_2==SUBSCRIPT))
					{
						alt41 = 2;
					}
					else if ((LA41_2==EXPR||LA41_2==ID))
					{
						alt41 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 41, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 41, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:342:4: ^( '-=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
				{
				DebugLocation(342, 4);
				DebugLocation(342, 6);
				Match(input,67,Follow._67_in_subtractassign2092); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(342, 11);
				// Gen.g:342:11: (id1= ID | ^( EXPR id1= ID ) )
				int alt39=2;
				try { DebugEnterSubRule(39);
				try { DebugEnterDecision(39, false);
				int LA39_0 = input.LA(1);

				if ((LA39_0==ID))
				{
					alt39 = 1;
				}
				else if ((LA39_0==EXPR))
				{
					alt39 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 39, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:342:12: id1= ID
					{
					DebugLocation(342, 15);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_subtractassign2097); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:342:21: ^( EXPR id1= ID )
					{
					DebugLocation(342, 21);
					DebugLocation(342, 23);
					Match(input,EXPR,Follow._EXPR_in_subtractassign2102); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(342, 31);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_subtractassign2106); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(39); }

				DebugLocation(342, 38);
				PushFollow(Follow._assignmentExpression_in_subtractassign2112);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 343:3: -> subassignop(subtemplate=TemplateMapping.SubtractAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.SubtractAssign[id1.evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:351:3: ^( '-=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] )
				{
				DebugLocation(351, 3);
				DebugLocation(351, 5);
				Match(input,67,Follow._67_in_subtractassign2171); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(351, 10);
				DebugLocation(351, 12);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_subtractassign2174); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(351, 22);
				// Gen.g:351:22: ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) )
				int alt40=2;
				try { DebugEnterSubRule(40);
				try { DebugEnterDecision(40, false);
				int LA40_0 = input.LA(1);

				if ((LA40_0==ID))
				{
					alt40 = 1;
				}
				else if ((LA40_0==EXPR))
				{
					alt40 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(40); }
				switch (alt40)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:351:23: (var= ID sub= ID )
					{
					DebugLocation(351, 23);
					// Gen.g:351:23: (var= ID sub= ID )
					DebugEnterAlt(1);
					// Gen.g:351:24: var= ID sub= ID
					{
					DebugLocation(351, 27);
					var=(LSLAst)Match(input,ID,Follow._ID_in_subtractassign2180); if (state.failed) return retval;
					DebugLocation(351, 34);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_subtractassign2184); if (state.failed) return retval;

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:351:41: ( ^( EXPR var= ID ) sub= ID )
					{
					DebugLocation(351, 41);
					// Gen.g:351:41: ( ^( EXPR var= ID ) sub= ID )
					DebugEnterAlt(1);
					// Gen.g:351:42: ^( EXPR var= ID ) sub= ID
					{
					DebugLocation(351, 42);
					DebugLocation(351, 44);
					Match(input,EXPR,Follow._EXPR_in_subtractassign2191); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(351, 52);
					var=(LSLAst)Match(input,ID,Follow._ID_in_subtractassign2195); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					DebugLocation(351, 60);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_subtractassign2200); if (state.failed) return retval;

					}


					}
					break;

				}
				} finally { DebugExitSubRule(40); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(351, 68);
				PushFollow(Follow._assignmentExpression_in_subtractassign2207);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 352:3: -> subassignop(subtemplate=TemplateMapping.SubtractAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.SubtractAssign[SymbolTable.FLOAT.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("subtractassign", 17);
			LeaveRule("subtractassign", 17);
			LeaveRule_subtractassign();
		}
		DebugLocation(360, 1);
		} finally { DebugExitRule(GrammarFileName, "subtractassign"); }
		return retval;

	}
	// $ANTLR end "subtractassign"

	private sealed partial class addassign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public addassign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_addassign();
	partial void LeaveRule_addassign();

	// $ANTLR start "addassign"
	// Gen.g:362:1: addassign[bool pushfinal] : ( ^( '+=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.AddAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '+=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.AddAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal));
	[GrammarRule("addassign")]
	private Gen.addassign_return addassign(bool pushfinal)
	{
		EnterRule_addassign();
		EnterRule("addassign", 18);
		TraceIn("addassign", 18);
		Gen.addassign_return retval = new Gen.addassign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "addassign");
		DebugLocation(362, 1);
		try
		{
			// Gen.g:363:2: ( ^( '+=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.AddAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '+=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassignop(subtemplate=TemplateMapping.AddAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal))
			int alt44=2;
			try { DebugEnterDecision(44, false);
			int LA44_0 = input.LA(1);

			if ((LA44_0==65))
			{
				int LA44_1 = input.LA(2);

				if ((LA44_1==DOWN))
				{
					int LA44_2 = input.LA(3);

					if ((LA44_2==SUBSCRIPT))
					{
						alt44 = 2;
					}
					else if ((LA44_2==EXPR||LA44_2==ID))
					{
						alt44 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 44, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 44, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 44, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:363:4: ^( '+=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
				{
				DebugLocation(363, 4);
				DebugLocation(363, 6);
				Match(input,65,Follow._65_in_addassign2279); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(363, 11);
				// Gen.g:363:11: (id1= ID | ^( EXPR id1= ID ) )
				int alt42=2;
				try { DebugEnterSubRule(42);
				try { DebugEnterDecision(42, false);
				int LA42_0 = input.LA(1);

				if ((LA42_0==ID))
				{
					alt42 = 1;
				}
				else if ((LA42_0==EXPR))
				{
					alt42 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(42); }
				switch (alt42)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:363:12: id1= ID
					{
					DebugLocation(363, 15);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_addassign2284); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:363:21: ^( EXPR id1= ID )
					{
					DebugLocation(363, 21);
					DebugLocation(363, 23);
					Match(input,EXPR,Follow._EXPR_in_addassign2289); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(363, 31);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_addassign2293); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(42); }

				DebugLocation(363, 38);
				PushFollow(Follow._assignmentExpression_in_addassign2299);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 364:3: -> subassignop(subtemplate=TemplateMapping.AddAssign[$id1.evalType.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.AddAssign[id1.evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:372:3: ^( '+=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] )
				{
				DebugLocation(372, 3);
				DebugLocation(372, 5);
				Match(input,65,Follow._65_in_addassign2358); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(372, 10);
				DebugLocation(372, 12);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_addassign2361); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(372, 22);
				// Gen.g:372:22: ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) )
				int alt43=2;
				try { DebugEnterSubRule(43);
				try { DebugEnterDecision(43, false);
				int LA43_0 = input.LA(1);

				if ((LA43_0==ID))
				{
					alt43 = 1;
				}
				else if ((LA43_0==EXPR))
				{
					alt43 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:372:23: (var= ID sub= ID )
					{
					DebugLocation(372, 23);
					// Gen.g:372:23: (var= ID sub= ID )
					DebugEnterAlt(1);
					// Gen.g:372:24: var= ID sub= ID
					{
					DebugLocation(372, 27);
					var=(LSLAst)Match(input,ID,Follow._ID_in_addassign2367); if (state.failed) return retval;
					DebugLocation(372, 34);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_addassign2371); if (state.failed) return retval;

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:372:41: ( ^( EXPR var= ID ) sub= ID )
					{
					DebugLocation(372, 41);
					// Gen.g:372:41: ( ^( EXPR var= ID ) sub= ID )
					DebugEnterAlt(1);
					// Gen.g:372:42: ^( EXPR var= ID ) sub= ID
					{
					DebugLocation(372, 42);
					DebugLocation(372, 44);
					Match(input,EXPR,Follow._EXPR_in_addassign2378); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(372, 52);
					var=(LSLAst)Match(input,ID,Follow._ID_in_addassign2382); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					DebugLocation(372, 60);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_addassign2387); if (state.failed) return retval;

					}


					}
					break;

				}
				} finally { DebugExitSubRule(43); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(372, 68);
				PushFollow(Follow._assignmentExpression_in_addassign2394);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 373:3: -> subassignop(subtemplate=TemplateMapping.AddAssign[SymbolTable.FLOAT.TypeIndex, $r.start.evalType.TypeIndex]isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassignop",
						new Dictionary<string, object>() { {"subtemplate", TemplateMapping.AddAssign[SymbolTable.FLOAT.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("addassign", 18);
			LeaveRule("addassign", 18);
			LeaveRule_addassign();
		}
		DebugLocation(381, 1);
		} finally { DebugExitRule(GrammarFileName, "addassign"); }
		return retval;

	}
	// $ANTLR end "addassign"

	private sealed partial class assign_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public assign_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_assign();
	partial void LeaveRule_assign();

	// $ANTLR start "assign"
	// Gen.g:383:1: assign[bool pushfinal] : ( ^( '=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> assign(isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassign(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal));
	[GrammarRule("assign")]
	private Gen.assign_return assign(bool pushfinal)
	{
		EnterRule_assign();
		EnterRule("assign", 19);
		TraceIn("assign", 19);
		Gen.assign_return retval = new Gen.assign_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst id1 = default(LSLAst);
		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		Gen.assignmentExpression_return r = default(Gen.assignmentExpression_return);

		try { DebugEnterRule(GrammarFileName, "assign");
		DebugLocation(383, 1);
		try
		{
			// Gen.g:384:2: ( ^( '=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] ) -> assign(isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)| ^( '=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] ) -> subassign(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal))
			int alt47=2;
			try { DebugEnterDecision(47, false);
			int LA47_0 = input.LA(1);

			if ((LA47_0==ASSIGN_EQ))
			{
				int LA47_1 = input.LA(2);

				if ((LA47_1==DOWN))
				{
					int LA47_2 = input.LA(3);

					if ((LA47_2==SUBSCRIPT))
					{
						alt47 = 2;
					}
					else if ((LA47_2==EXPR||LA47_2==ID))
					{
						alt47 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 47, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 47, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:384:4: ^( '=' (id1= ID | ^( EXPR id1= ID ) ) r= assignmentExpression[true] )
				{
				DebugLocation(384, 4);
				DebugLocation(384, 6);
				Match(input,ASSIGN_EQ,Follow._ASSIGN_EQ_in_assign2466); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(384, 10);
				// Gen.g:384:10: (id1= ID | ^( EXPR id1= ID ) )
				int alt45=2;
				try { DebugEnterSubRule(45);
				try { DebugEnterDecision(45, false);
				int LA45_0 = input.LA(1);

				if ((LA45_0==ID))
				{
					alt45 = 1;
				}
				else if ((LA45_0==EXPR))
				{
					alt45 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 45, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(45); }
				switch (alt45)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:384:11: id1= ID
					{
					DebugLocation(384, 14);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_assign2471); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:384:20: ^( EXPR id1= ID )
					{
					DebugLocation(384, 20);
					DebugLocation(384, 22);
					Match(input,EXPR,Follow._EXPR_in_assign2476); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(384, 30);
					id1=(LSLAst)Match(input,ID,Follow._ID_in_assign2480); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(45); }

				DebugLocation(384, 37);
				PushFollow(Follow._assignmentExpression_in_assign2486);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 385:3: -> assign(isglobal=((VariableSymbol)$id1.symbol).IsGlobalindex=((VariableSymbol)$id1.symbol).ScopeIndexexpr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("assign",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)id1.symbol).IsGlobal}, {"index", ((VariableSymbol)id1.symbol).ScopeIndex}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:392:3: ^( '=' ^( SUBSCRIPT ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) ) ) r= assignmentExpression[true] )
				{
				DebugLocation(392, 3);
				DebugLocation(392, 5);
				Match(input,ASSIGN_EQ,Follow._ASSIGN_EQ_in_assign2537); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(392, 9);
				DebugLocation(392, 11);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_assign2540); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(392, 21);
				// Gen.g:392:21: ( (var= ID sub= ID ) | ( ^( EXPR var= ID ) sub= ID ) )
				int alt46=2;
				try { DebugEnterSubRule(46);
				try { DebugEnterDecision(46, false);
				int LA46_0 = input.LA(1);

				if ((LA46_0==ID))
				{
					alt46 = 1;
				}
				else if ((LA46_0==EXPR))
				{
					alt46 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(46); }
				switch (alt46)
				{
				case 1:
					DebugEnterAlt(1);
					// Gen.g:392:22: (var= ID sub= ID )
					{
					DebugLocation(392, 22);
					// Gen.g:392:22: (var= ID sub= ID )
					DebugEnterAlt(1);
					// Gen.g:392:23: var= ID sub= ID
					{
					DebugLocation(392, 26);
					var=(LSLAst)Match(input,ID,Follow._ID_in_assign2546); if (state.failed) return retval;
					DebugLocation(392, 33);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_assign2550); if (state.failed) return retval;

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Gen.g:392:40: ( ^( EXPR var= ID ) sub= ID )
					{
					DebugLocation(392, 40);
					// Gen.g:392:40: ( ^( EXPR var= ID ) sub= ID )
					DebugEnterAlt(1);
					// Gen.g:392:41: ^( EXPR var= ID ) sub= ID
					{
					DebugLocation(392, 41);
					DebugLocation(392, 43);
					Match(input,EXPR,Follow._EXPR_in_assign2557); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(392, 51);
					var=(LSLAst)Match(input,ID,Follow._ID_in_assign2561); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					DebugLocation(392, 59);
					sub=(LSLAst)Match(input,ID,Follow._ID_in_assign2566); if (state.failed) return retval;

					}


					}
					break;

				}
				} finally { DebugExitSubRule(46); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(392, 67);
				PushFollow(Follow._assignmentExpression_in_assign2573);
				r=assignmentExpression(true);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 393:3: -> subassign(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)expr=$r.stpushfinal=pushfinal)
					{
						retval.Template = TemplateGroup.GetInstanceOf("subassign",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))}, {"expr", (r!=null?r.Template:null)}, {"pushfinal", pushfinal} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assign", 19);
			LeaveRule("assign", 19);
			LeaveRule_assign();
		}
		DebugLocation(400, 1);
		} finally { DebugExitRule(GrammarFileName, "assign"); }
		return retval;

	}
	// $ANTLR end "assign"

	private sealed partial class booleanExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public booleanExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_booleanExpression();
	partial void LeaveRule_booleanExpression();

	// $ANTLR start "booleanExpression"
	// Gen.g:403:1: booleanExpression : ( boolor -> {$boolor.st}| booland -> {$booland.st}| bitwiseExpression -> {$bitwiseExpression.st});
	[GrammarRule("booleanExpression")]
	private Gen.booleanExpression_return booleanExpression()
	{
		EnterRule_booleanExpression();
		EnterRule("booleanExpression", 20);
		TraceIn("booleanExpression", 20);
		Gen.booleanExpression_return retval = new Gen.booleanExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.boolor_return boolor32 = default(Gen.boolor_return);
		Gen.booland_return booland33 = default(Gen.booland_return);
		Gen.bitwiseExpression_return bitwiseExpression34 = default(Gen.bitwiseExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "booleanExpression");
		DebugLocation(403, 1);
		try
		{
			// Gen.g:406:2: ( boolor -> {$boolor.st}| booland -> {$booland.st}| bitwiseExpression -> {$bitwiseExpression.st})
			int alt48=3;
			try { DebugEnterDecision(48, false);
			switch (input.LA(1))
			{
			case 93:
				{
				alt48 = 1;
				}
				break;
			case 59:
				{
				alt48 = 2;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case GT:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case LT:
			case METHOD_CALL:
			case MINUS:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
			case VECTOR_LITERAL:
			case 56:
			case 57:
			case 60:
			case 61:
			case 63:
			case 69:
			case 71:
			case 73:
			case 74:
			case 75:
			case 76:
			case 81:
			case 92:
				{
				alt48 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:406:4: boolor
				{
				DebugLocation(406, 4);
				PushFollow(Follow._boolor_in_booleanExpression2646);
				boolor32=boolor();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 406:11: -> {$boolor.st}
					{
						retval.Template = (boolor32!=null?boolor32.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:407:4: booland
				{
				DebugLocation(407, 4);
				PushFollow(Follow._booland_in_booleanExpression2655);
				booland33=booland();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 407:12: -> {$booland.st}
					{
						retval.Template = (booland33!=null?booland33.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:408:4: bitwiseExpression
				{
				DebugLocation(408, 4);
				PushFollow(Follow._bitwiseExpression_in_booleanExpression2664);
				bitwiseExpression34=bitwiseExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 408:22: -> {$bitwiseExpression.st}
					{
						retval.Template = (bitwiseExpression34!=null?bitwiseExpression34.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("booleanExpression", 20);
			LeaveRule("booleanExpression", 20);
			LeaveRule_booleanExpression();
		}
		DebugLocation(409, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanExpression"); }
		return retval;

	}
	// $ANTLR end "booleanExpression"

	private sealed partial class boolor_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public boolor_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_boolor();
	partial void LeaveRule_boolor();

	// $ANTLR start "boolor"
	// Gen.g:411:1: boolor : ^( '||' l= booleanExpression r= booleanExpression ) -> boolor(lexpr=$l.strexpr=$r.st);
	[GrammarRule("boolor")]
	private Gen.boolor_return boolor()
	{
		EnterRule_boolor();
		EnterRule("boolor", 21);
		TraceIn("boolor", 21);
		Gen.boolor_return retval = new Gen.boolor_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.booleanExpression_return l = default(Gen.booleanExpression_return);
		Gen.booleanExpression_return r = default(Gen.booleanExpression_return);

		try { DebugEnterRule(GrammarFileName, "boolor");
		DebugLocation(411, 1);
		try
		{
			// Gen.g:412:2: ( ^( '||' l= booleanExpression r= booleanExpression ) -> boolor(lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:412:4: ^( '||' l= booleanExpression r= booleanExpression )
			{
			DebugLocation(412, 4);
			DebugLocation(412, 6);
			Match(input,93,Follow._93_in_boolor2680); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(412, 12);
			PushFollow(Follow._booleanExpression_in_boolor2684);
			l=booleanExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(412, 32);
			PushFollow(Follow._booleanExpression_in_boolor2688);
			r=booleanExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 413:3: -> boolor(lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("boolor",
					new Dictionary<string, object>() { {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("boolor", 21);
			LeaveRule("boolor", 21);
			LeaveRule_boolor();
		}
		DebugLocation(414, 1);
		} finally { DebugExitRule(GrammarFileName, "boolor"); }
		return retval;

	}
	// $ANTLR end "boolor"

	private sealed partial class booland_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public booland_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_booland();
	partial void LeaveRule_booland();

	// $ANTLR start "booland"
	// Gen.g:416:1: booland : ^( '&&' l= booleanExpression r= booleanExpression ) -> booland(lexpr=$l.strexpr=$r.st);
	[GrammarRule("booland")]
	private Gen.booland_return booland()
	{
		EnterRule_booland();
		EnterRule("booland", 22);
		TraceIn("booland", 22);
		Gen.booland_return retval = new Gen.booland_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.booleanExpression_return l = default(Gen.booleanExpression_return);
		Gen.booleanExpression_return r = default(Gen.booleanExpression_return);

		try { DebugEnterRule(GrammarFileName, "booland");
		DebugLocation(416, 1);
		try
		{
			// Gen.g:417:2: ( ^( '&&' l= booleanExpression r= booleanExpression ) -> booland(lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:417:4: ^( '&&' l= booleanExpression r= booleanExpression )
			{
			DebugLocation(417, 4);
			DebugLocation(417, 6);
			Match(input,59,Follow._59_in_booland2717); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(417, 12);
			PushFollow(Follow._booleanExpression_in_booland2721);
			l=booleanExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(417, 32);
			PushFollow(Follow._booleanExpression_in_booland2725);
			r=booleanExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 418:3: -> booland(lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("booland",
					new Dictionary<string, object>() { {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("booland", 22);
			LeaveRule("booland", 22);
			LeaveRule_booland();
		}
		DebugLocation(419, 1);
		} finally { DebugExitRule(GrammarFileName, "booland"); }
		return retval;

	}
	// $ANTLR end "booland"

	private sealed partial class bitwiseExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public bitwiseExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_bitwiseExpression();
	partial void LeaveRule_bitwiseExpression();

	// $ANTLR start "bitwiseExpression"
	// Gen.g:421:1: bitwiseExpression : ( bitor -> {$bitor.st}| bitand -> {$bitand.st}| bitxor -> {$bitxor.st}| equalityExpression -> {$equalityExpression.st});
	[GrammarRule("bitwiseExpression")]
	private Gen.bitwiseExpression_return bitwiseExpression()
	{
		EnterRule_bitwiseExpression();
		EnterRule("bitwiseExpression", 23);
		TraceIn("bitwiseExpression", 23);
		Gen.bitwiseExpression_return retval = new Gen.bitwiseExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.bitor_return bitor35 = default(Gen.bitor_return);
		Gen.bitand_return bitand36 = default(Gen.bitand_return);
		Gen.bitxor_return bitxor37 = default(Gen.bitxor_return);
		Gen.equalityExpression_return equalityExpression38 = default(Gen.equalityExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "bitwiseExpression");
		DebugLocation(421, 1);
		try
		{
			// Gen.g:424:2: ( bitor -> {$bitor.st}| bitand -> {$bitand.st}| bitxor -> {$bitxor.st}| equalityExpression -> {$equalityExpression.st})
			int alt49=4;
			try { DebugEnterDecision(49, false);
			switch (input.LA(1))
			{
			case 92:
				{
				alt49 = 1;
				}
				break;
			case 60:
				{
				alt49 = 2;
				}
				break;
			case 81:
				{
				alt49 = 3;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case GT:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case LT:
			case METHOD_CALL:
			case MINUS:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
			case VECTOR_LITERAL:
			case 56:
			case 57:
			case 61:
			case 63:
			case 69:
			case 71:
			case 73:
			case 74:
			case 75:
			case 76:
				{
				alt49 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 49, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:424:4: bitor
				{
				DebugLocation(424, 4);
				PushFollow(Follow._bitor_in_bitwiseExpression2763);
				bitor35=bitor();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 424:10: -> {$bitor.st}
					{
						retval.Template = (bitor35!=null?bitor35.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:425:4: bitand
				{
				DebugLocation(425, 4);
				PushFollow(Follow._bitand_in_bitwiseExpression2772);
				bitand36=bitand();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 425:11: -> {$bitand.st}
					{
						retval.Template = (bitand36!=null?bitand36.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:426:4: bitxor
				{
				DebugLocation(426, 4);
				PushFollow(Follow._bitxor_in_bitwiseExpression2781);
				bitxor37=bitxor();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 426:11: -> {$bitxor.st}
					{
						retval.Template = (bitxor37!=null?bitxor37.Template:null);
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:427:4: equalityExpression
				{
				DebugLocation(427, 4);
				PushFollow(Follow._equalityExpression_in_bitwiseExpression2790);
				equalityExpression38=equalityExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 427:23: -> {$equalityExpression.st}
					{
						retval.Template = (equalityExpression38!=null?equalityExpression38.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseExpression", 23);
			LeaveRule("bitwiseExpression", 23);
			LeaveRule_bitwiseExpression();
		}
		DebugLocation(428, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseExpression"

	private sealed partial class bitor_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public bitor_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_bitor();
	partial void LeaveRule_bitor();

	// $ANTLR start "bitor"
	// Gen.g:430:1: bitor : ^( '|' l= bitwiseExpression r= bitwiseExpression ) -> bitor(lexpr=$l.strexpr=$r.st);
	[GrammarRule("bitor")]
	private Gen.bitor_return bitor()
	{
		EnterRule_bitor();
		EnterRule("bitor", 24);
		TraceIn("bitor", 24);
		Gen.bitor_return retval = new Gen.bitor_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.bitwiseExpression_return l = default(Gen.bitwiseExpression_return);
		Gen.bitwiseExpression_return r = default(Gen.bitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "bitor");
		DebugLocation(430, 1);
		try
		{
			// Gen.g:431:2: ( ^( '|' l= bitwiseExpression r= bitwiseExpression ) -> bitor(lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:431:4: ^( '|' l= bitwiseExpression r= bitwiseExpression )
			{
			DebugLocation(431, 4);
			DebugLocation(431, 6);
			Match(input,92,Follow._92_in_bitor2806); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(431, 11);
			PushFollow(Follow._bitwiseExpression_in_bitor2810);
			l=bitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(431, 31);
			PushFollow(Follow._bitwiseExpression_in_bitor2814);
			r=bitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 432:3: -> bitor(lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("bitor",
					new Dictionary<string, object>() { {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitor", 24);
			LeaveRule("bitor", 24);
			LeaveRule_bitor();
		}
		DebugLocation(433, 1);
		} finally { DebugExitRule(GrammarFileName, "bitor"); }
		return retval;

	}
	// $ANTLR end "bitor"

	private sealed partial class bitand_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public bitand_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_bitand();
	partial void LeaveRule_bitand();

	// $ANTLR start "bitand"
	// Gen.g:435:1: bitand : ^( '&' l= bitwiseExpression r= bitwiseExpression ) -> bitand(lexpr=$l.strexpr=$r.st);
	[GrammarRule("bitand")]
	private Gen.bitand_return bitand()
	{
		EnterRule_bitand();
		EnterRule("bitand", 25);
		TraceIn("bitand", 25);
		Gen.bitand_return retval = new Gen.bitand_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.bitwiseExpression_return l = default(Gen.bitwiseExpression_return);
		Gen.bitwiseExpression_return r = default(Gen.bitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "bitand");
		DebugLocation(435, 1);
		try
		{
			// Gen.g:436:2: ( ^( '&' l= bitwiseExpression r= bitwiseExpression ) -> bitand(lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:436:4: ^( '&' l= bitwiseExpression r= bitwiseExpression )
			{
			DebugLocation(436, 4);
			DebugLocation(436, 6);
			Match(input,60,Follow._60_in_bitand2843); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(436, 11);
			PushFollow(Follow._bitwiseExpression_in_bitand2847);
			l=bitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(436, 31);
			PushFollow(Follow._bitwiseExpression_in_bitand2851);
			r=bitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 437:3: -> bitand(lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("bitand",
					new Dictionary<string, object>() { {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitand", 25);
			LeaveRule("bitand", 25);
			LeaveRule_bitand();
		}
		DebugLocation(438, 1);
		} finally { DebugExitRule(GrammarFileName, "bitand"); }
		return retval;

	}
	// $ANTLR end "bitand"

	private sealed partial class bitxor_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public bitxor_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_bitxor();
	partial void LeaveRule_bitxor();

	// $ANTLR start "bitxor"
	// Gen.g:440:1: bitxor : ^( '^' l= bitwiseExpression r= bitwiseExpression ) -> bitxor(lexpr=$l.strexpr=$r.st);
	[GrammarRule("bitxor")]
	private Gen.bitxor_return bitxor()
	{
		EnterRule_bitxor();
		EnterRule("bitxor", 26);
		TraceIn("bitxor", 26);
		Gen.bitxor_return retval = new Gen.bitxor_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.bitwiseExpression_return l = default(Gen.bitwiseExpression_return);
		Gen.bitwiseExpression_return r = default(Gen.bitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "bitxor");
		DebugLocation(440, 1);
		try
		{
			// Gen.g:441:2: ( ^( '^' l= bitwiseExpression r= bitwiseExpression ) -> bitxor(lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:441:4: ^( '^' l= bitwiseExpression r= bitwiseExpression )
			{
			DebugLocation(441, 4);
			DebugLocation(441, 6);
			Match(input,81,Follow._81_in_bitxor2880); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(441, 11);
			PushFollow(Follow._bitwiseExpression_in_bitxor2884);
			l=bitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(441, 31);
			PushFollow(Follow._bitwiseExpression_in_bitxor2888);
			r=bitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 442:3: -> bitxor(lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("bitxor",
					new Dictionary<string, object>() { {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitxor", 26);
			LeaveRule("bitxor", 26);
			LeaveRule_bitxor();
		}
		DebugLocation(443, 1);
		} finally { DebugExitRule(GrammarFileName, "bitxor"); }
		return retval;

	}
	// $ANTLR end "bitxor"

	private sealed partial class equalityExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public equalityExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();

	// $ANTLR start "equalityExpression"
	// Gen.g:445:1: equalityExpression : ( equals -> {$equals.st}| notEquals -> {$notEquals.st}| relationalExpression -> {$relationalExpression.st});
	[GrammarRule("equalityExpression")]
	private Gen.equalityExpression_return equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 27);
		TraceIn("equalityExpression", 27);
		Gen.equalityExpression_return retval = new Gen.equalityExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.equals_return equals39 = default(Gen.equals_return);
		Gen.notEquals_return notEquals40 = default(Gen.notEquals_return);
		Gen.relationalExpression_return relationalExpression41 = default(Gen.relationalExpression_return);

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(445, 1);
		try
		{
			// Gen.g:446:2: ( equals -> {$equals.st}| notEquals -> {$notEquals.st}| relationalExpression -> {$relationalExpression.st})
			int alt50=3;
			try { DebugEnterDecision(50, false);
			switch (input.LA(1))
			{
			case 74:
				{
				alt50 = 1;
				}
				break;
			case 56:
				{
				alt50 = 2;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case GT:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case LT:
			case METHOD_CALL:
			case MINUS:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
			case VECTOR_LITERAL:
			case 57:
			case 61:
			case 63:
			case 69:
			case 71:
			case 73:
			case 75:
			case 76:
				{
				alt50 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 50, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:446:4: equals
				{
				DebugLocation(446, 4);
				PushFollow(Follow._equals_in_equalityExpression2916);
				equals39=equals();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 446:11: -> {$equals.st}
					{
						retval.Template = (equals39!=null?equals39.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:447:4: notEquals
				{
				DebugLocation(447, 4);
				PushFollow(Follow._notEquals_in_equalityExpression2925);
				notEquals40=notEquals();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 447:14: -> {$notEquals.st}
					{
						retval.Template = (notEquals40!=null?notEquals40.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:448:4: relationalExpression
				{
				DebugLocation(448, 4);
				PushFollow(Follow._relationalExpression_in_equalityExpression2934);
				relationalExpression41=relationalExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 448:25: -> {$relationalExpression.st}
					{
						retval.Template = (relationalExpression41!=null?relationalExpression41.Template:null);
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("equalityExpression", 27);
			LeaveRule("equalityExpression", 27);
			LeaveRule_equalityExpression();
		}
		DebugLocation(449, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	private sealed partial class equals_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public equals_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_equals();
	partial void LeaveRule_equals();

	// $ANTLR start "equals"
	// Gen.g:451:1: equals : ^(op= '==' l= relationalExpression r= relationalExpression ) -> equals(subtemplate=TemplateMapping.Equality[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("equals")]
	private Gen.equals_return equals()
	{
		EnterRule_equals();
		EnterRule("equals", 28);
		TraceIn("equals", 28);
		Gen.equals_return retval = new Gen.equals_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst op = default(LSLAst);
		Gen.relationalExpression_return l = default(Gen.relationalExpression_return);
		Gen.relationalExpression_return r = default(Gen.relationalExpression_return);

		try { DebugEnterRule(GrammarFileName, "equals");
		DebugLocation(451, 1);
		try
		{
			// Gen.g:452:2: ( ^(op= '==' l= relationalExpression r= relationalExpression ) -> equals(subtemplate=TemplateMapping.Equality[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:452:4: ^(op= '==' l= relationalExpression r= relationalExpression )
			{
			DebugLocation(452, 4);
			DebugLocation(452, 8);
			op=(LSLAst)Match(input,74,Follow._74_in_equals2952); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(452, 15);
			PushFollow(Follow._relationalExpression_in_equals2956);
			l=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(452, 38);
			PushFollow(Follow._relationalExpression_in_equals2960);
			r=relationalExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 453:3: -> equals(subtemplate=TemplateMapping.Equality[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("equals",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Equality[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("equals", 28);
			LeaveRule("equals", 28);
			LeaveRule_equals();
		}
		DebugLocation(457, 1);
		} finally { DebugExitRule(GrammarFileName, "equals"); }
		return retval;

	}
	// $ANTLR end "equals"

	private sealed partial class notEquals_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public notEquals_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_notEquals();
	partial void LeaveRule_notEquals();

	// $ANTLR start "notEquals"
	// Gen.g:459:1: notEquals : ^(op= '!=' l= relationalExpression r= relationalExpression ) -> notequals(subtemplate=TemplateMapping.Inequality[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("notEquals")]
	private Gen.notEquals_return notEquals()
	{
		EnterRule_notEquals();
		EnterRule("notEquals", 29);
		TraceIn("notEquals", 29);
		Gen.notEquals_return retval = new Gen.notEquals_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst op = default(LSLAst);
		Gen.relationalExpression_return l = default(Gen.relationalExpression_return);
		Gen.relationalExpression_return r = default(Gen.relationalExpression_return);

		try { DebugEnterRule(GrammarFileName, "notEquals");
		DebugLocation(459, 1);
		try
		{
			// Gen.g:460:2: ( ^(op= '!=' l= relationalExpression r= relationalExpression ) -> notequals(subtemplate=TemplateMapping.Inequality[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:460:4: ^(op= '!=' l= relationalExpression r= relationalExpression )
			{
			DebugLocation(460, 4);
			DebugLocation(460, 8);
			op=(LSLAst)Match(input,56,Follow._56_in_notEquals3006); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(460, 15);
			PushFollow(Follow._relationalExpression_in_notEquals3010);
			l=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(460, 38);
			PushFollow(Follow._relationalExpression_in_notEquals3014);
			r=relationalExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 461:3: -> notequals(subtemplate=TemplateMapping.Inequality[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("notequals",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Inequality[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("notEquals", 29);
			LeaveRule("notEquals", 29);
			LeaveRule_notEquals();
		}
		DebugLocation(465, 1);
		} finally { DebugExitRule(GrammarFileName, "notEquals"); }
		return retval;

	}
	// $ANTLR end "notEquals"

	private sealed partial class relationalExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public relationalExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();

	// $ANTLR start "relationalExpression"
	// Gen.g:467:1: relationalExpression : ( lessThan -> {$lessThan.st}| greaterThan -> {$greaterThan.st}| lessOrEquals -> {$lessOrEquals.st}| greaterOrEquals -> {$greaterOrEquals.st}| binaryBitwiseExpression -> {$binaryBitwiseExpression.st});
	[GrammarRule("relationalExpression")]
	private Gen.relationalExpression_return relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 30);
		TraceIn("relationalExpression", 30);
		Gen.relationalExpression_return retval = new Gen.relationalExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.lessThan_return lessThan42 = default(Gen.lessThan_return);
		Gen.greaterThan_return greaterThan43 = default(Gen.greaterThan_return);
		Gen.lessOrEquals_return lessOrEquals44 = default(Gen.lessOrEquals_return);
		Gen.greaterOrEquals_return greaterOrEquals45 = default(Gen.greaterOrEquals_return);
		Gen.binaryBitwiseExpression_return binaryBitwiseExpression46 = default(Gen.binaryBitwiseExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(467, 1);
		try
		{
			// Gen.g:470:2: ( lessThan -> {$lessThan.st}| greaterThan -> {$greaterThan.st}| lessOrEquals -> {$lessOrEquals.st}| greaterOrEquals -> {$greaterOrEquals.st}| binaryBitwiseExpression -> {$binaryBitwiseExpression.st})
			int alt51=5;
			try { DebugEnterDecision(51, false);
			switch (input.LA(1))
			{
			case LT:
				{
				alt51 = 1;
				}
				break;
			case GT:
				{
				alt51 = 2;
				}
				break;
			case 73:
				{
				alt51 = 3;
				}
				break;
			case 75:
				{
				alt51 = 4;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case METHOD_CALL:
			case MINUS:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
			case VECTOR_LITERAL:
			case 57:
			case 61:
			case 63:
			case 69:
			case 71:
			case 76:
				{
				alt51 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 51, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:470:4: lessThan
				{
				DebugLocation(470, 4);
				PushFollow(Follow._lessThan_in_relationalExpression3067);
				lessThan42=lessThan();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 470:13: -> {$lessThan.st}
					{
						retval.Template = (lessThan42!=null?lessThan42.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:471:4: greaterThan
				{
				DebugLocation(471, 4);
				PushFollow(Follow._greaterThan_in_relationalExpression3076);
				greaterThan43=greaterThan();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 471:16: -> {$greaterThan.st}
					{
						retval.Template = (greaterThan43!=null?greaterThan43.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:472:4: lessOrEquals
				{
				DebugLocation(472, 4);
				PushFollow(Follow._lessOrEquals_in_relationalExpression3085);
				lessOrEquals44=lessOrEquals();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 472:17: -> {$lessOrEquals.st}
					{
						retval.Template = (lessOrEquals44!=null?lessOrEquals44.Template:null);
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:473:4: greaterOrEquals
				{
				DebugLocation(473, 4);
				PushFollow(Follow._greaterOrEquals_in_relationalExpression3094);
				greaterOrEquals45=greaterOrEquals();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 473:20: -> {$greaterOrEquals.st}
					{
						retval.Template = (greaterOrEquals45!=null?greaterOrEquals45.Template:null);
					}

				}
				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Gen.g:474:4: binaryBitwiseExpression
				{
				DebugLocation(474, 4);
				PushFollow(Follow._binaryBitwiseExpression_in_relationalExpression3103);
				binaryBitwiseExpression46=binaryBitwiseExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 474:28: -> {$binaryBitwiseExpression.st}
					{
						retval.Template = (binaryBitwiseExpression46!=null?binaryBitwiseExpression46.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("relationalExpression", 30);
			LeaveRule("relationalExpression", 30);
			LeaveRule_relationalExpression();
		}
		DebugLocation(475, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	private sealed partial class lessOrEquals_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public lessOrEquals_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_lessOrEquals();
	partial void LeaveRule_lessOrEquals();

	// $ANTLR start "lessOrEquals"
	// Gen.g:477:1: lessOrEquals : ^( '<=' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.LTECompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("lessOrEquals")]
	private Gen.lessOrEquals_return lessOrEquals()
	{
		EnterRule_lessOrEquals();
		EnterRule("lessOrEquals", 31);
		TraceIn("lessOrEquals", 31);
		Gen.lessOrEquals_return retval = new Gen.lessOrEquals_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.binaryBitwiseExpression_return l = default(Gen.binaryBitwiseExpression_return);
		Gen.binaryBitwiseExpression_return r = default(Gen.binaryBitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "lessOrEquals");
		DebugLocation(477, 1);
		try
		{
			// Gen.g:478:2: ( ^( '<=' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.LTECompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:478:4: ^( '<=' l= binaryBitwiseExpression r= binaryBitwiseExpression )
			{
			DebugLocation(478, 4);
			DebugLocation(478, 6);
			Match(input,73,Follow._73_in_lessOrEquals3119); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(478, 12);
			PushFollow(Follow._binaryBitwiseExpression_in_lessOrEquals3123);
			l=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(478, 38);
			PushFollow(Follow._binaryBitwiseExpression_in_lessOrEquals3127);
			r=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 479:3: -> compare(operation=TemplateMapping.LTECompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("compare",
					new Dictionary<string, object>() { {"operation", TemplateMapping.LTECompare[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lessOrEquals", 31);
			LeaveRule("lessOrEquals", 31);
			LeaveRule_lessOrEquals();
		}
		DebugLocation(480, 1);
		} finally { DebugExitRule(GrammarFileName, "lessOrEquals"); }
		return retval;

	}
	// $ANTLR end "lessOrEquals"

	private sealed partial class greaterOrEquals_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public greaterOrEquals_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_greaterOrEquals();
	partial void LeaveRule_greaterOrEquals();

	// $ANTLR start "greaterOrEquals"
	// Gen.g:482:1: greaterOrEquals : ^( '>=' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.GTECompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("greaterOrEquals")]
	private Gen.greaterOrEquals_return greaterOrEquals()
	{
		EnterRule_greaterOrEquals();
		EnterRule("greaterOrEquals", 32);
		TraceIn("greaterOrEquals", 32);
		Gen.greaterOrEquals_return retval = new Gen.greaterOrEquals_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.binaryBitwiseExpression_return l = default(Gen.binaryBitwiseExpression_return);
		Gen.binaryBitwiseExpression_return r = default(Gen.binaryBitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "greaterOrEquals");
		DebugLocation(482, 1);
		try
		{
			// Gen.g:483:2: ( ^( '>=' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.GTECompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:483:4: ^( '>=' l= binaryBitwiseExpression r= binaryBitwiseExpression )
			{
			DebugLocation(483, 4);
			DebugLocation(483, 6);
			Match(input,75,Follow._75_in_greaterOrEquals3161); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(483, 12);
			PushFollow(Follow._binaryBitwiseExpression_in_greaterOrEquals3165);
			l=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(483, 38);
			PushFollow(Follow._binaryBitwiseExpression_in_greaterOrEquals3169);
			r=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 484:3: -> compare(operation=TemplateMapping.GTECompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("compare",
					new Dictionary<string, object>() { {"operation", TemplateMapping.GTECompare[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("greaterOrEquals", 32);
			LeaveRule("greaterOrEquals", 32);
			LeaveRule_greaterOrEquals();
		}
		DebugLocation(485, 1);
		} finally { DebugExitRule(GrammarFileName, "greaterOrEquals"); }
		return retval;

	}
	// $ANTLR end "greaterOrEquals"

	private sealed partial class lessThan_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public lessThan_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_lessThan();
	partial void LeaveRule_lessThan();

	// $ANTLR start "lessThan"
	// Gen.g:487:1: lessThan : ^( '<' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.LTCompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("lessThan")]
	private Gen.lessThan_return lessThan()
	{
		EnterRule_lessThan();
		EnterRule("lessThan", 33);
		TraceIn("lessThan", 33);
		Gen.lessThan_return retval = new Gen.lessThan_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.binaryBitwiseExpression_return l = default(Gen.binaryBitwiseExpression_return);
		Gen.binaryBitwiseExpression_return r = default(Gen.binaryBitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "lessThan");
		DebugLocation(487, 1);
		try
		{
			// Gen.g:488:2: ( ^( '<' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.LTCompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:488:4: ^( '<' l= binaryBitwiseExpression r= binaryBitwiseExpression )
			{
			DebugLocation(488, 4);
			DebugLocation(488, 6);
			Match(input,LT,Follow._LT_in_lessThan3203); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(488, 11);
			PushFollow(Follow._binaryBitwiseExpression_in_lessThan3207);
			l=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(488, 37);
			PushFollow(Follow._binaryBitwiseExpression_in_lessThan3211);
			r=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 489:3: -> compare(operation=TemplateMapping.LTCompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("compare",
					new Dictionary<string, object>() { {"operation", TemplateMapping.LTCompare[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lessThan", 33);
			LeaveRule("lessThan", 33);
			LeaveRule_lessThan();
		}
		DebugLocation(490, 1);
		} finally { DebugExitRule(GrammarFileName, "lessThan"); }
		return retval;

	}
	// $ANTLR end "lessThan"

	private sealed partial class greaterThan_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public greaterThan_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_greaterThan();
	partial void LeaveRule_greaterThan();

	// $ANTLR start "greaterThan"
	// Gen.g:492:1: greaterThan : ^( '>' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.GTCompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("greaterThan")]
	private Gen.greaterThan_return greaterThan()
	{
		EnterRule_greaterThan();
		EnterRule("greaterThan", 34);
		TraceIn("greaterThan", 34);
		Gen.greaterThan_return retval = new Gen.greaterThan_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.binaryBitwiseExpression_return l = default(Gen.binaryBitwiseExpression_return);
		Gen.binaryBitwiseExpression_return r = default(Gen.binaryBitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "greaterThan");
		DebugLocation(492, 1);
		try
		{
			// Gen.g:493:2: ( ^( '>' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> compare(operation=TemplateMapping.GTCompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:493:4: ^( '>' l= binaryBitwiseExpression r= binaryBitwiseExpression )
			{
			DebugLocation(493, 4);
			DebugLocation(493, 6);
			Match(input,GT,Follow._GT_in_greaterThan3245); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(493, 11);
			PushFollow(Follow._binaryBitwiseExpression_in_greaterThan3249);
			l=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(493, 37);
			PushFollow(Follow._binaryBitwiseExpression_in_greaterThan3253);
			r=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 494:3: -> compare(operation=TemplateMapping.GTCompare[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("compare",
					new Dictionary<string, object>() { {"operation", TemplateMapping.GTCompare[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("greaterThan", 34);
			LeaveRule("greaterThan", 34);
			LeaveRule_greaterThan();
		}
		DebugLocation(495, 1);
		} finally { DebugExitRule(GrammarFileName, "greaterThan"); }
		return retval;

	}
	// $ANTLR end "greaterThan"

	private sealed partial class binaryBitwiseExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public binaryBitwiseExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_binaryBitwiseExpression();
	partial void LeaveRule_binaryBitwiseExpression();

	// $ANTLR start "binaryBitwiseExpression"
	// Gen.g:497:1: binaryBitwiseExpression : ( leftShift -> {$leftShift.st}| rightShift -> {$rightShift.st}| additiveExpression -> {$additiveExpression.st});
	[GrammarRule("binaryBitwiseExpression")]
	private Gen.binaryBitwiseExpression_return binaryBitwiseExpression()
	{
		EnterRule_binaryBitwiseExpression();
		EnterRule("binaryBitwiseExpression", 35);
		TraceIn("binaryBitwiseExpression", 35);
		Gen.binaryBitwiseExpression_return retval = new Gen.binaryBitwiseExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.leftShift_return leftShift47 = default(Gen.leftShift_return);
		Gen.rightShift_return rightShift48 = default(Gen.rightShift_return);
		Gen.additiveExpression_return additiveExpression49 = default(Gen.additiveExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "binaryBitwiseExpression");
		DebugLocation(497, 1);
		try
		{
			// Gen.g:500:2: ( leftShift -> {$leftShift.st}| rightShift -> {$rightShift.st}| additiveExpression -> {$additiveExpression.st})
			int alt52=3;
			try { DebugEnterDecision(52, false);
			switch (input.LA(1))
			{
			case 71:
				{
				alt52 = 1;
				}
				break;
			case 76:
				{
				alt52 = 2;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case METHOD_CALL:
			case MINUS:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
			case VECTOR_LITERAL:
			case 57:
			case 61:
			case 63:
			case 69:
				{
				alt52 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:500:4: leftShift
				{
				DebugLocation(500, 4);
				PushFollow(Follow._leftShift_in_binaryBitwiseExpression3296);
				leftShift47=leftShift();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 500:14: -> {$leftShift.st}
					{
						retval.Template = (leftShift47!=null?leftShift47.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:501:4: rightShift
				{
				DebugLocation(501, 4);
				PushFollow(Follow._rightShift_in_binaryBitwiseExpression3305);
				rightShift48=rightShift();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 501:15: -> {$rightShift.st}
					{
						retval.Template = (rightShift48!=null?rightShift48.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:502:4: additiveExpression
				{
				DebugLocation(502, 4);
				PushFollow(Follow._additiveExpression_in_binaryBitwiseExpression3314);
				additiveExpression49=additiveExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 502:23: -> {$additiveExpression.st}
					{
						retval.Template = (additiveExpression49!=null?additiveExpression49.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("binaryBitwiseExpression", 35);
			LeaveRule("binaryBitwiseExpression", 35);
			LeaveRule_binaryBitwiseExpression();
		}
		DebugLocation(503, 1);
		} finally { DebugExitRule(GrammarFileName, "binaryBitwiseExpression"); }
		return retval;

	}
	// $ANTLR end "binaryBitwiseExpression"

	private sealed partial class leftShift_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public leftShift_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_leftShift();
	partial void LeaveRule_leftShift();

	// $ANTLR start "leftShift"
	// Gen.g:505:1: leftShift : ^( '<<' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> lshift(lexpr=$l.strexpr=$r.st);
	[GrammarRule("leftShift")]
	private Gen.leftShift_return leftShift()
	{
		EnterRule_leftShift();
		EnterRule("leftShift", 36);
		TraceIn("leftShift", 36);
		Gen.leftShift_return retval = new Gen.leftShift_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.binaryBitwiseExpression_return l = default(Gen.binaryBitwiseExpression_return);
		Gen.binaryBitwiseExpression_return r = default(Gen.binaryBitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "leftShift");
		DebugLocation(505, 1);
		try
		{
			// Gen.g:506:2: ( ^( '<<' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> lshift(lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:506:4: ^( '<<' l= binaryBitwiseExpression r= binaryBitwiseExpression )
			{
			DebugLocation(506, 4);
			DebugLocation(506, 6);
			Match(input,71,Follow._71_in_leftShift3330); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(506, 12);
			PushFollow(Follow._binaryBitwiseExpression_in_leftShift3334);
			l=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(506, 38);
			PushFollow(Follow._binaryBitwiseExpression_in_leftShift3338);
			r=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 507:3: -> lshift(lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("lshift",
					new Dictionary<string, object>() { {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("leftShift", 36);
			LeaveRule("leftShift", 36);
			LeaveRule_leftShift();
		}
		DebugLocation(508, 1);
		} finally { DebugExitRule(GrammarFileName, "leftShift"); }
		return retval;

	}
	// $ANTLR end "leftShift"

	private sealed partial class rightShift_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public rightShift_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_rightShift();
	partial void LeaveRule_rightShift();

	// $ANTLR start "rightShift"
	// Gen.g:510:1: rightShift : ^( '>>' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> rshift(lexpr=$l.strexpr=$r.st);
	[GrammarRule("rightShift")]
	private Gen.rightShift_return rightShift()
	{
		EnterRule_rightShift();
		EnterRule("rightShift", 37);
		TraceIn("rightShift", 37);
		Gen.rightShift_return retval = new Gen.rightShift_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.binaryBitwiseExpression_return l = default(Gen.binaryBitwiseExpression_return);
		Gen.binaryBitwiseExpression_return r = default(Gen.binaryBitwiseExpression_return);

		try { DebugEnterRule(GrammarFileName, "rightShift");
		DebugLocation(510, 1);
		try
		{
			// Gen.g:511:2: ( ^( '>>' l= binaryBitwiseExpression r= binaryBitwiseExpression ) -> rshift(lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:511:4: ^( '>>' l= binaryBitwiseExpression r= binaryBitwiseExpression )
			{
			DebugLocation(511, 4);
			DebugLocation(511, 6);
			Match(input,76,Follow._76_in_rightShift3367); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(511, 12);
			PushFollow(Follow._binaryBitwiseExpression_in_rightShift3371);
			l=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(511, 38);
			PushFollow(Follow._binaryBitwiseExpression_in_rightShift3375);
			r=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 512:3: -> rshift(lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("rshift",
					new Dictionary<string, object>() { {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rightShift", 37);
			LeaveRule("rightShift", 37);
			LeaveRule_rightShift();
		}
		DebugLocation(513, 1);
		} finally { DebugExitRule(GrammarFileName, "rightShift"); }
		return retval;

	}
	// $ANTLR end "rightShift"

	private sealed partial class additiveExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public additiveExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// Gen.g:515:1: additiveExpression : ( add -> {$add.st}| subtract -> {$subtract.st}| multiplicativeExpression -> {$multiplicativeExpression.st});
	[GrammarRule("additiveExpression")]
	private Gen.additiveExpression_return additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 38);
		TraceIn("additiveExpression", 38);
		Gen.additiveExpression_return retval = new Gen.additiveExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.add_return add50 = default(Gen.add_return);
		Gen.subtract_return subtract51 = default(Gen.subtract_return);
		Gen.multiplicativeExpression_return multiplicativeExpression52 = default(Gen.multiplicativeExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(515, 1);
		try
		{
			// Gen.g:518:2: ( add -> {$add.st}| subtract -> {$subtract.st}| multiplicativeExpression -> {$multiplicativeExpression.st})
			int alt53=3;
			try { DebugEnterDecision(53, false);
			switch (input.LA(1))
			{
			case 63:
				{
				alt53 = 1;
				}
				break;
			case MINUS:
				{
				alt53 = 2;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case METHOD_CALL:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
			case VECTOR_LITERAL:
			case 57:
			case 61:
			case 69:
				{
				alt53 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:518:4: add
				{
				DebugLocation(518, 4);
				PushFollow(Follow._add_in_additiveExpression3413);
				add50=add();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 518:8: -> {$add.st}
					{
						retval.Template = (add50!=null?add50.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:519:4: subtract
				{
				DebugLocation(519, 4);
				PushFollow(Follow._subtract_in_additiveExpression3422);
				subtract51=subtract();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 519:13: -> {$subtract.st}
					{
						retval.Template = (subtract51!=null?subtract51.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:520:4: multiplicativeExpression
				{
				DebugLocation(520, 4);
				PushFollow(Follow._multiplicativeExpression_in_additiveExpression3431);
				multiplicativeExpression52=multiplicativeExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 520:29: -> {$multiplicativeExpression.st}
					{
						retval.Template = (multiplicativeExpression52!=null?multiplicativeExpression52.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("additiveExpression", 38);
			LeaveRule("additiveExpression", 38);
			LeaveRule_additiveExpression();
		}
		DebugLocation(521, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	private sealed partial class subtract_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public subtract_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_subtract();
	partial void LeaveRule_subtract();

	// $ANTLR start "subtract"
	// Gen.g:523:1: subtract : ^(op= '-' l= additiveExpression r= additiveExpression ) -> subtract(subtemplate=TemplateMapping.Subtraction[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("subtract")]
	private Gen.subtract_return subtract()
	{
		EnterRule_subtract();
		EnterRule("subtract", 39);
		TraceIn("subtract", 39);
		Gen.subtract_return retval = new Gen.subtract_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst op = default(LSLAst);
		Gen.additiveExpression_return l = default(Gen.additiveExpression_return);
		Gen.additiveExpression_return r = default(Gen.additiveExpression_return);

		try { DebugEnterRule(GrammarFileName, "subtract");
		DebugLocation(523, 1);
		try
		{
			// Gen.g:524:2: ( ^(op= '-' l= additiveExpression r= additiveExpression ) -> subtract(subtemplate=TemplateMapping.Subtraction[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:524:4: ^(op= '-' l= additiveExpression r= additiveExpression )
			{
			DebugLocation(524, 4);
			DebugLocation(524, 8);
			op=(LSLAst)Match(input,MINUS,Follow._MINUS_in_subtract3449); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(524, 14);
			PushFollow(Follow._additiveExpression_in_subtract3453);
			l=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(524, 35);
			PushFollow(Follow._additiveExpression_in_subtract3457);
			r=additiveExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 525:3: -> subtract(subtemplate=TemplateMapping.Subtraction[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("subtract",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Subtraction[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("subtract", 39);
			LeaveRule("subtract", 39);
			LeaveRule_subtract();
		}
		DebugLocation(526, 1);
		} finally { DebugExitRule(GrammarFileName, "subtract"); }
		return retval;

	}
	// $ANTLR end "subtract"

	private sealed partial class add_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public add_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_add();
	partial void LeaveRule_add();

	// $ANTLR start "add"
	// Gen.g:528:1: add : ^(op= '+' l= additiveExpression r= additiveExpression ) -> add(subtemplate=TemplateMapping.Addition[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("add")]
	private Gen.add_return add()
	{
		EnterRule_add();
		EnterRule("add", 40);
		TraceIn("add", 40);
		Gen.add_return retval = new Gen.add_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst op = default(LSLAst);
		Gen.additiveExpression_return l = default(Gen.additiveExpression_return);
		Gen.additiveExpression_return r = default(Gen.additiveExpression_return);

		try { DebugEnterRule(GrammarFileName, "add");
		DebugLocation(528, 1);
		try
		{
			// Gen.g:529:2: ( ^(op= '+' l= additiveExpression r= additiveExpression ) -> add(subtemplate=TemplateMapping.Addition[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:529:4: ^(op= '+' l= additiveExpression r= additiveExpression )
			{
			DebugLocation(529, 4);
			DebugLocation(529, 8);
			op=(LSLAst)Match(input,63,Follow._63_in_add3493); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(529, 14);
			PushFollow(Follow._additiveExpression_in_add3497);
			l=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(529, 35);
			PushFollow(Follow._additiveExpression_in_add3501);
			r=additiveExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 530:3: -> add(subtemplate=TemplateMapping.Addition[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("add",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Addition[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("add", 40);
			LeaveRule("add", 40);
			LeaveRule_add();
		}
		DebugLocation(531, 1);
		} finally { DebugExitRule(GrammarFileName, "add"); }
		return retval;

	}
	// $ANTLR end "add"

	private sealed partial class multiplicativeExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public multiplicativeExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// Gen.g:534:1: multiplicativeExpression : ( mult -> {$mult.st}| div -> {$div.st}| mod -> {$mod.st}| unaryExpression -> {$unaryExpression.st});
	[GrammarRule("multiplicativeExpression")]
	private Gen.multiplicativeExpression_return multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 41);
		TraceIn("multiplicativeExpression", 41);
		Gen.multiplicativeExpression_return retval = new Gen.multiplicativeExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.mult_return mult53 = default(Gen.mult_return);
		Gen.div_return div54 = default(Gen.div_return);
		Gen.mod_return mod55 = default(Gen.mod_return);
		Gen.unaryExpression_return unaryExpression56 = default(Gen.unaryExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(534, 1);
		try
		{
			// Gen.g:537:2: ( mult -> {$mult.st}| div -> {$div.st}| mod -> {$mod.st}| unaryExpression -> {$unaryExpression.st})
			int alt54=4;
			try { DebugEnterDecision(54, false);
			switch (input.LA(1))
			{
			case 61:
				{
				alt54 = 1;
				}
				break;
			case 69:
				{
				alt54 = 2;
				}
				break;
			case 57:
				{
				alt54 = 3;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case METHOD_CALL:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
			case VECTOR_LITERAL:
				{
				alt54 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:537:4: mult
				{
				DebugLocation(537, 4);
				PushFollow(Follow._mult_in_multiplicativeExpression3545);
				mult53=mult();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 537:9: -> {$mult.st}
					{
						retval.Template = (mult53!=null?mult53.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:538:4: div
				{
				DebugLocation(538, 4);
				PushFollow(Follow._div_in_multiplicativeExpression3554);
				div54=div();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 538:8: -> {$div.st}
					{
						retval.Template = (div54!=null?div54.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:539:4: mod
				{
				DebugLocation(539, 4);
				PushFollow(Follow._mod_in_multiplicativeExpression3563);
				mod55=mod();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 539:8: -> {$mod.st}
					{
						retval.Template = (mod55!=null?mod55.Template:null);
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:540:4: unaryExpression
				{
				DebugLocation(540, 4);
				PushFollow(Follow._unaryExpression_in_multiplicativeExpression3572);
				unaryExpression56=unaryExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 540:20: -> {$unaryExpression.st}
					{
						retval.Template = (unaryExpression56!=null?unaryExpression56.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multiplicativeExpression", 41);
			LeaveRule("multiplicativeExpression", 41);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(541, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	private sealed partial class mod_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public mod_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_mod();
	partial void LeaveRule_mod();

	// $ANTLR start "mod"
	// Gen.g:543:1: mod : ^(op= '%' l= multiplicativeExpression r= multiplicativeExpression ) -> mod(subtemplate=TemplateMapping.Mod[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("mod")]
	private Gen.mod_return mod()
	{
		EnterRule_mod();
		EnterRule("mod", 42);
		TraceIn("mod", 42);
		Gen.mod_return retval = new Gen.mod_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst op = default(LSLAst);
		Gen.multiplicativeExpression_return l = default(Gen.multiplicativeExpression_return);
		Gen.multiplicativeExpression_return r = default(Gen.multiplicativeExpression_return);

		try { DebugEnterRule(GrammarFileName, "mod");
		DebugLocation(543, 1);
		try
		{
			// Gen.g:544:2: ( ^(op= '%' l= multiplicativeExpression r= multiplicativeExpression ) -> mod(subtemplate=TemplateMapping.Mod[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:544:4: ^(op= '%' l= multiplicativeExpression r= multiplicativeExpression )
			{
			DebugLocation(544, 4);
			DebugLocation(544, 8);
			op=(LSLAst)Match(input,57,Follow._57_in_mod3590); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(544, 14);
			PushFollow(Follow._multiplicativeExpression_in_mod3594);
			l=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(544, 41);
			PushFollow(Follow._multiplicativeExpression_in_mod3598);
			r=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 545:3: -> mod(subtemplate=TemplateMapping.Mod[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("mod",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Mod[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("mod", 42);
			LeaveRule("mod", 42);
			LeaveRule_mod();
		}
		DebugLocation(546, 1);
		} finally { DebugExitRule(GrammarFileName, "mod"); }
		return retval;

	}
	// $ANTLR end "mod"

	private sealed partial class div_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public div_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_div();
	partial void LeaveRule_div();

	// $ANTLR start "div"
	// Gen.g:548:1: div : ^(op= '/' l= multiplicativeExpression r= multiplicativeExpression ) -> div(subtemplate=TemplateMapping.Division[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("div")]
	private Gen.div_return div()
	{
		EnterRule_div();
		EnterRule("div", 43);
		TraceIn("div", 43);
		Gen.div_return retval = new Gen.div_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst op = default(LSLAst);
		Gen.multiplicativeExpression_return l = default(Gen.multiplicativeExpression_return);
		Gen.multiplicativeExpression_return r = default(Gen.multiplicativeExpression_return);

		try { DebugEnterRule(GrammarFileName, "div");
		DebugLocation(548, 1);
		try
		{
			// Gen.g:549:2: ( ^(op= '/' l= multiplicativeExpression r= multiplicativeExpression ) -> div(subtemplate=TemplateMapping.Division[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:549:4: ^(op= '/' l= multiplicativeExpression r= multiplicativeExpression )
			{
			DebugLocation(549, 4);
			DebugLocation(549, 8);
			op=(LSLAst)Match(input,69,Follow._69_in_div3634); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(549, 14);
			PushFollow(Follow._multiplicativeExpression_in_div3638);
			l=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(549, 41);
			PushFollow(Follow._multiplicativeExpression_in_div3642);
			r=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 550:3: -> div(subtemplate=TemplateMapping.Division[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("div",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Division[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("div", 43);
			LeaveRule("div", 43);
			LeaveRule_div();
		}
		DebugLocation(551, 1);
		} finally { DebugExitRule(GrammarFileName, "div"); }
		return retval;

	}
	// $ANTLR end "div"

	private sealed partial class mult_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public mult_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_mult();
	partial void LeaveRule_mult();

	// $ANTLR start "mult"
	// Gen.g:553:1: mult : ^(op= '*' l= multiplicativeExpression r= multiplicativeExpression ) -> mul(subtemplate=TemplateMapping.Multiplication[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st);
	[GrammarRule("mult")]
	private Gen.mult_return mult()
	{
		EnterRule_mult();
		EnterRule("mult", 44);
		TraceIn("mult", 44);
		Gen.mult_return retval = new Gen.mult_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst op = default(LSLAst);
		Gen.multiplicativeExpression_return l = default(Gen.multiplicativeExpression_return);
		Gen.multiplicativeExpression_return r = default(Gen.multiplicativeExpression_return);

		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(553, 1);
		try
		{
			// Gen.g:554:2: ( ^(op= '*' l= multiplicativeExpression r= multiplicativeExpression ) -> mul(subtemplate=TemplateMapping.Multiplication[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st))
			DebugEnterAlt(1);
			// Gen.g:554:4: ^(op= '*' l= multiplicativeExpression r= multiplicativeExpression )
			{
			DebugLocation(554, 4);
			DebugLocation(554, 8);
			op=(LSLAst)Match(input,61,Follow._61_in_mult3678); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(554, 14);
			PushFollow(Follow._multiplicativeExpression_in_mult3682);
			l=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(554, 41);
			PushFollow(Follow._multiplicativeExpression_in_mult3686);
			r=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 555:3: -> mul(subtemplate=TemplateMapping.Multiplication[$l.start.evalType.TypeIndex, $r.start.evalType.TypeIndex]lexpr=$l.strexpr=$r.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("mul",
					new Dictionary<string, object>() { {"subtemplate", TemplateMapping.Multiplication[(l!=null?((LSLAst)l.Start):default(LSLAst)).evalType.TypeIndex, (r!=null?((LSLAst)r.Start):default(LSLAst)).evalType.TypeIndex]}, {"lexpr", (l!=null?l.Template:null)}, {"rexpr", (r!=null?r.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("mult", 44);
			LeaveRule("mult", 44);
			LeaveRule_mult();
		}
		DebugLocation(556, 1);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return retval;

	}
	// $ANTLR end "mult"

	private sealed partial class unaryExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public unaryExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();

	// $ANTLR start "unaryExpression"
	// Gen.g:558:1: unaryExpression : ( unaryMinus -> {$unaryMinus.st}| unaryBoolNot -> {$unaryBoolNot.st}| uBitNot -> {$uBitNot.st}| typeCastExpression -> {$typeCastExpression.st});
	[GrammarRule("unaryExpression")]
	private Gen.unaryExpression_return unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 45);
		TraceIn("unaryExpression", 45);
		Gen.unaryExpression_return retval = new Gen.unaryExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.unaryMinus_return unaryMinus57 = default(Gen.unaryMinus_return);
		Gen.unaryBoolNot_return unaryBoolNot58 = default(Gen.unaryBoolNot_return);
		Gen.uBitNot_return uBitNot59 = default(Gen.uBitNot_return);
		Gen.typeCastExpression_return typeCastExpression60 = default(Gen.typeCastExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(558, 1);
		try
		{
			// Gen.g:561:2: ( unaryMinus -> {$unaryMinus.st}| unaryBoolNot -> {$unaryBoolNot.st}| uBitNot -> {$uBitNot.st}| typeCastExpression -> {$typeCastExpression.st})
			int alt55=4;
			try { DebugEnterDecision(55, false);
			switch (input.LA(1))
			{
			case UNARY_MINUS:
				{
				alt55 = 1;
				}
				break;
			case UNARY_BOOL_NOT:
				{
				alt55 = 2;
				}
				break;
			case UNARY_BIT_NOT:
				{
				alt55 = 3;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case METHOD_CALL:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case TYPE_CAST:
			case VECTOR_LITERAL:
				{
				alt55 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:561:4: unaryMinus
				{
				DebugLocation(561, 4);
				PushFollow(Follow._unaryMinus_in_unaryExpression3729);
				unaryMinus57=unaryMinus();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 561:15: -> {$unaryMinus.st}
					{
						retval.Template = (unaryMinus57!=null?unaryMinus57.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:562:4: unaryBoolNot
				{
				DebugLocation(562, 4);
				PushFollow(Follow._unaryBoolNot_in_unaryExpression3738);
				unaryBoolNot58=unaryBoolNot();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 562:17: -> {$unaryBoolNot.st}
					{
						retval.Template = (unaryBoolNot58!=null?unaryBoolNot58.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:563:4: uBitNot
				{
				DebugLocation(563, 4);
				PushFollow(Follow._uBitNot_in_unaryExpression3747);
				uBitNot59=uBitNot();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 563:12: -> {$uBitNot.st}
					{
						retval.Template = (uBitNot59!=null?uBitNot59.Template:null);
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:564:4: typeCastExpression
				{
				DebugLocation(564, 4);
				PushFollow(Follow._typeCastExpression_in_unaryExpression3756);
				typeCastExpression60=typeCastExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 564:23: -> {$typeCastExpression.st}
					{
						retval.Template = (typeCastExpression60!=null?typeCastExpression60.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryExpression", 45);
			LeaveRule("unaryExpression", 45);
			LeaveRule_unaryExpression();
		}
		DebugLocation(565, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	private sealed partial class uBitNot_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public uBitNot_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_uBitNot();
	partial void LeaveRule_uBitNot();

	// $ANTLR start "uBitNot"
	// Gen.g:567:1: uBitNot : ^( UNARY_BIT_NOT unaryExpression ) -> ubitnot(expr=$unaryExpression.st);
	[GrammarRule("uBitNot")]
	private Gen.uBitNot_return uBitNot()
	{
		EnterRule_uBitNot();
		EnterRule("uBitNot", 46);
		TraceIn("uBitNot", 46);
		Gen.uBitNot_return retval = new Gen.uBitNot_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.unaryExpression_return unaryExpression61 = default(Gen.unaryExpression_return);

		try { DebugEnterRule(GrammarFileName, "uBitNot");
		DebugLocation(567, 1);
		try
		{
			// Gen.g:568:2: ( ^( UNARY_BIT_NOT unaryExpression ) -> ubitnot(expr=$unaryExpression.st))
			DebugEnterAlt(1);
			// Gen.g:568:4: ^( UNARY_BIT_NOT unaryExpression )
			{
			DebugLocation(568, 4);
			DebugLocation(568, 6);
			Match(input,UNARY_BIT_NOT,Follow._UNARY_BIT_NOT_in_uBitNot3772); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(568, 20);
			PushFollow(Follow._unaryExpression_in_uBitNot3774);
			unaryExpression61=unaryExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 569:3: -> ubitnot(expr=$unaryExpression.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("ubitnot",
					new Dictionary<string, object>() { {"expr", (unaryExpression61!=null?unaryExpression61.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("uBitNot", 46);
			LeaveRule("uBitNot", 46);
			LeaveRule_uBitNot();
		}
		DebugLocation(570, 1);
		} finally { DebugExitRule(GrammarFileName, "uBitNot"); }
		return retval;

	}
	// $ANTLR end "uBitNot"

	private sealed partial class unaryBoolNot_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public unaryBoolNot_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_unaryBoolNot();
	partial void LeaveRule_unaryBoolNot();

	// $ANTLR start "unaryBoolNot"
	// Gen.g:572:1: unaryBoolNot : ^( UNARY_BOOL_NOT unaryExpression ) -> ilnot(expr=$unaryExpression.st);
	[GrammarRule("unaryBoolNot")]
	private Gen.unaryBoolNot_return unaryBoolNot()
	{
		EnterRule_unaryBoolNot();
		EnterRule("unaryBoolNot", 47);
		TraceIn("unaryBoolNot", 47);
		Gen.unaryBoolNot_return retval = new Gen.unaryBoolNot_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.unaryExpression_return unaryExpression62 = default(Gen.unaryExpression_return);

		try { DebugEnterRule(GrammarFileName, "unaryBoolNot");
		DebugLocation(572, 1);
		try
		{
			// Gen.g:573:2: ( ^( UNARY_BOOL_NOT unaryExpression ) -> ilnot(expr=$unaryExpression.st))
			DebugEnterAlt(1);
			// Gen.g:573:4: ^( UNARY_BOOL_NOT unaryExpression )
			{
			DebugLocation(573, 4);
			DebugLocation(573, 6);
			Match(input,UNARY_BOOL_NOT,Follow._UNARY_BOOL_NOT_in_unaryBoolNot3798); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(573, 21);
			PushFollow(Follow._unaryExpression_in_unaryBoolNot3800);
			unaryExpression62=unaryExpression();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 574:3: -> ilnot(expr=$unaryExpression.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("ilnot",
					new Dictionary<string, object>() { {"expr", (unaryExpression62!=null?unaryExpression62.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryBoolNot", 47);
			LeaveRule("unaryBoolNot", 47);
			LeaveRule_unaryBoolNot();
		}
		DebugLocation(575, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryBoolNot"); }
		return retval;

	}
	// $ANTLR end "unaryBoolNot"

	private sealed partial class unaryMinus_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public unaryMinus_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_unaryMinus();
	partial void LeaveRule_unaryMinus();

	// $ANTLR start "unaryMinus"
	// Gen.g:577:1: unaryMinus : ( ^( UNARY_MINUS INTEGER_LITERAL ) -> iconst(constText=\"-\" + $INTEGER_LITERAL.text)| ^( UNARY_MINUS FLOAT_LITERAL ) -> fconst(constText=\"-\" + FormatFloat($FLOAT_LITERAL.text))| ^( UNARY_MINUS unaryExpression ) {...}? -> ineg(expr=$unaryExpression.st)| ^( UNARY_MINUS unaryExpression ) {...}? -> fneg(expr=$unaryExpression.st)| ^( UNARY_MINUS unaryExpression ) {...}? -> vneg(expr=$unaryExpression.st)| ^( UNARY_MINUS unaryExpression ) {...}? -> rneg(expr=$unaryExpression.st));
	[GrammarRule("unaryMinus")]
	private Gen.unaryMinus_return unaryMinus()
	{
		EnterRule_unaryMinus();
		EnterRule("unaryMinus", 48);
		TraceIn("unaryMinus", 48);
		Gen.unaryMinus_return retval = new Gen.unaryMinus_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst INTEGER_LITERAL63 = default(LSLAst);
		LSLAst FLOAT_LITERAL64 = default(LSLAst);
		Gen.unaryExpression_return unaryExpression65 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression66 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression67 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression68 = default(Gen.unaryExpression_return);

		try { DebugEnterRule(GrammarFileName, "unaryMinus");
		DebugLocation(577, 1);
		try
		{
			// Gen.g:578:2: ( ^( UNARY_MINUS INTEGER_LITERAL ) -> iconst(constText=\"-\" + $INTEGER_LITERAL.text)| ^( UNARY_MINUS FLOAT_LITERAL ) -> fconst(constText=\"-\" + FormatFloat($FLOAT_LITERAL.text))| ^( UNARY_MINUS unaryExpression ) {...}? -> ineg(expr=$unaryExpression.st)| ^( UNARY_MINUS unaryExpression ) {...}? -> fneg(expr=$unaryExpression.st)| ^( UNARY_MINUS unaryExpression ) {...}? -> vneg(expr=$unaryExpression.st)| ^( UNARY_MINUS unaryExpression ) {...}? -> rneg(expr=$unaryExpression.st))
			int alt56=6;
			try { DebugEnterDecision(56, false);
			int LA56_0 = input.LA(1);

			if ((LA56_0==UNARY_MINUS))
			{
				int LA56_1 = input.LA(2);

				if ((EvaluatePredicate(synpred94_Gen_fragment)))
				{
					alt56 = 1;
				}
				else if ((EvaluatePredicate(synpred95_Gen_fragment)))
				{
					alt56 = 2;
				}
				else if ((EvaluatePredicate(synpred96_Gen_fragment)))
				{
					alt56 = 3;
				}
				else if ((EvaluatePredicate(synpred97_Gen_fragment)))
				{
					alt56 = 4;
				}
				else if ((EvaluatePredicate(synpred98_Gen_fragment)))
				{
					alt56 = 5;
				}
				else if ((true))
				{
					alt56 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 56, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 56, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(56); }
			switch (alt56)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:579:3: ^( UNARY_MINUS INTEGER_LITERAL )
				{
				DebugLocation(579, 3);
				DebugLocation(579, 5);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_unaryMinus3828); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(579, 17);
				INTEGER_LITERAL63=(LSLAst)Match(input,INTEGER_LITERAL,Follow._INTEGER_LITERAL_in_unaryMinus3830); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 580:3: -> iconst(constText=\"-\" + $INTEGER_LITERAL.text)
					{
						retval.Template = TemplateGroup.GetInstanceOf("iconst",
						new Dictionary<string, object>() { {"constText", "-" + (INTEGER_LITERAL63!=null?INTEGER_LITERAL63.Text:null)} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:582:3: ^( UNARY_MINUS FLOAT_LITERAL )
				{
				DebugLocation(582, 3);
				DebugLocation(582, 5);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_unaryMinus3850); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(582, 17);
				FLOAT_LITERAL64=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_unaryMinus3852); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 583:3: -> fconst(constText=\"-\" + FormatFloat($FLOAT_LITERAL.text))
					{
						retval.Template = TemplateGroup.GetInstanceOf("fconst",
						new Dictionary<string, object>() { {"constText", "-" + FormatFloat((FLOAT_LITERAL64!=null?FLOAT_LITERAL64.Text:null))} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:585:3: ^( UNARY_MINUS unaryExpression ) {...}?
				{
				DebugLocation(585, 3);
				DebugLocation(585, 5);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_unaryMinus3872); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(585, 17);
				PushFollow(Follow._unaryExpression_in_unaryMinus3874);
				unaryExpression65=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(585, 34);
				if (!(((unaryExpression65!=null?((LSLAst)unaryExpression65.Start):default(LSLAst)).evalType == SymbolTable.INT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "unaryMinus", "$unaryExpression.start.evalType == SymbolTable.INT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 586:3: -> ineg(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("ineg",
						new Dictionary<string, object>() { {"expr", (unaryExpression65!=null?unaryExpression65.Template:null)} });
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:588:3: ^( UNARY_MINUS unaryExpression ) {...}?
				{
				DebugLocation(588, 3);
				DebugLocation(588, 5);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_unaryMinus3896); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(588, 17);
				PushFollow(Follow._unaryExpression_in_unaryMinus3898);
				unaryExpression66=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(588, 34);
				if (!(((unaryExpression66!=null?((LSLAst)unaryExpression66.Start):default(LSLAst)).evalType == SymbolTable.FLOAT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "unaryMinus", "$unaryExpression.start.evalType == SymbolTable.FLOAT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 589:3: -> fneg(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("fneg",
						new Dictionary<string, object>() { {"expr", (unaryExpression66!=null?unaryExpression66.Template:null)} });
					}

				}
				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Gen.g:591:3: ^( UNARY_MINUS unaryExpression ) {...}?
				{
				DebugLocation(591, 3);
				DebugLocation(591, 5);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_unaryMinus3920); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(591, 17);
				PushFollow(Follow._unaryExpression_in_unaryMinus3922);
				unaryExpression67=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(591, 34);
				if (!(((unaryExpression67!=null?((LSLAst)unaryExpression67.Start):default(LSLAst)).evalType == SymbolTable.VECTOR)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "unaryMinus", "$unaryExpression.start.evalType == SymbolTable.VECTOR");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 592:3: -> vneg(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("vneg",
						new Dictionary<string, object>() { {"expr", (unaryExpression67!=null?unaryExpression67.Template:null)} });
					}

				}
				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Gen.g:594:3: ^( UNARY_MINUS unaryExpression ) {...}?
				{
				DebugLocation(594, 3);
				DebugLocation(594, 5);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_unaryMinus3944); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(594, 17);
				PushFollow(Follow._unaryExpression_in_unaryMinus3946);
				unaryExpression68=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(594, 34);
				if (!(((unaryExpression68!=null?((LSLAst)unaryExpression68.Start):default(LSLAst)).evalType == SymbolTable.ROTATION)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "unaryMinus", "$unaryExpression.start.evalType == SymbolTable.ROTATION");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 595:3: -> rneg(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("rneg",
						new Dictionary<string, object>() { {"expr", (unaryExpression68!=null?unaryExpression68.Template:null)} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryMinus", 48);
			LeaveRule("unaryMinus", 48);
			LeaveRule_unaryMinus();
		}
		DebugLocation(596, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryMinus"); }
		return retval;

	}
	// $ANTLR end "unaryMinus"

	private sealed partial class typeCastExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public typeCastExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_typeCastExpression();
	partial void LeaveRule_typeCastExpression();

	// $ANTLR start "typeCastExpression"
	// Gen.g:598:1: typeCastExpression : ( typeCast -> {$typeCast.st}| preIncDecExpression -> {$preIncDecExpression.st});
	[GrammarRule("typeCastExpression")]
	private Gen.typeCastExpression_return typeCastExpression()
	{
		EnterRule_typeCastExpression();
		EnterRule("typeCastExpression", 49);
		TraceIn("typeCastExpression", 49);
		Gen.typeCastExpression_return retval = new Gen.typeCastExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.typeCast_return typeCast69 = default(Gen.typeCast_return);
		Gen.preIncDecExpression_return preIncDecExpression70 = default(Gen.preIncDecExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "typeCastExpression");
		DebugLocation(598, 1);
		try
		{
			// Gen.g:601:2: ( typeCast -> {$typeCast.st}| preIncDecExpression -> {$preIncDecExpression.st})
			int alt57=2;
			try { DebugEnterDecision(57, false);
			int LA57_0 = input.LA(1);

			if ((LA57_0==TYPE_CAST))
			{
				alt57 = 1;
			}
			else if (((LA57_0>=EXPR && LA57_0<=FLOAT_LITERAL)||LA57_0==ID||LA57_0==INTEGER_LITERAL||LA57_0==LIST_LITERAL||LA57_0==METHOD_CALL||(LA57_0>=POST_DECREMENT && LA57_0<=PRE_INCREMENT)||LA57_0==ROTATION_LITERAL||(LA57_0>=STRING_LITERAL && LA57_0<=SUBSCRIPT)||LA57_0==VECTOR_LITERAL))
			{
				alt57 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:601:4: typeCast
				{
				DebugLocation(601, 4);
				PushFollow(Follow._typeCast_in_typeCastExpression3981);
				typeCast69=typeCast();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 601:13: -> {$typeCast.st}
					{
						retval.Template = (typeCast69!=null?typeCast69.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:602:4: preIncDecExpression
				{
				DebugLocation(602, 4);
				PushFollow(Follow._preIncDecExpression_in_typeCastExpression3990);
				preIncDecExpression70=preIncDecExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 602:24: -> {$preIncDecExpression.st}
					{
						retval.Template = (preIncDecExpression70!=null?preIncDecExpression70.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeCastExpression", 49);
			LeaveRule("typeCastExpression", 49);
			LeaveRule_typeCastExpression();
		}
		DebugLocation(603, 1);
		} finally { DebugExitRule(GrammarFileName, "typeCastExpression"); }
		return retval;

	}
	// $ANTLR end "typeCastExpression"

	private sealed partial class typeCast_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public typeCast_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_typeCast();
	partial void LeaveRule_typeCast();

	// $ANTLR start "typeCast"
	// Gen.g:605:1: typeCast : ( ^( TYPE_CAST TYPE unaryExpression ) {...}? -> icast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> fcast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> scast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> scast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> vcast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> rcast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> lcast(expr=$unaryExpression.st));
	[GrammarRule("typeCast")]
	private Gen.typeCast_return typeCast()
	{
		EnterRule_typeCast();
		EnterRule("typeCast", 50);
		TraceIn("typeCast", 50);
		Gen.typeCast_return retval = new Gen.typeCast_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst TYPE_CAST71 = default(LSLAst);
		LSLAst TYPE_CAST73 = default(LSLAst);
		LSLAst TYPE_CAST75 = default(LSLAst);
		LSLAst TYPE_CAST77 = default(LSLAst);
		LSLAst TYPE_CAST79 = default(LSLAst);
		LSLAst TYPE_CAST81 = default(LSLAst);
		LSLAst TYPE_CAST83 = default(LSLAst);
		Gen.unaryExpression_return unaryExpression72 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression74 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression76 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression78 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression80 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression82 = default(Gen.unaryExpression_return);
		Gen.unaryExpression_return unaryExpression84 = default(Gen.unaryExpression_return);

		try { DebugEnterRule(GrammarFileName, "typeCast");
		DebugLocation(605, 1);
		try
		{
			// Gen.g:606:2: ( ^( TYPE_CAST TYPE unaryExpression ) {...}? -> icast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> fcast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> scast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> scast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> vcast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> rcast(expr=$unaryExpression.st)| ^( TYPE_CAST TYPE unaryExpression ) {...}? -> lcast(expr=$unaryExpression.st))
			int alt58=7;
			try { DebugEnterDecision(58, false);
			int LA58_0 = input.LA(1);

			if ((LA58_0==TYPE_CAST))
			{
				int LA58_1 = input.LA(2);

				if ((EvaluatePredicate(synpred100_Gen_fragment)))
				{
					alt58 = 1;
				}
				else if ((EvaluatePredicate(synpred101_Gen_fragment)))
				{
					alt58 = 2;
				}
				else if ((EvaluatePredicate(synpred102_Gen_fragment)))
				{
					alt58 = 3;
				}
				else if ((EvaluatePredicate(synpred103_Gen_fragment)))
				{
					alt58 = 4;
				}
				else if ((EvaluatePredicate(synpred104_Gen_fragment)))
				{
					alt58 = 5;
				}
				else if ((EvaluatePredicate(synpred105_Gen_fragment)))
				{
					alt58 = 6;
				}
				else if ((true))
				{
					alt58 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 58, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:606:4: ^( TYPE_CAST TYPE unaryExpression ) {...}?
				{
				DebugLocation(606, 4);
				DebugLocation(606, 6);
				TYPE_CAST71=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast4006); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(606, 16);
				Match(input,TYPE,Follow._TYPE_in_typeCast4008); if (state.failed) return retval;
				DebugLocation(606, 21);
				PushFollow(Follow._unaryExpression_in_typeCast4010);
				unaryExpression72=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(606, 38);
				if (!((TYPE_CAST71.evalType == SymbolTable.INT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "typeCast", "$TYPE_CAST.evalType == SymbolTable.INT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 607:3: -> icast(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("icast",
						new Dictionary<string, object>() { {"expr", (unaryExpression72!=null?unaryExpression72.Template:null)} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:609:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
				{
				DebugLocation(609, 3);
				DebugLocation(609, 5);
				TYPE_CAST73=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast4032); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(609, 15);
				Match(input,TYPE,Follow._TYPE_in_typeCast4034); if (state.failed) return retval;
				DebugLocation(609, 20);
				PushFollow(Follow._unaryExpression_in_typeCast4036);
				unaryExpression74=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(609, 37);
				if (!((TYPE_CAST73.evalType == SymbolTable.FLOAT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "typeCast", "$TYPE_CAST.evalType == SymbolTable.FLOAT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 610:3: -> fcast(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("fcast",
						new Dictionary<string, object>() { {"expr", (unaryExpression74!=null?unaryExpression74.Template:null)} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:612:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
				{
				DebugLocation(612, 3);
				DebugLocation(612, 5);
				TYPE_CAST75=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast4058); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(612, 15);
				Match(input,TYPE,Follow._TYPE_in_typeCast4060); if (state.failed) return retval;
				DebugLocation(612, 20);
				PushFollow(Follow._unaryExpression_in_typeCast4062);
				unaryExpression76=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(612, 37);
				if (!((TYPE_CAST75.evalType == SymbolTable.STRING)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "typeCast", "$TYPE_CAST.evalType == SymbolTable.STRING");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 613:3: -> scast(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("scast",
						new Dictionary<string, object>() { {"expr", (unaryExpression76!=null?unaryExpression76.Template:null)} });
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:615:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
				{
				DebugLocation(615, 3);
				DebugLocation(615, 5);
				TYPE_CAST77=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast4084); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(615, 15);
				Match(input,TYPE,Follow._TYPE_in_typeCast4086); if (state.failed) return retval;
				DebugLocation(615, 20);
				PushFollow(Follow._unaryExpression_in_typeCast4088);
				unaryExpression78=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(615, 37);
				if (!((TYPE_CAST77.evalType == SymbolTable.KEY)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "typeCast", "$TYPE_CAST.evalType == SymbolTable.KEY");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 616:3: -> scast(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("scast",
						new Dictionary<string, object>() { {"expr", (unaryExpression78!=null?unaryExpression78.Template:null)} });
					}

				}
				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Gen.g:618:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
				{
				DebugLocation(618, 3);
				DebugLocation(618, 5);
				TYPE_CAST79=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast4110); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(618, 15);
				Match(input,TYPE,Follow._TYPE_in_typeCast4112); if (state.failed) return retval;
				DebugLocation(618, 20);
				PushFollow(Follow._unaryExpression_in_typeCast4114);
				unaryExpression80=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(618, 37);
				if (!((TYPE_CAST79.evalType == SymbolTable.VECTOR)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "typeCast", "$TYPE_CAST.evalType == SymbolTable.VECTOR");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 619:3: -> vcast(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("vcast",
						new Dictionary<string, object>() { {"expr", (unaryExpression80!=null?unaryExpression80.Template:null)} });
					}

				}
				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Gen.g:621:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
				{
				DebugLocation(621, 3);
				DebugLocation(621, 5);
				TYPE_CAST81=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast4136); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(621, 15);
				Match(input,TYPE,Follow._TYPE_in_typeCast4138); if (state.failed) return retval;
				DebugLocation(621, 20);
				PushFollow(Follow._unaryExpression_in_typeCast4140);
				unaryExpression82=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(621, 37);
				if (!((TYPE_CAST81.evalType == SymbolTable.ROTATION)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "typeCast", "$TYPE_CAST.evalType == SymbolTable.ROTATION");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 622:3: -> rcast(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("rcast",
						new Dictionary<string, object>() { {"expr", (unaryExpression82!=null?unaryExpression82.Template:null)} });
					}

				}
				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Gen.g:624:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
				{
				DebugLocation(624, 3);
				DebugLocation(624, 5);
				TYPE_CAST83=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast4162); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(624, 15);
				Match(input,TYPE,Follow._TYPE_in_typeCast4164); if (state.failed) return retval;
				DebugLocation(624, 20);
				PushFollow(Follow._unaryExpression_in_typeCast4166);
				unaryExpression84=unaryExpression();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(624, 37);
				if (!((TYPE_CAST83.evalType == SymbolTable.LIST)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "typeCast", "$TYPE_CAST.evalType == SymbolTable.LIST");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 625:3: -> lcast(expr=$unaryExpression.st)
					{
						retval.Template = TemplateGroup.GetInstanceOf("lcast",
						new Dictionary<string, object>() { {"expr", (unaryExpression84!=null?unaryExpression84.Template:null)} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeCast", 50);
			LeaveRule("typeCast", 50);
			LeaveRule_typeCast();
		}
		DebugLocation(626, 1);
		} finally { DebugExitRule(GrammarFileName, "typeCast"); }
		return retval;

	}
	// $ANTLR end "typeCast"

	private sealed partial class preIncDecExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public preIncDecExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_preIncDecExpression();
	partial void LeaveRule_preIncDecExpression();

	// $ANTLR start "preIncDecExpression"
	// Gen.g:628:1: preIncDecExpression : ( preIncrement -> {$preIncrement.st}| preDecrement -> {$preDecrement.st}| postfixExpression -> {$postfixExpression.st});
	[GrammarRule("preIncDecExpression")]
	private Gen.preIncDecExpression_return preIncDecExpression()
	{
		EnterRule_preIncDecExpression();
		EnterRule("preIncDecExpression", 51);
		TraceIn("preIncDecExpression", 51);
		Gen.preIncDecExpression_return retval = new Gen.preIncDecExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.preIncrement_return preIncrement85 = default(Gen.preIncrement_return);
		Gen.preDecrement_return preDecrement86 = default(Gen.preDecrement_return);
		Gen.postfixExpression_return postfixExpression87 = default(Gen.postfixExpression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "preIncDecExpression");
		DebugLocation(628, 1);
		try
		{
			// Gen.g:631:2: ( preIncrement -> {$preIncrement.st}| preDecrement -> {$preDecrement.st}| postfixExpression -> {$postfixExpression.st})
			int alt59=3;
			try { DebugEnterDecision(59, false);
			switch (input.LA(1))
			{
			case PRE_INCREMENT:
				{
				alt59 = 1;
				}
				break;
			case PRE_DECREMENT:
				{
				alt59 = 2;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case METHOD_CALL:
			case POST_DECREMENT:
			case POST_INCREMENT:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case SUBSCRIPT:
			case VECTOR_LITERAL:
				{
				alt59 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 59, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:631:4: preIncrement
				{
				DebugLocation(631, 4);
				PushFollow(Follow._preIncrement_in_preIncDecExpression4201);
				preIncrement85=preIncrement();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 631:17: -> {$preIncrement.st}
					{
						retval.Template = (preIncrement85!=null?preIncrement85.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:632:4: preDecrement
				{
				DebugLocation(632, 4);
				PushFollow(Follow._preDecrement_in_preIncDecExpression4210);
				preDecrement86=preDecrement();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 632:17: -> {$preDecrement.st}
					{
						retval.Template = (preDecrement86!=null?preDecrement86.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:633:4: postfixExpression
				{
				DebugLocation(633, 4);
				PushFollow(Follow._postfixExpression_in_preIncDecExpression4219);
				postfixExpression87=postfixExpression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 633:22: -> {$postfixExpression.st}
					{
						retval.Template = (postfixExpression87!=null?postfixExpression87.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("preIncDecExpression", 51);
			LeaveRule("preIncDecExpression", 51);
			LeaveRule_preIncDecExpression();
		}
		DebugLocation(634, 1);
		} finally { DebugExitRule(GrammarFileName, "preIncDecExpression"); }
		return retval;

	}
	// $ANTLR end "preIncDecExpression"

	private sealed partial class preDecrement_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public preDecrement_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_preDecrement();
	partial void LeaveRule_preDecrement();

	// $ANTLR start "preDecrement"
	// Gen.g:636:1: preDecrement : ( ^( PRE_DECREMENT ID ) {...}? -> ipredec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_DECREMENT ID ) {...}? -> fpredec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_DECREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpredecsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)));
	[GrammarRule("preDecrement")]
	private Gen.preDecrement_return preDecrement()
	{
		EnterRule_preDecrement();
		EnterRule("preDecrement", 52);
		TraceIn("preDecrement", 52);
		Gen.preDecrement_return retval = new Gen.preDecrement_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		LSLAst ID88 = default(LSLAst);
		LSLAst ID89 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "preDecrement");
		DebugLocation(636, 1);
		try
		{
			// Gen.g:637:2: ( ^( PRE_DECREMENT ID ) {...}? -> ipredec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_DECREMENT ID ) {...}? -> fpredec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_DECREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpredecsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)))
			int alt60=3;
			try { DebugEnterDecision(60, false);
			int LA60_0 = input.LA(1);

			if ((LA60_0==PRE_DECREMENT))
			{
				int LA60_1 = input.LA(2);

				if ((LA60_1==DOWN))
				{
					int LA60_2 = input.LA(3);

					if ((LA60_2==ID))
					{
						int LA60_3 = input.LA(4);

						if ((LA60_3==UP))
						{
							int LA60_5 = input.LA(5);

							if ((EvaluatePredicate(synpred108_Gen_fragment)))
							{
								alt60 = 1;
							}
							else if ((EvaluatePredicate(synpred109_Gen_fragment)))
							{
								alt60 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 60, 5, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 60, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA60_2==SUBSCRIPT))
					{
						alt60 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 60, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:637:4: ^( PRE_DECREMENT ID ) {...}?
				{
				DebugLocation(637, 4);
				DebugLocation(637, 6);
				Match(input,PRE_DECREMENT,Follow._PRE_DECREMENT_in_preDecrement4235); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(637, 20);
				ID88=(LSLAst)Match(input,ID,Follow._ID_in_preDecrement4237); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(637, 24);
				if (!((ID88.evalType == SymbolTable.INT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "preDecrement", "$ID.evalType == SymbolTable.INT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 638:3: -> ipredec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("ipredec",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID88.symbol).IsGlobal}, {"index", ((VariableSymbol)ID88.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:643:3: ^( PRE_DECREMENT ID ) {...}?
				{
				DebugLocation(643, 3);
				DebugLocation(643, 5);
				Match(input,PRE_DECREMENT,Follow._PRE_DECREMENT_in_preDecrement4274); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(643, 19);
				ID89=(LSLAst)Match(input,ID,Follow._ID_in_preDecrement4276); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(643, 23);
				if (!((ID89.evalType == SymbolTable.FLOAT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "preDecrement", "$ID.evalType == SymbolTable.FLOAT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 644:3: -> fpredec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpredec",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID89.symbol).IsGlobal}, {"index", ((VariableSymbol)ID89.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:649:3: ^( PRE_DECREMENT ^( SUBSCRIPT var= ID sub= ID ) )
				{
				DebugLocation(649, 3);
				DebugLocation(649, 5);
				Match(input,PRE_DECREMENT,Follow._PRE_DECREMENT_in_preDecrement4313); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(649, 19);
				DebugLocation(649, 21);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_preDecrement4316); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(649, 34);
				var=(LSLAst)Match(input,ID,Follow._ID_in_preDecrement4320); if (state.failed) return retval;
				DebugLocation(649, 41);
				sub=(LSLAst)Match(input,ID,Follow._ID_in_preDecrement4324); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 650:3: -> fpredecsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text))
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpredecsub",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("preDecrement", 52);
			LeaveRule("preDecrement", 52);
			LeaveRule_preDecrement();
		}
		DebugLocation(656, 1);
		} finally { DebugExitRule(GrammarFileName, "preDecrement"); }
		return retval;

	}
	// $ANTLR end "preDecrement"

	private sealed partial class preIncrement_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public preIncrement_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_preIncrement();
	partial void LeaveRule_preIncrement();

	// $ANTLR start "preIncrement"
	// Gen.g:658:1: preIncrement : ( ^( PRE_INCREMENT ID ) {...}? -> ipreinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_INCREMENT ID ) {...}? -> fpreinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_INCREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpreincsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)));
	[GrammarRule("preIncrement")]
	private Gen.preIncrement_return preIncrement()
	{
		EnterRule_preIncrement();
		EnterRule("preIncrement", 53);
		TraceIn("preIncrement", 53);
		Gen.preIncrement_return retval = new Gen.preIncrement_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		LSLAst ID90 = default(LSLAst);
		LSLAst ID91 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "preIncrement");
		DebugLocation(658, 1);
		try
		{
			// Gen.g:659:2: ( ^( PRE_INCREMENT ID ) {...}? -> ipreinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_INCREMENT ID ) {...}? -> fpreinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( PRE_INCREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpreincsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)))
			int alt61=3;
			try { DebugEnterDecision(61, false);
			int LA61_0 = input.LA(1);

			if ((LA61_0==PRE_INCREMENT))
			{
				int LA61_1 = input.LA(2);

				if ((LA61_1==DOWN))
				{
					int LA61_2 = input.LA(3);

					if ((LA61_2==ID))
					{
						int LA61_3 = input.LA(4);

						if ((LA61_3==UP))
						{
							int LA61_5 = input.LA(5);

							if ((EvaluatePredicate(synpred110_Gen_fragment)))
							{
								alt61 = 1;
							}
							else if ((EvaluatePredicate(synpred111_Gen_fragment)))
							{
								alt61 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 61, 5, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 61, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA61_2==SUBSCRIPT))
					{
						alt61 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 61, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 61, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 61, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:659:4: ^( PRE_INCREMENT ID ) {...}?
				{
				DebugLocation(659, 4);
				DebugLocation(659, 6);
				Match(input,PRE_INCREMENT,Follow._PRE_INCREMENT_in_preIncrement4375); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(659, 20);
				ID90=(LSLAst)Match(input,ID,Follow._ID_in_preIncrement4377); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(659, 24);
				if (!((ID90.evalType == SymbolTable.INT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "preIncrement", "$ID.evalType == SymbolTable.INT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 660:3: -> ipreinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("ipreinc",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID90.symbol).IsGlobal}, {"index", ((VariableSymbol)ID90.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:665:3: ^( PRE_INCREMENT ID ) {...}?
				{
				DebugLocation(665, 3);
				DebugLocation(665, 5);
				Match(input,PRE_INCREMENT,Follow._PRE_INCREMENT_in_preIncrement4414); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(665, 19);
				ID91=(LSLAst)Match(input,ID,Follow._ID_in_preIncrement4416); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(665, 23);
				if (!((ID91.evalType == SymbolTable.FLOAT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "preIncrement", "$ID.evalType == SymbolTable.FLOAT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 666:3: -> fpreinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpreinc",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID91.symbol).IsGlobal}, {"index", ((VariableSymbol)ID91.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:671:3: ^( PRE_INCREMENT ^( SUBSCRIPT var= ID sub= ID ) )
				{
				DebugLocation(671, 3);
				DebugLocation(671, 5);
				Match(input,PRE_INCREMENT,Follow._PRE_INCREMENT_in_preIncrement4453); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(671, 19);
				DebugLocation(671, 21);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_preIncrement4456); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(671, 34);
				var=(LSLAst)Match(input,ID,Follow._ID_in_preIncrement4460); if (state.failed) return retval;
				DebugLocation(671, 41);
				sub=(LSLAst)Match(input,ID,Follow._ID_in_preIncrement4464); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 672:3: -> fpreincsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text))
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpreincsub",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("preIncrement", 53);
			LeaveRule("preIncrement", 53);
			LeaveRule_preIncrement();
		}
		DebugLocation(678, 1);
		} finally { DebugExitRule(GrammarFileName, "preIncrement"); }
		return retval;

	}
	// $ANTLR end "preIncrement"

	private sealed partial class postfixExpression_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public postfixExpression_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();

	// $ANTLR start "postfixExpression"
	// Gen.g:680:1: postfixExpression : ( postIncrement -> {$postIncrement.st}| postDecrement -> {$postDecrement.st}| subscript -> {$subscript.st}| methodCall[false, false] -> {$methodCall.st}| primary -> {$primary.st});
	[GrammarRule("postfixExpression")]
	private Gen.postfixExpression_return postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 54);
		TraceIn("postfixExpression", 54);
		Gen.postfixExpression_return retval = new Gen.postfixExpression_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.postIncrement_return postIncrement92 = default(Gen.postIncrement_return);
		Gen.postDecrement_return postDecrement93 = default(Gen.postDecrement_return);
		Gen.subscript_return subscript94 = default(Gen.subscript_return);
		Gen.methodCall_return methodCall95 = default(Gen.methodCall_return);
		Gen.primary_return primary96 = default(Gen.primary_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(680, 1);
		try
		{
			// Gen.g:683:2: ( postIncrement -> {$postIncrement.st}| postDecrement -> {$postDecrement.st}| subscript -> {$subscript.st}| methodCall[false, false] -> {$methodCall.st}| primary -> {$primary.st})
			int alt62=5;
			try { DebugEnterDecision(62, false);
			switch (input.LA(1))
			{
			case POST_INCREMENT:
				{
				alt62 = 1;
				}
				break;
			case POST_DECREMENT:
				{
				alt62 = 2;
				}
				break;
			case SUBSCRIPT:
				{
				alt62 = 3;
				}
				break;
			case METHOD_CALL:
				{
				alt62 = 4;
				}
				break;
			case EXPR:
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LIST_LITERAL:
			case ROTATION_LITERAL:
			case STRING_LITERAL:
			case VECTOR_LITERAL:
				{
				alt62 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 62, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:683:4: postIncrement
				{
				DebugLocation(683, 4);
				PushFollow(Follow._postIncrement_in_postfixExpression4524);
				postIncrement92=postIncrement();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 683:18: -> {$postIncrement.st}
					{
						retval.Template = (postIncrement92!=null?postIncrement92.Template:null);
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:684:4: postDecrement
				{
				DebugLocation(684, 4);
				PushFollow(Follow._postDecrement_in_postfixExpression4533);
				postDecrement93=postDecrement();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 684:18: -> {$postDecrement.st}
					{
						retval.Template = (postDecrement93!=null?postDecrement93.Template:null);
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:685:4: subscript
				{
				DebugLocation(685, 4);
				PushFollow(Follow._subscript_in_postfixExpression4542);
				subscript94=subscript();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 685:14: -> {$subscript.st}
					{
						retval.Template = (subscript94!=null?subscript94.Template:null);
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:686:4: methodCall[false, false]
				{
				DebugLocation(686, 4);
				PushFollow(Follow._methodCall_in_postfixExpression4551);
				methodCall95=methodCall(false, false);
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 686:29: -> {$methodCall.st}
					{
						retval.Template = (methodCall95!=null?methodCall95.Template:null);
					}

				}
				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Gen.g:687:4: primary
				{
				DebugLocation(687, 4);
				PushFollow(Follow._primary_in_postfixExpression4561);
				primary96=primary();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 687:12: -> {$primary.st}
					{
						retval.Template = (primary96!=null?primary96.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("postfixExpression", 54);
			LeaveRule("postfixExpression", 54);
			LeaveRule_postfixExpression();
		}
		DebugLocation(688, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	private sealed partial class methodCall_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public methodCall_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_methodCall();
	partial void LeaveRule_methodCall();

	// $ANTLR start "methodCall"
	// Gen.g:690:1: methodCall[bool allowVoid, bool popResult] : ^( METHOD_CALL name= ID ( ^( ELIST (e+= expr )+ ) | ELIST ) ) {...}? -> methcall(name=$name.symbol.Nameexprs=$eisSyscall=((MethodSymbol)$ID.symbol).IsSyscallpopresult=$name.symbol.Type != SymbolTable.VOID && popResult);
	[GrammarRule("methodCall")]
	private Gen.methodCall_return methodCall(bool allowVoid, bool popResult)
	{
		EnterRule_methodCall();
		EnterRule("methodCall", 55);
		TraceIn("methodCall", 55);
		Gen.methodCall_return retval = new Gen.methodCall_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst name = default(LSLAst);
		List<StringTemplate> list_e = null;
		Gen.expr_return e = default(Gen.expr_return);
		try { DebugEnterRule(GrammarFileName, "methodCall");
		DebugLocation(690, 1);
		try
		{
			// Gen.g:691:2: ( ^( METHOD_CALL name= ID ( ^( ELIST (e+= expr )+ ) | ELIST ) ) {...}? -> methcall(name=$name.symbol.Nameexprs=$eisSyscall=((MethodSymbol)$ID.symbol).IsSyscallpopresult=$name.symbol.Type != SymbolTable.VOID && popResult))
			DebugEnterAlt(1);
			// Gen.g:691:4: ^( METHOD_CALL name= ID ( ^( ELIST (e+= expr )+ ) | ELIST ) ) {...}?
			{
			DebugLocation(691, 4);
			DebugLocation(691, 6);
			Match(input,METHOD_CALL,Follow._METHOD_CALL_in_methodCall4579); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(691, 22);
			name=(LSLAst)Match(input,ID,Follow._ID_in_methodCall4583); if (state.failed) return retval;
			DebugLocation(691, 26);
			// Gen.g:691:26: ( ^( ELIST (e+= expr )+ ) | ELIST )
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_0 = input.LA(1);

			if ((LA64_0==ELIST))
			{
				int LA64_1 = input.LA(2);

				if ((LA64_1==DOWN))
				{
					alt64 = 1;
				}
				else if ((LA64_1==UP))
				{
					alt64 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 64, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 64, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:691:27: ^( ELIST (e+= expr )+ )
				{
				DebugLocation(691, 27);
				DebugLocation(691, 29);
				Match(input,ELIST,Follow._ELIST_in_methodCall4587); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(691, 36);
				// Gen.g:691:36: (e+= expr )+
				int cnt63=0;
				try { DebugEnterSubRule(63);
				while (true)
				{
					int alt63=2;
					try { DebugEnterDecision(63, false);
					int LA63_0 = input.LA(1);

					if ((LA63_0==ASSIGN_EQ||(LA63_0>=EXPR && LA63_0<=FLOAT_LITERAL)||(LA63_0>=GT && LA63_0<=ID)||LA63_0==INTEGER_LITERAL||LA63_0==LIST_LITERAL||(LA63_0>=LT && LA63_0<=METHOD_CALL)||LA63_0==MINUS||(LA63_0>=POST_DECREMENT && LA63_0<=PRE_INCREMENT)||LA63_0==ROTATION_LITERAL||(LA63_0>=STRING_LITERAL && LA63_0<=SUBSCRIPT)||(LA63_0>=TYPE_CAST && LA63_0<=UNARY_MINUS)||LA63_0==VECTOR_LITERAL||(LA63_0>=56 && LA63_0<=63)||LA63_0==65||LA63_0==67||(LA63_0>=69 && LA63_0<=77)||LA63_0==81||(LA63_0>=92 && LA63_0<=93)))
					{
						alt63 = 1;
					}


					} finally { DebugExitDecision(63); }
					switch (alt63)
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:691:36: e+= expr
						{
						DebugLocation(691, 36);
						PushFollow(Follow._expr_in_methodCall4591);
						e=expr();
						PopFollow();
						if (state.failed) return retval;
						if (list_e==null) list_e=new List<StringTemplate>();
						list_e.Add(e.Template);


						}
						break;

					default:
						if (cnt63 >= 1)
							goto loop63;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee63 = new EarlyExitException( 63, input );
						DebugRecognitionException(eee63);
						throw eee63;
					}
					cnt63++;
				}
				loop63:
					;

				} finally { DebugExitSubRule(63); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:691:47: ELIST
				{
				DebugLocation(691, 47);
				Match(input,ELIST,Follow._ELIST_in_methodCall4597); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(64); }


			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			DebugLocation(691, 55);
			if (!((name.symbol.Type != SymbolTable.VOID || allowVoid)))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "methodCall", "$name.symbol.Type != SymbolTable.VOID || allowVoid");
			}


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 692:3: -> methcall(name=$name.symbol.Nameexprs=$eisSyscall=((MethodSymbol)$ID.symbol).IsSyscallpopresult=$name.symbol.Type != SymbolTable.VOID && popResult)
				{
					retval.Template = TemplateGroup.GetInstanceOf("methcall",
					new Dictionary<string, object>() { {"name", name.symbol.Name}, {"exprs", list_e}, {"isSyscall", ((MethodSymbol)name.symbol).IsSyscall}, {"popresult", name.symbol.Type != SymbolTable.VOID && popResult} });
				}

			}
			}

		}
		catch (FailedPredicateException fpe)
		{

					string hdr = GetErrorHeader(fpe);
					string msg = "A function call with no return type can not be used as part of an expression";
					EmitErrorMessage(hdr + " " + msg);
					throw;
				
		}
		finally
		{
			TraceOut("methodCall", 55);
			LeaveRule("methodCall", 55);
			LeaveRule_methodCall();
		}
		DebugLocation(698, 1);
		} finally { DebugExitRule(GrammarFileName, "methodCall"); }
		return retval;

	}
	// $ANTLR end "methodCall"

	private sealed partial class subscript_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public subscript_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_subscript();
	partial void LeaveRule_subscript();

	// $ANTLR start "subscript"
	// Gen.g:706:1: subscript : ^( SUBSCRIPT var= ID sub= ID ) -> loadsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubidx=CalcSubIndex($sub.text));
	[GrammarRule("subscript")]
	private Gen.subscript_return subscript()
	{
		EnterRule_subscript();
		EnterRule("subscript", 56);
		TraceIn("subscript", 56);
		Gen.subscript_return retval = new Gen.subscript_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "subscript");
		DebugLocation(706, 1);
		try
		{
			// Gen.g:707:2: ( ^( SUBSCRIPT var= ID sub= ID ) -> loadsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubidx=CalcSubIndex($sub.text)))
			DebugEnterAlt(1);
			// Gen.g:707:4: ^( SUBSCRIPT var= ID sub= ID )
			{
			DebugLocation(707, 4);
			DebugLocation(707, 6);
			Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_subscript4663); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(707, 19);
			var=(LSLAst)Match(input,ID,Follow._ID_in_subscript4667); if (state.failed) return retval;
			DebugLocation(707, 26);
			sub=(LSLAst)Match(input,ID,Follow._ID_in_subscript4671); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 708:3: -> loadsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubidx=CalcSubIndex($sub.text))
				{
					retval.Template = TemplateGroup.GetInstanceOf("loadsub",
					new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subidx", CalcSubIndex((sub!=null?sub.Text:null))} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("subscript", 56);
			LeaveRule("subscript", 56);
			LeaveRule_subscript();
		}
		DebugLocation(713, 1);
		} finally { DebugExitRule(GrammarFileName, "subscript"); }
		return retval;

	}
	// $ANTLR end "subscript"

	private sealed partial class postIncrement_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public postIncrement_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_postIncrement();
	partial void LeaveRule_postIncrement();

	// $ANTLR start "postIncrement"
	// Gen.g:715:1: postIncrement : ( ^( POST_INCREMENT ID ) {...}? -> ipostinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_INCREMENT ID ) {...}? -> fpostinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_INCREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpostincsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)));
	[GrammarRule("postIncrement")]
	private Gen.postIncrement_return postIncrement()
	{
		EnterRule_postIncrement();
		EnterRule("postIncrement", 57);
		TraceIn("postIncrement", 57);
		Gen.postIncrement_return retval = new Gen.postIncrement_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		LSLAst ID97 = default(LSLAst);
		LSLAst ID98 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "postIncrement");
		DebugLocation(715, 1);
		try
		{
			// Gen.g:716:2: ( ^( POST_INCREMENT ID ) {...}? -> ipostinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_INCREMENT ID ) {...}? -> fpostinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_INCREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpostincsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)))
			int alt65=3;
			try { DebugEnterDecision(65, false);
			int LA65_0 = input.LA(1);

			if ((LA65_0==POST_INCREMENT))
			{
				int LA65_1 = input.LA(2);

				if ((LA65_1==DOWN))
				{
					int LA65_2 = input.LA(3);

					if ((LA65_2==ID))
					{
						int LA65_3 = input.LA(4);

						if ((LA65_3==UP))
						{
							int LA65_5 = input.LA(5);

							if ((EvaluatePredicate(synpred118_Gen_fragment)))
							{
								alt65 = 1;
							}
							else if ((EvaluatePredicate(synpred119_Gen_fragment)))
							{
								alt65 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 65, 5, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 65, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA65_2==SUBSCRIPT))
					{
						alt65 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 65, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 65, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 65, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:716:4: ^( POST_INCREMENT ID ) {...}?
				{
				DebugLocation(716, 4);
				DebugLocation(716, 6);
				Match(input,POST_INCREMENT,Follow._POST_INCREMENT_in_postIncrement4718); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(716, 21);
				ID97=(LSLAst)Match(input,ID,Follow._ID_in_postIncrement4720); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(716, 25);
				if (!((ID97.symbol.Type == SymbolTable.INT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "postIncrement", "$ID.symbol.Type == SymbolTable.INT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 717:3: -> ipostinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("ipostinc",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID97.symbol).IsGlobal}, {"index", ((VariableSymbol)ID97.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:723:3: ^( POST_INCREMENT ID ) {...}?
				{
				DebugLocation(723, 3);
				DebugLocation(723, 5);
				Match(input,POST_INCREMENT,Follow._POST_INCREMENT_in_postIncrement4761); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(723, 20);
				ID98=(LSLAst)Match(input,ID,Follow._ID_in_postIncrement4763); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(723, 24);
				if (!((ID98.symbol.Type == SymbolTable.FLOAT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "postIncrement", "$ID.symbol.Type == SymbolTable.FLOAT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 724:3: -> fpostinc(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpostinc",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID98.symbol).IsGlobal}, {"index", ((VariableSymbol)ID98.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:730:3: ^( POST_INCREMENT ^( SUBSCRIPT var= ID sub= ID ) )
				{
				DebugLocation(730, 3);
				DebugLocation(730, 5);
				Match(input,POST_INCREMENT,Follow._POST_INCREMENT_in_postIncrement4804); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(730, 20);
				DebugLocation(730, 22);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_postIncrement4807); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(730, 35);
				var=(LSLAst)Match(input,ID,Follow._ID_in_postIncrement4811); if (state.failed) return retval;
				DebugLocation(730, 42);
				sub=(LSLAst)Match(input,ID,Follow._ID_in_postIncrement4815); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 731:3: -> fpostincsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text))
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpostincsub",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("postIncrement", 57);
			LeaveRule("postIncrement", 57);
			LeaveRule_postIncrement();
		}
		DebugLocation(736, 1);
		} finally { DebugExitRule(GrammarFileName, "postIncrement"); }
		return retval;

	}
	// $ANTLR end "postIncrement"

	private sealed partial class postDecrement_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public postDecrement_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_postDecrement();
	partial void LeaveRule_postDecrement();

	// $ANTLR start "postDecrement"
	// Gen.g:738:1: postDecrement : ( ^( POST_DECREMENT ID ) {...}? -> ipostdec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_DECREMENT ID ) {...}? -> fpostdec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_DECREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpostdecsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)));
	[GrammarRule("postDecrement")]
	private Gen.postDecrement_return postDecrement()
	{
		EnterRule_postDecrement();
		EnterRule("postDecrement", 58);
		TraceIn("postDecrement", 58);
		Gen.postDecrement_return retval = new Gen.postDecrement_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst var = default(LSLAst);
		LSLAst sub = default(LSLAst);
		LSLAst ID99 = default(LSLAst);
		LSLAst ID100 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "postDecrement");
		DebugLocation(738, 1);
		try
		{
			// Gen.g:739:2: ( ^( POST_DECREMENT ID ) {...}? -> ipostdec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_DECREMENT ID ) {...}? -> fpostdec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( POST_DECREMENT ^( SUBSCRIPT var= ID sub= ID ) ) -> fpostdecsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text)))
			int alt66=3;
			try { DebugEnterDecision(66, false);
			int LA66_0 = input.LA(1);

			if ((LA66_0==POST_DECREMENT))
			{
				int LA66_1 = input.LA(2);

				if ((LA66_1==DOWN))
				{
					int LA66_2 = input.LA(3);

					if ((LA66_2==ID))
					{
						int LA66_3 = input.LA(4);

						if ((LA66_3==UP))
						{
							int LA66_5 = input.LA(5);

							if ((EvaluatePredicate(synpred120_Gen_fragment)))
							{
								alt66 = 1;
							}
							else if ((EvaluatePredicate(synpred121_Gen_fragment)))
							{
								alt66 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 66, 5, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 66, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA66_2==SUBSCRIPT))
					{
						alt66 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 66, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 66, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 66, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:739:4: ^( POST_DECREMENT ID ) {...}?
				{
				DebugLocation(739, 4);
				DebugLocation(739, 6);
				Match(input,POST_DECREMENT,Follow._POST_DECREMENT_in_postDecrement4863); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(739, 21);
				ID99=(LSLAst)Match(input,ID,Follow._ID_in_postDecrement4865); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(739, 25);
				if (!((ID99.symbol.Type == SymbolTable.INT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "postDecrement", "$ID.symbol.Type == SymbolTable.INT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 740:3: -> ipostdec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("ipostdec",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID99.symbol).IsGlobal}, {"index", ((VariableSymbol)ID99.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:746:3: ^( POST_DECREMENT ID ) {...}?
				{
				DebugLocation(746, 3);
				DebugLocation(746, 5);
				Match(input,POST_DECREMENT,Follow._POST_DECREMENT_in_postDecrement4906); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(746, 20);
				ID100=(LSLAst)Match(input,ID,Follow._ID_in_postDecrement4908); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(746, 24);
				if (!((ID100.symbol.Type == SymbolTable.FLOAT)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "postDecrement", "$ID.symbol.Type == SymbolTable.FLOAT");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 747:3: -> fpostdec(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpostdec",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID100.symbol).IsGlobal}, {"index", ((VariableSymbol)ID100.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:753:3: ^( POST_DECREMENT ^( SUBSCRIPT var= ID sub= ID ) )
				{
				DebugLocation(753, 3);
				DebugLocation(753, 5);
				Match(input,POST_DECREMENT,Follow._POST_DECREMENT_in_postDecrement4949); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(753, 20);
				DebugLocation(753, 22);
				Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_postDecrement4952); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(753, 35);
				var=(LSLAst)Match(input,ID,Follow._ID_in_postDecrement4956); if (state.failed) return retval;
				DebugLocation(753, 42);
				sub=(LSLAst)Match(input,ID,Follow._ID_in_postDecrement4960); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 754:3: -> fpostdecsub(isglobal=((VariableSymbol)$var.symbol).IsGlobalindex=((VariableSymbol)$var.symbol).ScopeIndexsubindex=CalcSubIndex($sub.text))
					{
						retval.Template = TemplateGroup.GetInstanceOf("fpostdecsub",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)var.symbol).IsGlobal}, {"index", ((VariableSymbol)var.symbol).ScopeIndex}, {"subindex", CalcSubIndex((sub!=null?sub.Text:null))} });
					}

				}
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("postDecrement", 58);
			LeaveRule("postDecrement", 58);
			LeaveRule_postDecrement();
		}
		DebugLocation(759, 1);
		} finally { DebugExitRule(GrammarFileName, "postDecrement"); }
		return retval;

	}
	// $ANTLR end "postDecrement"

	private sealed partial class primary_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public primary_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_primary();
	partial void LeaveRule_primary();

	// $ANTLR start "primary"
	// Gen.g:761:1: primary : ( STRING_LITERAL -> sconst(constText=$STRING_LITERAL.text)| INTEGER_LITERAL -> iconst(constText=$INTEGER_LITERAL.text)| FLOAT_LITERAL -> fconst(constText=this.FormatFloat($FLOAT_LITERAL.text))| ID {...}? -> sysconstload(template=((ConstantSymbol)$ID.symbol).TemplateNamevalue=((ConstantSymbol)$ID.symbol).ConstValue)| ID {...}? -> idload(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ( vecConst )=> vecConst -> {$vecConst.st}| vecLiteral -> {$vecLiteral.st}| ( rotConst )=> rotConst -> {$rotConst.st}| rotLiteral -> {$rotLiteral.st}| listLiteral -> {$listLiteral.st}| expression -> {$expression.st});
	[GrammarRule("primary")]
	private Gen.primary_return primary()
	{
		EnterRule_primary();
		EnterRule("primary", 59);
		TraceIn("primary", 59);
		Gen.primary_return retval = new Gen.primary_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst STRING_LITERAL101 = default(LSLAst);
		LSLAst INTEGER_LITERAL102 = default(LSLAst);
		LSLAst FLOAT_LITERAL103 = default(LSLAst);
		LSLAst ID104 = default(LSLAst);
		LSLAst ID105 = default(LSLAst);
		Gen.vecConst_return vecConst106 = default(Gen.vecConst_return);
		Gen.vecLiteral_return vecLiteral107 = default(Gen.vecLiteral_return);
		Gen.rotConst_return rotConst108 = default(Gen.rotConst_return);
		Gen.rotLiteral_return rotLiteral109 = default(Gen.rotLiteral_return);
		Gen.listLiteral_return listLiteral110 = default(Gen.listLiteral_return);
		Gen.expression_return expression111 = default(Gen.expression_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "primary");
		DebugLocation(761, 1);
		try
		{
			// Gen.g:764:2: ( STRING_LITERAL -> sconst(constText=$STRING_LITERAL.text)| INTEGER_LITERAL -> iconst(constText=$INTEGER_LITERAL.text)| FLOAT_LITERAL -> fconst(constText=this.FormatFloat($FLOAT_LITERAL.text))| ID {...}? -> sysconstload(template=((ConstantSymbol)$ID.symbol).TemplateNamevalue=((ConstantSymbol)$ID.symbol).ConstValue)| ID {...}? -> idload(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ( vecConst )=> vecConst -> {$vecConst.st}| vecLiteral -> {$vecLiteral.st}| ( rotConst )=> rotConst -> {$rotConst.st}| rotLiteral -> {$rotLiteral.st}| listLiteral -> {$listLiteral.st}| expression -> {$expression.st})
			int alt67=11;
			try { DebugEnterDecision(67, false);
			try
			{
				alt67 = dfa67.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:764:4: STRING_LITERAL
				{
				DebugLocation(764, 4);
				STRING_LITERAL101=(LSLAst)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_primary5019); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 764:19: -> sconst(constText=$STRING_LITERAL.text)
					{
						retval.Template = TemplateGroup.GetInstanceOf("sconst",
						new Dictionary<string, object>() { {"constText", (STRING_LITERAL101!=null?STRING_LITERAL101.Text:null)} });
					}

				}
				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:765:4: INTEGER_LITERAL
				{
				DebugLocation(765, 4);
				INTEGER_LITERAL102=(LSLAst)Match(input,INTEGER_LITERAL,Follow._INTEGER_LITERAL_in_primary5033); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 765:20: -> iconst(constText=$INTEGER_LITERAL.text)
					{
						retval.Template = TemplateGroup.GetInstanceOf("iconst",
						new Dictionary<string, object>() { {"constText", (INTEGER_LITERAL102!=null?INTEGER_LITERAL102.Text:null)} });
					}

				}
				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Gen.g:766:4: FLOAT_LITERAL
				{
				DebugLocation(766, 4);
				FLOAT_LITERAL103=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_primary5047); if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 766:18: -> fconst(constText=this.FormatFloat($FLOAT_LITERAL.text))
					{
						retval.Template = TemplateGroup.GetInstanceOf("fconst",
						new Dictionary<string, object>() { {"constText", this.FormatFloat((FLOAT_LITERAL103!=null?FLOAT_LITERAL103.Text:null))} });
					}

				}
				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Gen.g:768:5: ID {...}?
				{
				DebugLocation(768, 5);
				ID104=(LSLAst)Match(input,ID,Follow._ID_in_primary5064); if (state.failed) return retval;
				DebugLocation(768, 8);
				if (!((ID104.symbol is ConstantSymbol)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary", "$ID.symbol is ConstantSymbol");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 768:40: -> sysconstload(template=((ConstantSymbol)$ID.symbol).TemplateNamevalue=((ConstantSymbol)$ID.symbol).ConstValue)
					{
						retval.Template = TemplateGroup.GetInstanceOf("sysconstload",
						new Dictionary<string, object>() { {"template", ((ConstantSymbol)ID104.symbol).TemplateName}, {"value", ((ConstantSymbol)ID104.symbol).ConstValue} });
					}

				}
				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Gen.g:774:4: ID {...}?
				{
				DebugLocation(774, 4);
				ID105=(LSLAst)Match(input,ID,Follow._ID_in_primary5101); if (state.failed) return retval;
				DebugLocation(774, 7);
				if (!((!(ID105.symbol is ConstantSymbol))))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary", "!($ID.symbol is ConstantSymbol)");
				}


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 774:42: -> idload(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)
					{
						retval.Template = TemplateGroup.GetInstanceOf("idload",
						new Dictionary<string, object>() { {"isglobal", ((VariableSymbol)ID105.symbol).IsGlobal}, {"index", ((VariableSymbol)ID105.symbol).ScopeIndex} });
					}

				}
				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Gen.g:779:4: ( vecConst )=> vecConst
				{
				DebugLocation(779, 18);
				PushFollow(Follow._vecConst_in_primary5140);
				vecConst106=vecConst();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 779:27: -> {$vecConst.st}
					{
						retval.Template = (vecConst106!=null?vecConst106.Template:null);
					}

				}
				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Gen.g:780:4: vecLiteral
				{
				DebugLocation(780, 4);
				PushFollow(Follow._vecLiteral_in_primary5149);
				vecLiteral107=vecLiteral();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 780:15: -> {$vecLiteral.st}
					{
						retval.Template = (vecLiteral107!=null?vecLiteral107.Template:null);
					}

				}
				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Gen.g:781:4: ( rotConst )=> rotConst
				{
				DebugLocation(781, 18);
				PushFollow(Follow._rotConst_in_primary5164);
				rotConst108=rotConst();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 781:27: -> {$rotConst.st}
					{
						retval.Template = (rotConst108!=null?rotConst108.Template:null);
					}

				}
				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Gen.g:782:4: rotLiteral
				{
				DebugLocation(782, 4);
				PushFollow(Follow._rotLiteral_in_primary5173);
				rotLiteral109=rotLiteral();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 782:15: -> {$rotLiteral.st}
					{
						retval.Template = (rotLiteral109!=null?rotLiteral109.Template:null);
					}

				}
				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Gen.g:783:4: listLiteral
				{
				DebugLocation(783, 4);
				PushFollow(Follow._listLiteral_in_primary5182);
				listLiteral110=listLiteral();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 783:16: -> {$listLiteral.st}
					{
						retval.Template = (listLiteral110!=null?listLiteral110.Template:null);
					}

				}
				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Gen.g:784:4: expression
				{
				DebugLocation(784, 4);
				PushFollow(Follow._expression_in_primary5191);
				expression111=expression();
				PopFollow();
				if (state.failed) return retval;


				// TEMPLATE REWRITE
				if (state.backtracking == 0)
				{
					// 784:15: -> {$expression.st}
					{
						retval.Template = (expression111!=null?expression111.Template:null);
					}

				}
				}
				break;

			}
			if (state.backtracking == 0)
			{
				 retval.Template = DoPromotion(t, retval.Template); 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("primary", 59);
			LeaveRule("primary", 59);
			LeaveRule_primary();
		}
		DebugLocation(785, 1);
		} finally { DebugExitRule(GrammarFileName, "primary"); }
		return retval;

	}
	// $ANTLR end "primary"

	private sealed partial class vecConst_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public vecConst_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_vecConst();
	partial void LeaveRule_vecConst();

	// $ANTLR start "vecConst"
	// Gen.g:787:1: vecConst : ^( VECTOR_LITERAL x= FLOAT_LITERAL y= FLOAT_LITERAL z= FLOAT_LITERAL ) -> vconst(x=FormatFloat($x.text)y=FormatFloat($y.text)z=FormatFloat($z.text));
	[GrammarRule("vecConst")]
	private Gen.vecConst_return vecConst()
	{
		EnterRule_vecConst();
		EnterRule("vecConst", 60);
		TraceIn("vecConst", 60);
		Gen.vecConst_return retval = new Gen.vecConst_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst x = default(LSLAst);
		LSLAst y = default(LSLAst);
		LSLAst z = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "vecConst");
		DebugLocation(787, 1);
		try
		{
			// Gen.g:788:2: ( ^( VECTOR_LITERAL x= FLOAT_LITERAL y= FLOAT_LITERAL z= FLOAT_LITERAL ) -> vconst(x=FormatFloat($x.text)y=FormatFloat($y.text)z=FormatFloat($z.text)))
			DebugEnterAlt(1);
			// Gen.g:788:4: ^( VECTOR_LITERAL x= FLOAT_LITERAL y= FLOAT_LITERAL z= FLOAT_LITERAL )
			{
			DebugLocation(788, 4);
			DebugLocation(788, 6);
			Match(input,VECTOR_LITERAL,Follow._VECTOR_LITERAL_in_vecConst5207); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(788, 22);
			x=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_vecConst5211); if (state.failed) return retval;
			DebugLocation(788, 38);
			y=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_vecConst5215); if (state.failed) return retval;
			DebugLocation(788, 54);
			z=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_vecConst5219); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 788:70: -> vconst(x=FormatFloat($x.text)y=FormatFloat($y.text)z=FormatFloat($z.text))
				{
					retval.Template = TemplateGroup.GetInstanceOf("vconst",
					new Dictionary<string, object>() { {"x", FormatFloat((x!=null?x.Text:null))}, {"y", FormatFloat((y!=null?y.Text:null))}, {"z", FormatFloat((z!=null?z.Text:null))} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("vecConst", 60);
			LeaveRule("vecConst", 60);
			LeaveRule_vecConst();
		}
		DebugLocation(790, 1);
		} finally { DebugExitRule(GrammarFileName, "vecConst"); }
		return retval;

	}
	// $ANTLR end "vecConst"

	private sealed partial class vecLiteral_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public vecLiteral_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_vecLiteral();
	partial void LeaveRule_vecLiteral();

	// $ANTLR start "vecLiteral"
	// Gen.g:792:1: vecLiteral : ^( VECTOR_LITERAL x= expr y= expr z= expr ) -> buildvec(x=$x.sty=$y.stz=$z.st);
	[GrammarRule("vecLiteral")]
	private Gen.vecLiteral_return vecLiteral()
	{
		EnterRule_vecLiteral();
		EnterRule("vecLiteral", 61);
		TraceIn("vecLiteral", 61);
		Gen.vecLiteral_return retval = new Gen.vecLiteral_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.expr_return x = default(Gen.expr_return);
		Gen.expr_return y = default(Gen.expr_return);
		Gen.expr_return z = default(Gen.expr_return);

		try { DebugEnterRule(GrammarFileName, "vecLiteral");
		DebugLocation(792, 1);
		try
		{
			// Gen.g:793:2: ( ^( VECTOR_LITERAL x= expr y= expr z= expr ) -> buildvec(x=$x.sty=$y.stz=$z.st))
			DebugEnterAlt(1);
			// Gen.g:793:4: ^( VECTOR_LITERAL x= expr y= expr z= expr )
			{
			DebugLocation(793, 4);
			DebugLocation(793, 6);
			Match(input,VECTOR_LITERAL,Follow._VECTOR_LITERAL_in_vecLiteral5253); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(793, 22);
			PushFollow(Follow._expr_in_vecLiteral5257);
			x=expr();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(793, 29);
			PushFollow(Follow._expr_in_vecLiteral5261);
			y=expr();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(793, 36);
			PushFollow(Follow._expr_in_vecLiteral5265);
			z=expr();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 793:43: -> buildvec(x=$x.sty=$y.stz=$z.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("buildvec",
					new Dictionary<string, object>() { {"x", (x!=null?x.Template:null)}, {"y", (y!=null?y.Template:null)}, {"z", (z!=null?z.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("vecLiteral", 61);
			LeaveRule("vecLiteral", 61);
			LeaveRule_vecLiteral();
		}
		DebugLocation(795, 1);
		} finally { DebugExitRule(GrammarFileName, "vecLiteral"); }
		return retval;

	}
	// $ANTLR end "vecLiteral"

	private sealed partial class rotConst_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public rotConst_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_rotConst();
	partial void LeaveRule_rotConst();

	// $ANTLR start "rotConst"
	// Gen.g:797:1: rotConst : ^( ROTATION_LITERAL x= FLOAT_LITERAL y= FLOAT_LITERAL z= FLOAT_LITERAL w= FLOAT_LITERAL ) -> rconst(x=FormatFloat($x.text)y=FormatFloat($y.text)z=FormatFloat($z.text)w=FormatFloat($w.text));
	[GrammarRule("rotConst")]
	private Gen.rotConst_return rotConst()
	{
		EnterRule_rotConst();
		EnterRule("rotConst", 62);
		TraceIn("rotConst", 62);
		Gen.rotConst_return retval = new Gen.rotConst_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst x = default(LSLAst);
		LSLAst y = default(LSLAst);
		LSLAst z = default(LSLAst);
		LSLAst w = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "rotConst");
		DebugLocation(797, 1);
		try
		{
			// Gen.g:798:2: ( ^( ROTATION_LITERAL x= FLOAT_LITERAL y= FLOAT_LITERAL z= FLOAT_LITERAL w= FLOAT_LITERAL ) -> rconst(x=FormatFloat($x.text)y=FormatFloat($y.text)z=FormatFloat($z.text)w=FormatFloat($w.text)))
			DebugEnterAlt(1);
			// Gen.g:798:4: ^( ROTATION_LITERAL x= FLOAT_LITERAL y= FLOAT_LITERAL z= FLOAT_LITERAL w= FLOAT_LITERAL )
			{
			DebugLocation(798, 4);
			DebugLocation(798, 6);
			Match(input,ROTATION_LITERAL,Follow._ROTATION_LITERAL_in_rotConst5299); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(798, 24);
			x=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_rotConst5303); if (state.failed) return retval;
			DebugLocation(798, 40);
			y=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_rotConst5307); if (state.failed) return retval;
			DebugLocation(798, 56);
			z=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_rotConst5311); if (state.failed) return retval;
			DebugLocation(798, 72);
			w=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_rotConst5315); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 798:88: -> rconst(x=FormatFloat($x.text)y=FormatFloat($y.text)z=FormatFloat($z.text)w=FormatFloat($w.text))
				{
					retval.Template = TemplateGroup.GetInstanceOf("rconst",
					new Dictionary<string, object>() { {"x", FormatFloat((x!=null?x.Text:null))}, {"y", FormatFloat((y!=null?y.Text:null))}, {"z", FormatFloat((z!=null?z.Text:null))}, {"w", FormatFloat((w!=null?w.Text:null))} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rotConst", 62);
			LeaveRule("rotConst", 62);
			LeaveRule_rotConst();
		}
		DebugLocation(800, 1);
		} finally { DebugExitRule(GrammarFileName, "rotConst"); }
		return retval;

	}
	// $ANTLR end "rotConst"

	private sealed partial class rotLiteral_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public rotLiteral_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_rotLiteral();
	partial void LeaveRule_rotLiteral();

	// $ANTLR start "rotLiteral"
	// Gen.g:802:1: rotLiteral : ^( ROTATION_LITERAL x= expr y= expr z= expr w= expr ) -> buildrot(x=$x.sty=$y.stz=$z.stw=$w.st);
	[GrammarRule("rotLiteral")]
	private Gen.rotLiteral_return rotLiteral()
	{
		EnterRule_rotLiteral();
		EnterRule("rotLiteral", 63);
		TraceIn("rotLiteral", 63);
		Gen.rotLiteral_return retval = new Gen.rotLiteral_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Gen.expr_return x = default(Gen.expr_return);
		Gen.expr_return y = default(Gen.expr_return);
		Gen.expr_return z = default(Gen.expr_return);
		Gen.expr_return w = default(Gen.expr_return);

		try { DebugEnterRule(GrammarFileName, "rotLiteral");
		DebugLocation(802, 1);
		try
		{
			// Gen.g:803:2: ( ^( ROTATION_LITERAL x= expr y= expr z= expr w= expr ) -> buildrot(x=$x.sty=$y.stz=$z.stw=$w.st))
			DebugEnterAlt(1);
			// Gen.g:803:4: ^( ROTATION_LITERAL x= expr y= expr z= expr w= expr )
			{
			DebugLocation(803, 4);
			DebugLocation(803, 6);
			Match(input,ROTATION_LITERAL,Follow._ROTATION_LITERAL_in_rotLiteral5356); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(803, 24);
			PushFollow(Follow._expr_in_rotLiteral5360);
			x=expr();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(803, 31);
			PushFollow(Follow._expr_in_rotLiteral5364);
			y=expr();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(803, 38);
			PushFollow(Follow._expr_in_rotLiteral5368);
			z=expr();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(803, 45);
			PushFollow(Follow._expr_in_rotLiteral5372);
			w=expr();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 803:52: -> buildrot(x=$x.sty=$y.stz=$z.stw=$w.st)
				{
					retval.Template = TemplateGroup.GetInstanceOf("buildrot",
					new Dictionary<string, object>() { {"x", (x!=null?x.Template:null)}, {"y", (y!=null?y.Template:null)}, {"z", (z!=null?z.Template:null)}, {"w", (w!=null?w.Template:null)} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rotLiteral", 63);
			LeaveRule("rotLiteral", 63);
			LeaveRule_rotLiteral();
		}
		DebugLocation(805, 1);
		} finally { DebugExitRule(GrammarFileName, "rotLiteral"); }
		return retval;

	}
	// $ANTLR end "rotLiteral"

	private sealed partial class listLiteral_return : TreeRuleReturnScope<LSLAst>
	{
		private StringTemplate _st;
		public StringTemplate Template { get { return _st; } set { _st = value; } }
		public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
		public listLiteral_return(Gen grammar) {OnCreated(grammar);}
		partial void OnCreated(Gen grammar);
	}

	partial void EnterRule_listLiteral();
	partial void LeaveRule_listLiteral();

	// $ANTLR start "listLiteral"
	// Gen.g:807:1: listLiteral : ^( LIST_LITERAL ( ^( ELIST (e+= expr )+ ) | ELIST ) ) -> buildlist(exprs=$e);
	[GrammarRule("listLiteral")]
	private Gen.listLiteral_return listLiteral()
	{
		EnterRule_listLiteral();
		EnterRule("listLiteral", 64);
		TraceIn("listLiteral", 64);
		Gen.listLiteral_return retval = new Gen.listLiteral_return(this);
		retval.Start = (LSLAst)input.LT(1);

		List<StringTemplate> list_e = null;
		Gen.expr_return e = default(Gen.expr_return);
		try { DebugEnterRule(GrammarFileName, "listLiteral");
		DebugLocation(807, 1);
		try
		{
			// Gen.g:808:2: ( ^( LIST_LITERAL ( ^( ELIST (e+= expr )+ ) | ELIST ) ) -> buildlist(exprs=$e))
			DebugEnterAlt(1);
			// Gen.g:808:4: ^( LIST_LITERAL ( ^( ELIST (e+= expr )+ ) | ELIST ) )
			{
			DebugLocation(808, 4);
			DebugLocation(808, 6);
			Match(input,LIST_LITERAL,Follow._LIST_LITERAL_in_listLiteral5412); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(808, 19);
			// Gen.g:808:19: ( ^( ELIST (e+= expr )+ ) | ELIST )
			int alt69=2;
			try { DebugEnterSubRule(69);
			try { DebugEnterDecision(69, false);
			int LA69_0 = input.LA(1);

			if ((LA69_0==ELIST))
			{
				int LA69_1 = input.LA(2);

				if ((LA69_1==DOWN))
				{
					alt69 = 1;
				}
				else if ((LA69_1==UP))
				{
					alt69 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 69, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 69, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// Gen.g:808:20: ^( ELIST (e+= expr )+ )
				{
				DebugLocation(808, 20);
				DebugLocation(808, 22);
				Match(input,ELIST,Follow._ELIST_in_listLiteral5416); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(808, 29);
				// Gen.g:808:29: (e+= expr )+
				int cnt68=0;
				try { DebugEnterSubRule(68);
				while (true)
				{
					int alt68=2;
					try { DebugEnterDecision(68, false);
					int LA68_0 = input.LA(1);

					if ((LA68_0==ASSIGN_EQ||(LA68_0>=EXPR && LA68_0<=FLOAT_LITERAL)||(LA68_0>=GT && LA68_0<=ID)||LA68_0==INTEGER_LITERAL||LA68_0==LIST_LITERAL||(LA68_0>=LT && LA68_0<=METHOD_CALL)||LA68_0==MINUS||(LA68_0>=POST_DECREMENT && LA68_0<=PRE_INCREMENT)||LA68_0==ROTATION_LITERAL||(LA68_0>=STRING_LITERAL && LA68_0<=SUBSCRIPT)||(LA68_0>=TYPE_CAST && LA68_0<=UNARY_MINUS)||LA68_0==VECTOR_LITERAL||(LA68_0>=56 && LA68_0<=63)||LA68_0==65||LA68_0==67||(LA68_0>=69 && LA68_0<=77)||LA68_0==81||(LA68_0>=92 && LA68_0<=93)))
					{
						alt68 = 1;
					}


					} finally { DebugExitDecision(68); }
					switch (alt68)
					{
					case 1:
						DebugEnterAlt(1);
						// Gen.g:808:29: e+= expr
						{
						DebugLocation(808, 29);
						PushFollow(Follow._expr_in_listLiteral5420);
						e=expr();
						PopFollow();
						if (state.failed) return retval;
						if (list_e==null) list_e=new List<StringTemplate>();
						list_e.Add(e.Template);


						}
						break;

					default:
						if (cnt68 >= 1)
							goto loop68;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee68 = new EarlyExitException( 68, input );
						DebugRecognitionException(eee68);
						throw eee68;
					}
					cnt68++;
				}
				loop68:
					;

				} finally { DebugExitSubRule(68); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Gen.g:808:40: ELIST
				{
				DebugLocation(808, 40);
				Match(input,ELIST,Follow._ELIST_in_listLiteral5426); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(69); }


			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			// TEMPLATE REWRITE
			if (state.backtracking == 0)
			{
				// 808:49: -> buildlist(exprs=$e)
				{
					retval.Template = TemplateGroup.GetInstanceOf("buildlist",
					new Dictionary<string, object>() { {"exprs", list_e} });
				}

			}
			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("listLiteral", 64);
			LeaveRule("listLiteral", 64);
			LeaveRule_listLiteral();
		}
		DebugLocation(810, 1);
		} finally { DebugExitRule(GrammarFileName, "listLiteral"); }
		return retval;

	}
	// $ANTLR end "listLiteral"

	partial void EnterRule_synpred22_Gen_fragment();
	partial void LeaveRule_synpred22_Gen_fragment();

	// $ANTLR start synpred22_Gen
	public void synpred22_Gen_fragment()
	{
		EnterRule_synpred22_Gen_fragment();
		EnterRule("synpred22_Gen_fragment", 86);
		TraceIn("synpred22_Gen_fragment", 86);
		try
		{
			// Gen.g:134:4: ( funcBlock )
			DebugEnterAlt(1);
			// Gen.g:134:4: funcBlock
			{
			DebugLocation(134, 4);
			PushFollow(Follow._funcBlock_in_synpred22_Gen531);
			funcBlock();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred22_Gen_fragment", 86);
			LeaveRule("synpred22_Gen_fragment", 86);
			LeaveRule_synpred22_Gen_fragment();
		}
	}
	// $ANTLR end synpred22_Gen

	partial void EnterRule_synpred24_Gen_fragment();
	partial void LeaveRule_synpred24_Gen_fragment();

	// $ANTLR start synpred24_Gen
	public void synpred24_Gen_fragment()
	{
		Gen.expression_return e = default(Gen.expression_return);

		EnterRule_synpred24_Gen_fragment();
		EnterRule("synpred24_Gen_fragment", 88);
		TraceIn("synpred24_Gen_fragment", 88);
		try
		{
			// Gen.g:142:4: ( ^( VAR_DECL TYPE ID e= expression ) )
			DebugEnterAlt(1);
			// Gen.g:142:4: ^( VAR_DECL TYPE ID e= expression )
			{
			DebugLocation(142, 4);
			DebugLocation(142, 6);
			Match(input,VAR_DECL,Follow._VAR_DECL_in_synpred24_Gen565); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(142, 15);
			Match(input,TYPE,Follow._TYPE_in_synpred24_Gen567); if (state.failed) return;
			DebugLocation(142, 20);
			Match(input,ID,Follow._ID_in_synpred24_Gen569); if (state.failed) return;
			DebugLocation(142, 24);
			PushFollow(Follow._expression_in_synpred24_Gen573);
			e=expression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_Gen_fragment", 88);
			LeaveRule("synpred24_Gen_fragment", 88);
			LeaveRule_synpred24_Gen_fragment();
		}
	}
	// $ANTLR end synpred24_Gen

	partial void EnterRule_synpred25_Gen_fragment();
	partial void LeaveRule_synpred25_Gen_fragment();

	// $ANTLR start synpred25_Gen
	public void synpred25_Gen_fragment()
	{
		EnterRule_synpred25_Gen_fragment();
		EnterRule("synpred25_Gen_fragment", 89);
		TraceIn("synpred25_Gen_fragment", 89);
		try
		{
			// Gen.g:148:3: ( ^( VAR_DECL TYPE ID ) )
			DebugEnterAlt(1);
			// Gen.g:148:3: ^( VAR_DECL TYPE ID )
			{
			DebugLocation(148, 3);
			DebugLocation(148, 5);
			Match(input,VAR_DECL,Follow._VAR_DECL_in_synpred25_Gen607); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(148, 14);
			Match(input,TYPE,Follow._TYPE_in_synpred25_Gen609); if (state.failed) return;
			DebugLocation(148, 19);
			Match(input,ID,Follow._ID_in_synpred25_Gen611); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_Gen_fragment", 89);
			LeaveRule("synpred25_Gen_fragment", 89);
			LeaveRule_synpred25_Gen_fragment();
		}
	}
	// $ANTLR end synpred25_Gen

	partial void EnterRule_synpred41_Gen_fragment();
	partial void LeaveRule_synpred41_Gen_fragment();

	// $ANTLR start synpred41_Gen
	public void synpred41_Gen_fragment()
	{
		EnterRule_synpred41_Gen_fragment();
		EnterRule("synpred41_Gen_fragment", 105);
		TraceIn("synpred41_Gen_fragment", 105);
		try
		{
			// Gen.g:209:3: ( ^( EXPR methodCall[true, true] ) )
			DebugEnterAlt(1);
			// Gen.g:209:3: ^( EXPR methodCall[true, true] )
			{
			DebugLocation(209, 3);
			DebugLocation(209, 5);
			Match(input,EXPR,Follow._EXPR_in_synpred41_Gen1093); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(209, 10);
			PushFollow(Follow._methodCall_in_synpred41_Gen1095);
			methodCall(true, true);
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred41_Gen_fragment", 105);
			LeaveRule("synpred41_Gen_fragment", 105);
			LeaveRule_synpred41_Gen_fragment();
		}
	}
	// $ANTLR end synpred41_Gen

	partial void EnterRule_synpred42_Gen_fragment();
	partial void LeaveRule_synpred42_Gen_fragment();

	// $ANTLR start synpred42_Gen
	public void synpred42_Gen_fragment()
	{
		EnterRule_synpred42_Gen_fragment();
		EnterRule("synpred42_Gen_fragment", 106);
		TraceIn("synpred42_Gen_fragment", 106);
		try
		{
			// Gen.g:211:3: ( ^( EXPR preIncrement ) )
			DebugEnterAlt(1);
			// Gen.g:211:3: ^( EXPR preIncrement )
			{
			DebugLocation(211, 3);
			DebugLocation(211, 5);
			Match(input,EXPR,Follow._EXPR_in_synpred42_Gen1109); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(211, 10);
			PushFollow(Follow._preIncrement_in_synpred42_Gen1111);
			preIncrement();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred42_Gen_fragment", 106);
			LeaveRule("synpred42_Gen_fragment", 106);
			LeaveRule_synpred42_Gen_fragment();
		}
	}
	// $ANTLR end synpred42_Gen

	partial void EnterRule_synpred43_Gen_fragment();
	partial void LeaveRule_synpred43_Gen_fragment();

	// $ANTLR start synpred43_Gen
	public void synpred43_Gen_fragment()
	{
		EnterRule_synpred43_Gen_fragment();
		EnterRule("synpred43_Gen_fragment", 107);
		TraceIn("synpred43_Gen_fragment", 107);
		try
		{
			// Gen.g:214:3: ( ^( EXPR postIncrement ) )
			DebugEnterAlt(1);
			// Gen.g:214:3: ^( EXPR postIncrement )
			{
			DebugLocation(214, 3);
			DebugLocation(214, 5);
			Match(input,EXPR,Follow._EXPR_in_synpred43_Gen1132); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(214, 10);
			PushFollow(Follow._postIncrement_in_synpred43_Gen1134);
			postIncrement();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred43_Gen_fragment", 107);
			LeaveRule("synpred43_Gen_fragment", 107);
			LeaveRule_synpred43_Gen_fragment();
		}
	}
	// $ANTLR end synpred43_Gen

	partial void EnterRule_synpred44_Gen_fragment();
	partial void LeaveRule_synpred44_Gen_fragment();

	// $ANTLR start synpred44_Gen
	public void synpred44_Gen_fragment()
	{
		EnterRule_synpred44_Gen_fragment();
		EnterRule("synpred44_Gen_fragment", 108);
		TraceIn("synpred44_Gen_fragment", 108);
		try
		{
			// Gen.g:217:3: ( ^( EXPR preDecrement ) )
			DebugEnterAlt(1);
			// Gen.g:217:3: ^( EXPR preDecrement )
			{
			DebugLocation(217, 3);
			DebugLocation(217, 5);
			Match(input,EXPR,Follow._EXPR_in_synpred44_Gen1155); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(217, 10);
			PushFollow(Follow._preDecrement_in_synpred44_Gen1157);
			preDecrement();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred44_Gen_fragment", 108);
			LeaveRule("synpred44_Gen_fragment", 108);
			LeaveRule_synpred44_Gen_fragment();
		}
	}
	// $ANTLR end synpred44_Gen

	partial void EnterRule_synpred45_Gen_fragment();
	partial void LeaveRule_synpred45_Gen_fragment();

	// $ANTLR start synpred45_Gen
	public void synpred45_Gen_fragment()
	{
		EnterRule_synpred45_Gen_fragment();
		EnterRule("synpred45_Gen_fragment", 109);
		TraceIn("synpred45_Gen_fragment", 109);
		try
		{
			// Gen.g:220:3: ( ^( EXPR postDecrement ) )
			DebugEnterAlt(1);
			// Gen.g:220:3: ^( EXPR postDecrement )
			{
			DebugLocation(220, 3);
			DebugLocation(220, 5);
			Match(input,EXPR,Follow._EXPR_in_synpred45_Gen1178); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(220, 10);
			PushFollow(Follow._postDecrement_in_synpred45_Gen1180);
			postDecrement();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred45_Gen_fragment", 109);
			LeaveRule("synpred45_Gen_fragment", 109);
			LeaveRule_synpred45_Gen_fragment();
		}
	}
	// $ANTLR end synpred45_Gen

	partial void EnterRule_synpred94_Gen_fragment();
	partial void LeaveRule_synpred94_Gen_fragment();

	// $ANTLR start synpred94_Gen
	public void synpred94_Gen_fragment()
	{
		EnterRule_synpred94_Gen_fragment();
		EnterRule("synpred94_Gen_fragment", 158);
		TraceIn("synpred94_Gen_fragment", 158);
		try
		{
			// Gen.g:579:3: ( ^( UNARY_MINUS INTEGER_LITERAL ) )
			DebugEnterAlt(1);
			// Gen.g:579:3: ^( UNARY_MINUS INTEGER_LITERAL )
			{
			DebugLocation(579, 3);
			DebugLocation(579, 5);
			Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_synpred94_Gen3828); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(579, 17);
			Match(input,INTEGER_LITERAL,Follow._INTEGER_LITERAL_in_synpred94_Gen3830); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred94_Gen_fragment", 158);
			LeaveRule("synpred94_Gen_fragment", 158);
			LeaveRule_synpred94_Gen_fragment();
		}
	}
	// $ANTLR end synpred94_Gen

	partial void EnterRule_synpred95_Gen_fragment();
	partial void LeaveRule_synpred95_Gen_fragment();

	// $ANTLR start synpred95_Gen
	public void synpred95_Gen_fragment()
	{
		EnterRule_synpred95_Gen_fragment();
		EnterRule("synpred95_Gen_fragment", 159);
		TraceIn("synpred95_Gen_fragment", 159);
		try
		{
			// Gen.g:582:3: ( ^( UNARY_MINUS FLOAT_LITERAL ) )
			DebugEnterAlt(1);
			// Gen.g:582:3: ^( UNARY_MINUS FLOAT_LITERAL )
			{
			DebugLocation(582, 3);
			DebugLocation(582, 5);
			Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_synpred95_Gen3850); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(582, 17);
			Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_synpred95_Gen3852); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred95_Gen_fragment", 159);
			LeaveRule("synpred95_Gen_fragment", 159);
			LeaveRule_synpred95_Gen_fragment();
		}
	}
	// $ANTLR end synpred95_Gen

	partial void EnterRule_synpred96_Gen_fragment();
	partial void LeaveRule_synpred96_Gen_fragment();

	// $ANTLR start synpred96_Gen
	public void synpred96_Gen_fragment()
	{
		Gen.unaryExpression_return unaryExpression112 = default(Gen.unaryExpression_return);

		EnterRule_synpred96_Gen_fragment();
		EnterRule("synpred96_Gen_fragment", 160);
		TraceIn("synpred96_Gen_fragment", 160);
		try
		{
			// Gen.g:585:3: ( ^( UNARY_MINUS unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:585:3: ^( UNARY_MINUS unaryExpression ) {...}?
			{
			DebugLocation(585, 3);
			DebugLocation(585, 5);
			Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_synpred96_Gen3872); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(585, 17);
			PushFollow(Follow._unaryExpression_in_synpred96_Gen3874);
			unaryExpression112=unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(585, 34);
			if (!(((unaryExpression112!=null?((LSLAst)unaryExpression112.Start):default(LSLAst)).evalType == SymbolTable.INT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred96_Gen", "$unaryExpression.start.evalType == SymbolTable.INT");
			}

			}

		}
		finally
		{
			TraceOut("synpred96_Gen_fragment", 160);
			LeaveRule("synpred96_Gen_fragment", 160);
			LeaveRule_synpred96_Gen_fragment();
		}
	}
	// $ANTLR end synpred96_Gen

	partial void EnterRule_synpred97_Gen_fragment();
	partial void LeaveRule_synpred97_Gen_fragment();

	// $ANTLR start synpred97_Gen
	public void synpred97_Gen_fragment()
	{
		Gen.unaryExpression_return unaryExpression113 = default(Gen.unaryExpression_return);

		EnterRule_synpred97_Gen_fragment();
		EnterRule("synpred97_Gen_fragment", 161);
		TraceIn("synpred97_Gen_fragment", 161);
		try
		{
			// Gen.g:588:3: ( ^( UNARY_MINUS unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:588:3: ^( UNARY_MINUS unaryExpression ) {...}?
			{
			DebugLocation(588, 3);
			DebugLocation(588, 5);
			Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_synpred97_Gen3896); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(588, 17);
			PushFollow(Follow._unaryExpression_in_synpred97_Gen3898);
			unaryExpression113=unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(588, 34);
			if (!(((unaryExpression113!=null?((LSLAst)unaryExpression113.Start):default(LSLAst)).evalType == SymbolTable.FLOAT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred97_Gen", "$unaryExpression.start.evalType == SymbolTable.FLOAT");
			}

			}

		}
		finally
		{
			TraceOut("synpred97_Gen_fragment", 161);
			LeaveRule("synpred97_Gen_fragment", 161);
			LeaveRule_synpred97_Gen_fragment();
		}
	}
	// $ANTLR end synpred97_Gen

	partial void EnterRule_synpred98_Gen_fragment();
	partial void LeaveRule_synpred98_Gen_fragment();

	// $ANTLR start synpred98_Gen
	public void synpred98_Gen_fragment()
	{
		Gen.unaryExpression_return unaryExpression114 = default(Gen.unaryExpression_return);

		EnterRule_synpred98_Gen_fragment();
		EnterRule("synpred98_Gen_fragment", 162);
		TraceIn("synpred98_Gen_fragment", 162);
		try
		{
			// Gen.g:591:3: ( ^( UNARY_MINUS unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:591:3: ^( UNARY_MINUS unaryExpression ) {...}?
			{
			DebugLocation(591, 3);
			DebugLocation(591, 5);
			Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_synpred98_Gen3920); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(591, 17);
			PushFollow(Follow._unaryExpression_in_synpred98_Gen3922);
			unaryExpression114=unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(591, 34);
			if (!(((unaryExpression114!=null?((LSLAst)unaryExpression114.Start):default(LSLAst)).evalType == SymbolTable.VECTOR)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred98_Gen", "$unaryExpression.start.evalType == SymbolTable.VECTOR");
			}

			}

		}
		finally
		{
			TraceOut("synpred98_Gen_fragment", 162);
			LeaveRule("synpred98_Gen_fragment", 162);
			LeaveRule_synpred98_Gen_fragment();
		}
	}
	// $ANTLR end synpred98_Gen

	partial void EnterRule_synpred100_Gen_fragment();
	partial void LeaveRule_synpred100_Gen_fragment();

	// $ANTLR start synpred100_Gen
	public void synpred100_Gen_fragment()
	{
		LSLAst TYPE_CAST115 = default(LSLAst);

		EnterRule_synpred100_Gen_fragment();
		EnterRule("synpred100_Gen_fragment", 164);
		TraceIn("synpred100_Gen_fragment", 164);
		try
		{
			// Gen.g:606:4: ( ^( TYPE_CAST TYPE unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:606:4: ^( TYPE_CAST TYPE unaryExpression ) {...}?
			{
			DebugLocation(606, 4);
			DebugLocation(606, 6);
			TYPE_CAST115=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_synpred100_Gen4006); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(606, 16);
			Match(input,TYPE,Follow._TYPE_in_synpred100_Gen4008); if (state.failed) return;
			DebugLocation(606, 21);
			PushFollow(Follow._unaryExpression_in_synpred100_Gen4010);
			unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(606, 38);
			if (!((TYPE_CAST115.evalType == SymbolTable.INT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred100_Gen", "$TYPE_CAST.evalType == SymbolTable.INT");
			}

			}

		}
		finally
		{
			TraceOut("synpred100_Gen_fragment", 164);
			LeaveRule("synpred100_Gen_fragment", 164);
			LeaveRule_synpred100_Gen_fragment();
		}
	}
	// $ANTLR end synpred100_Gen

	partial void EnterRule_synpred101_Gen_fragment();
	partial void LeaveRule_synpred101_Gen_fragment();

	// $ANTLR start synpred101_Gen
	public void synpred101_Gen_fragment()
	{
		LSLAst TYPE_CAST116 = default(LSLAst);

		EnterRule_synpred101_Gen_fragment();
		EnterRule("synpred101_Gen_fragment", 165);
		TraceIn("synpred101_Gen_fragment", 165);
		try
		{
			// Gen.g:609:3: ( ^( TYPE_CAST TYPE unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:609:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
			{
			DebugLocation(609, 3);
			DebugLocation(609, 5);
			TYPE_CAST116=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_synpred101_Gen4032); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(609, 15);
			Match(input,TYPE,Follow._TYPE_in_synpred101_Gen4034); if (state.failed) return;
			DebugLocation(609, 20);
			PushFollow(Follow._unaryExpression_in_synpred101_Gen4036);
			unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(609, 37);
			if (!((TYPE_CAST116.evalType == SymbolTable.FLOAT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred101_Gen", "$TYPE_CAST.evalType == SymbolTable.FLOAT");
			}

			}

		}
		finally
		{
			TraceOut("synpred101_Gen_fragment", 165);
			LeaveRule("synpred101_Gen_fragment", 165);
			LeaveRule_synpred101_Gen_fragment();
		}
	}
	// $ANTLR end synpred101_Gen

	partial void EnterRule_synpred102_Gen_fragment();
	partial void LeaveRule_synpred102_Gen_fragment();

	// $ANTLR start synpred102_Gen
	public void synpred102_Gen_fragment()
	{
		LSLAst TYPE_CAST117 = default(LSLAst);

		EnterRule_synpred102_Gen_fragment();
		EnterRule("synpred102_Gen_fragment", 166);
		TraceIn("synpred102_Gen_fragment", 166);
		try
		{
			// Gen.g:612:3: ( ^( TYPE_CAST TYPE unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:612:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
			{
			DebugLocation(612, 3);
			DebugLocation(612, 5);
			TYPE_CAST117=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_synpred102_Gen4058); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(612, 15);
			Match(input,TYPE,Follow._TYPE_in_synpred102_Gen4060); if (state.failed) return;
			DebugLocation(612, 20);
			PushFollow(Follow._unaryExpression_in_synpred102_Gen4062);
			unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(612, 37);
			if (!((TYPE_CAST117.evalType == SymbolTable.STRING)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred102_Gen", "$TYPE_CAST.evalType == SymbolTable.STRING");
			}

			}

		}
		finally
		{
			TraceOut("synpred102_Gen_fragment", 166);
			LeaveRule("synpred102_Gen_fragment", 166);
			LeaveRule_synpred102_Gen_fragment();
		}
	}
	// $ANTLR end synpred102_Gen

	partial void EnterRule_synpred103_Gen_fragment();
	partial void LeaveRule_synpred103_Gen_fragment();

	// $ANTLR start synpred103_Gen
	public void synpred103_Gen_fragment()
	{
		LSLAst TYPE_CAST118 = default(LSLAst);

		EnterRule_synpred103_Gen_fragment();
		EnterRule("synpred103_Gen_fragment", 167);
		TraceIn("synpred103_Gen_fragment", 167);
		try
		{
			// Gen.g:615:3: ( ^( TYPE_CAST TYPE unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:615:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
			{
			DebugLocation(615, 3);
			DebugLocation(615, 5);
			TYPE_CAST118=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_synpred103_Gen4084); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(615, 15);
			Match(input,TYPE,Follow._TYPE_in_synpred103_Gen4086); if (state.failed) return;
			DebugLocation(615, 20);
			PushFollow(Follow._unaryExpression_in_synpred103_Gen4088);
			unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(615, 37);
			if (!((TYPE_CAST118.evalType == SymbolTable.KEY)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred103_Gen", "$TYPE_CAST.evalType == SymbolTable.KEY");
			}

			}

		}
		finally
		{
			TraceOut("synpred103_Gen_fragment", 167);
			LeaveRule("synpred103_Gen_fragment", 167);
			LeaveRule_synpred103_Gen_fragment();
		}
	}
	// $ANTLR end synpred103_Gen

	partial void EnterRule_synpred104_Gen_fragment();
	partial void LeaveRule_synpred104_Gen_fragment();

	// $ANTLR start synpred104_Gen
	public void synpred104_Gen_fragment()
	{
		LSLAst TYPE_CAST119 = default(LSLAst);

		EnterRule_synpred104_Gen_fragment();
		EnterRule("synpred104_Gen_fragment", 168);
		TraceIn("synpred104_Gen_fragment", 168);
		try
		{
			// Gen.g:618:3: ( ^( TYPE_CAST TYPE unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:618:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
			{
			DebugLocation(618, 3);
			DebugLocation(618, 5);
			TYPE_CAST119=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_synpred104_Gen4110); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(618, 15);
			Match(input,TYPE,Follow._TYPE_in_synpred104_Gen4112); if (state.failed) return;
			DebugLocation(618, 20);
			PushFollow(Follow._unaryExpression_in_synpred104_Gen4114);
			unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(618, 37);
			if (!((TYPE_CAST119.evalType == SymbolTable.VECTOR)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred104_Gen", "$TYPE_CAST.evalType == SymbolTable.VECTOR");
			}

			}

		}
		finally
		{
			TraceOut("synpred104_Gen_fragment", 168);
			LeaveRule("synpred104_Gen_fragment", 168);
			LeaveRule_synpred104_Gen_fragment();
		}
	}
	// $ANTLR end synpred104_Gen

	partial void EnterRule_synpred105_Gen_fragment();
	partial void LeaveRule_synpred105_Gen_fragment();

	// $ANTLR start synpred105_Gen
	public void synpred105_Gen_fragment()
	{
		LSLAst TYPE_CAST120 = default(LSLAst);

		EnterRule_synpred105_Gen_fragment();
		EnterRule("synpred105_Gen_fragment", 169);
		TraceIn("synpred105_Gen_fragment", 169);
		try
		{
			// Gen.g:621:3: ( ^( TYPE_CAST TYPE unaryExpression ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:621:3: ^( TYPE_CAST TYPE unaryExpression ) {...}?
			{
			DebugLocation(621, 3);
			DebugLocation(621, 5);
			TYPE_CAST120=(LSLAst)Match(input,TYPE_CAST,Follow._TYPE_CAST_in_synpred105_Gen4136); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(621, 15);
			Match(input,TYPE,Follow._TYPE_in_synpred105_Gen4138); if (state.failed) return;
			DebugLocation(621, 20);
			PushFollow(Follow._unaryExpression_in_synpred105_Gen4140);
			unaryExpression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(621, 37);
			if (!((TYPE_CAST120.evalType == SymbolTable.ROTATION)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred105_Gen", "$TYPE_CAST.evalType == SymbolTable.ROTATION");
			}

			}

		}
		finally
		{
			TraceOut("synpred105_Gen_fragment", 169);
			LeaveRule("synpred105_Gen_fragment", 169);
			LeaveRule_synpred105_Gen_fragment();
		}
	}
	// $ANTLR end synpred105_Gen

	partial void EnterRule_synpred108_Gen_fragment();
	partial void LeaveRule_synpred108_Gen_fragment();

	// $ANTLR start synpred108_Gen
	public void synpred108_Gen_fragment()
	{
		LSLAst ID121 = default(LSLAst);

		EnterRule_synpred108_Gen_fragment();
		EnterRule("synpred108_Gen_fragment", 172);
		TraceIn("synpred108_Gen_fragment", 172);
		try
		{
			// Gen.g:637:4: ( ^( PRE_DECREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:637:4: ^( PRE_DECREMENT ID ) {...}?
			{
			DebugLocation(637, 4);
			DebugLocation(637, 6);
			Match(input,PRE_DECREMENT,Follow._PRE_DECREMENT_in_synpred108_Gen4235); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(637, 20);
			ID121=(LSLAst)Match(input,ID,Follow._ID_in_synpred108_Gen4237); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(637, 24);
			if (!((ID121.evalType == SymbolTable.INT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred108_Gen", "$ID.evalType == SymbolTable.INT");
			}

			}

		}
		finally
		{
			TraceOut("synpred108_Gen_fragment", 172);
			LeaveRule("synpred108_Gen_fragment", 172);
			LeaveRule_synpred108_Gen_fragment();
		}
	}
	// $ANTLR end synpred108_Gen

	partial void EnterRule_synpred109_Gen_fragment();
	partial void LeaveRule_synpred109_Gen_fragment();

	// $ANTLR start synpred109_Gen
	public void synpred109_Gen_fragment()
	{
		LSLAst ID122 = default(LSLAst);

		EnterRule_synpred109_Gen_fragment();
		EnterRule("synpred109_Gen_fragment", 173);
		TraceIn("synpred109_Gen_fragment", 173);
		try
		{
			// Gen.g:643:3: ( ^( PRE_DECREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:643:3: ^( PRE_DECREMENT ID ) {...}?
			{
			DebugLocation(643, 3);
			DebugLocation(643, 5);
			Match(input,PRE_DECREMENT,Follow._PRE_DECREMENT_in_synpred109_Gen4274); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(643, 19);
			ID122=(LSLAst)Match(input,ID,Follow._ID_in_synpred109_Gen4276); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(643, 23);
			if (!((ID122.evalType == SymbolTable.FLOAT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred109_Gen", "$ID.evalType == SymbolTable.FLOAT");
			}

			}

		}
		finally
		{
			TraceOut("synpred109_Gen_fragment", 173);
			LeaveRule("synpred109_Gen_fragment", 173);
			LeaveRule_synpred109_Gen_fragment();
		}
	}
	// $ANTLR end synpred109_Gen

	partial void EnterRule_synpred110_Gen_fragment();
	partial void LeaveRule_synpred110_Gen_fragment();

	// $ANTLR start synpred110_Gen
	public void synpred110_Gen_fragment()
	{
		LSLAst ID123 = default(LSLAst);

		EnterRule_synpred110_Gen_fragment();
		EnterRule("synpred110_Gen_fragment", 174);
		TraceIn("synpred110_Gen_fragment", 174);
		try
		{
			// Gen.g:659:4: ( ^( PRE_INCREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:659:4: ^( PRE_INCREMENT ID ) {...}?
			{
			DebugLocation(659, 4);
			DebugLocation(659, 6);
			Match(input,PRE_INCREMENT,Follow._PRE_INCREMENT_in_synpred110_Gen4375); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(659, 20);
			ID123=(LSLAst)Match(input,ID,Follow._ID_in_synpred110_Gen4377); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(659, 24);
			if (!((ID123.evalType == SymbolTable.INT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred110_Gen", "$ID.evalType == SymbolTable.INT");
			}

			}

		}
		finally
		{
			TraceOut("synpred110_Gen_fragment", 174);
			LeaveRule("synpred110_Gen_fragment", 174);
			LeaveRule_synpred110_Gen_fragment();
		}
	}
	// $ANTLR end synpred110_Gen

	partial void EnterRule_synpred111_Gen_fragment();
	partial void LeaveRule_synpred111_Gen_fragment();

	// $ANTLR start synpred111_Gen
	public void synpred111_Gen_fragment()
	{
		LSLAst ID124 = default(LSLAst);

		EnterRule_synpred111_Gen_fragment();
		EnterRule("synpred111_Gen_fragment", 175);
		TraceIn("synpred111_Gen_fragment", 175);
		try
		{
			// Gen.g:665:3: ( ^( PRE_INCREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:665:3: ^( PRE_INCREMENT ID ) {...}?
			{
			DebugLocation(665, 3);
			DebugLocation(665, 5);
			Match(input,PRE_INCREMENT,Follow._PRE_INCREMENT_in_synpred111_Gen4414); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(665, 19);
			ID124=(LSLAst)Match(input,ID,Follow._ID_in_synpred111_Gen4416); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(665, 23);
			if (!((ID124.evalType == SymbolTable.FLOAT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred111_Gen", "$ID.evalType == SymbolTable.FLOAT");
			}

			}

		}
		finally
		{
			TraceOut("synpred111_Gen_fragment", 175);
			LeaveRule("synpred111_Gen_fragment", 175);
			LeaveRule_synpred111_Gen_fragment();
		}
	}
	// $ANTLR end synpred111_Gen

	partial void EnterRule_synpred118_Gen_fragment();
	partial void LeaveRule_synpred118_Gen_fragment();

	// $ANTLR start synpred118_Gen
	public void synpred118_Gen_fragment()
	{
		LSLAst ID125 = default(LSLAst);

		EnterRule_synpred118_Gen_fragment();
		EnterRule("synpred118_Gen_fragment", 182);
		TraceIn("synpred118_Gen_fragment", 182);
		try
		{
			// Gen.g:716:4: ( ^( POST_INCREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:716:4: ^( POST_INCREMENT ID ) {...}?
			{
			DebugLocation(716, 4);
			DebugLocation(716, 6);
			Match(input,POST_INCREMENT,Follow._POST_INCREMENT_in_synpred118_Gen4718); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(716, 21);
			ID125=(LSLAst)Match(input,ID,Follow._ID_in_synpred118_Gen4720); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(716, 25);
			if (!((ID125.symbol.Type == SymbolTable.INT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred118_Gen", "$ID.symbol.Type == SymbolTable.INT");
			}

			}

		}
		finally
		{
			TraceOut("synpred118_Gen_fragment", 182);
			LeaveRule("synpred118_Gen_fragment", 182);
			LeaveRule_synpred118_Gen_fragment();
		}
	}
	// $ANTLR end synpred118_Gen

	partial void EnterRule_synpred119_Gen_fragment();
	partial void LeaveRule_synpred119_Gen_fragment();

	// $ANTLR start synpred119_Gen
	public void synpred119_Gen_fragment()
	{
		LSLAst ID126 = default(LSLAst);

		EnterRule_synpred119_Gen_fragment();
		EnterRule("synpred119_Gen_fragment", 183);
		TraceIn("synpred119_Gen_fragment", 183);
		try
		{
			// Gen.g:723:3: ( ^( POST_INCREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:723:3: ^( POST_INCREMENT ID ) {...}?
			{
			DebugLocation(723, 3);
			DebugLocation(723, 5);
			Match(input,POST_INCREMENT,Follow._POST_INCREMENT_in_synpred119_Gen4761); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(723, 20);
			ID126=(LSLAst)Match(input,ID,Follow._ID_in_synpred119_Gen4763); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(723, 24);
			if (!((ID126.symbol.Type == SymbolTable.FLOAT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred119_Gen", "$ID.symbol.Type == SymbolTable.FLOAT");
			}

			}

		}
		finally
		{
			TraceOut("synpred119_Gen_fragment", 183);
			LeaveRule("synpred119_Gen_fragment", 183);
			LeaveRule_synpred119_Gen_fragment();
		}
	}
	// $ANTLR end synpred119_Gen

	partial void EnterRule_synpred120_Gen_fragment();
	partial void LeaveRule_synpred120_Gen_fragment();

	// $ANTLR start synpred120_Gen
	public void synpred120_Gen_fragment()
	{
		LSLAst ID127 = default(LSLAst);

		EnterRule_synpred120_Gen_fragment();
		EnterRule("synpred120_Gen_fragment", 184);
		TraceIn("synpred120_Gen_fragment", 184);
		try
		{
			// Gen.g:739:4: ( ^( POST_DECREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:739:4: ^( POST_DECREMENT ID ) {...}?
			{
			DebugLocation(739, 4);
			DebugLocation(739, 6);
			Match(input,POST_DECREMENT,Follow._POST_DECREMENT_in_synpred120_Gen4863); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(739, 21);
			ID127=(LSLAst)Match(input,ID,Follow._ID_in_synpred120_Gen4865); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(739, 25);
			if (!((ID127.symbol.Type == SymbolTable.INT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred120_Gen", "$ID.symbol.Type == SymbolTable.INT");
			}

			}

		}
		finally
		{
			TraceOut("synpred120_Gen_fragment", 184);
			LeaveRule("synpred120_Gen_fragment", 184);
			LeaveRule_synpred120_Gen_fragment();
		}
	}
	// $ANTLR end synpred120_Gen

	partial void EnterRule_synpred121_Gen_fragment();
	partial void LeaveRule_synpred121_Gen_fragment();

	// $ANTLR start synpred121_Gen
	public void synpred121_Gen_fragment()
	{
		LSLAst ID128 = default(LSLAst);

		EnterRule_synpred121_Gen_fragment();
		EnterRule("synpred121_Gen_fragment", 185);
		TraceIn("synpred121_Gen_fragment", 185);
		try
		{
			// Gen.g:746:3: ( ^( POST_DECREMENT ID ) {...}?)
			DebugEnterAlt(1);
			// Gen.g:746:3: ^( POST_DECREMENT ID ) {...}?
			{
			DebugLocation(746, 3);
			DebugLocation(746, 5);
			Match(input,POST_DECREMENT,Follow._POST_DECREMENT_in_synpred121_Gen4906); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(746, 20);
			ID128=(LSLAst)Match(input,ID,Follow._ID_in_synpred121_Gen4908); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(746, 24);
			if (!((ID128.symbol.Type == SymbolTable.FLOAT)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred121_Gen", "$ID.symbol.Type == SymbolTable.FLOAT");
			}

			}

		}
		finally
		{
			TraceOut("synpred121_Gen_fragment", 185);
			LeaveRule("synpred121_Gen_fragment", 185);
			LeaveRule_synpred121_Gen_fragment();
		}
	}
	// $ANTLR end synpred121_Gen

	partial void EnterRule_synpred125_Gen_fragment();
	partial void LeaveRule_synpred125_Gen_fragment();

	// $ANTLR start synpred125_Gen
	public void synpred125_Gen_fragment()
	{
		LSLAst ID129 = default(LSLAst);

		EnterRule_synpred125_Gen_fragment();
		EnterRule("synpred125_Gen_fragment", 189);
		TraceIn("synpred125_Gen_fragment", 189);
		try
		{
			// Gen.g:768:5: ( ID {...}?)
			DebugEnterAlt(1);
			// Gen.g:768:5: ID {...}?
			{
			DebugLocation(768, 5);
			ID129=(LSLAst)Match(input,ID,Follow._ID_in_synpred125_Gen5064); if (state.failed) return;
			DebugLocation(768, 8);
			if (!((ID129.symbol is ConstantSymbol)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred125_Gen", "$ID.symbol is ConstantSymbol");
			}

			}

		}
		finally
		{
			TraceOut("synpred125_Gen_fragment", 189);
			LeaveRule("synpred125_Gen_fragment", 189);
			LeaveRule_synpred125_Gen_fragment();
		}
	}
	// $ANTLR end synpred125_Gen

	partial void EnterRule_synpred126_Gen_fragment();
	partial void LeaveRule_synpred126_Gen_fragment();

	// $ANTLR start synpred126_Gen
	public void synpred126_Gen_fragment()
	{
		LSLAst ID130 = default(LSLAst);

		EnterRule_synpred126_Gen_fragment();
		EnterRule("synpred126_Gen_fragment", 190);
		TraceIn("synpred126_Gen_fragment", 190);
		try
		{
			// Gen.g:774:4: ( ID {...}?)
			DebugEnterAlt(1);
			// Gen.g:774:4: ID {...}?
			{
			DebugLocation(774, 4);
			ID130=(LSLAst)Match(input,ID,Follow._ID_in_synpred126_Gen5101); if (state.failed) return;
			DebugLocation(774, 7);
			if (!((!(ID130.symbol is ConstantSymbol))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred126_Gen", "!($ID.symbol is ConstantSymbol)");
			}

			}

		}
		finally
		{
			TraceOut("synpred126_Gen_fragment", 190);
			LeaveRule("synpred126_Gen_fragment", 190);
			LeaveRule_synpred126_Gen_fragment();
		}
	}
	// $ANTLR end synpred126_Gen

	partial void EnterRule_synpred127_Gen_fragment();
	partial void LeaveRule_synpred127_Gen_fragment();

	// $ANTLR start synpred127_Gen
	public void synpred127_Gen_fragment()
	{
		EnterRule_synpred127_Gen_fragment();
		EnterRule("synpred127_Gen_fragment", 191);
		TraceIn("synpred127_Gen_fragment", 191);
		try
		{
			// Gen.g:779:4: ( vecConst )
			DebugEnterAlt(1);
			// Gen.g:779:5: vecConst
			{
			DebugLocation(779, 5);
			PushFollow(Follow._vecConst_in_synpred127_Gen5135);
			vecConst();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred127_Gen_fragment", 191);
			LeaveRule("synpred127_Gen_fragment", 191);
			LeaveRule_synpred127_Gen_fragment();
		}
	}
	// $ANTLR end synpred127_Gen

	partial void EnterRule_synpred128_Gen_fragment();
	partial void LeaveRule_synpred128_Gen_fragment();

	// $ANTLR start synpred128_Gen
	public void synpred128_Gen_fragment()
	{
		EnterRule_synpred128_Gen_fragment();
		EnterRule("synpred128_Gen_fragment", 192);
		TraceIn("synpred128_Gen_fragment", 192);
		try
		{
			// Gen.g:780:4: ( vecLiteral )
			DebugEnterAlt(1);
			// Gen.g:780:4: vecLiteral
			{
			DebugLocation(780, 4);
			PushFollow(Follow._vecLiteral_in_synpred128_Gen5149);
			vecLiteral();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred128_Gen_fragment", 192);
			LeaveRule("synpred128_Gen_fragment", 192);
			LeaveRule_synpred128_Gen_fragment();
		}
	}
	// $ANTLR end synpred128_Gen

	partial void EnterRule_synpred129_Gen_fragment();
	partial void LeaveRule_synpred129_Gen_fragment();

	// $ANTLR start synpred129_Gen
	public void synpred129_Gen_fragment()
	{
		EnterRule_synpred129_Gen_fragment();
		EnterRule("synpred129_Gen_fragment", 193);
		TraceIn("synpred129_Gen_fragment", 193);
		try
		{
			// Gen.g:781:4: ( rotConst )
			DebugEnterAlt(1);
			// Gen.g:781:5: rotConst
			{
			DebugLocation(781, 5);
			PushFollow(Follow._rotConst_in_synpred129_Gen5159);
			rotConst();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred129_Gen_fragment", 193);
			LeaveRule("synpred129_Gen_fragment", 193);
			LeaveRule_synpred129_Gen_fragment();
		}
	}
	// $ANTLR end synpred129_Gen

	partial void EnterRule_synpred130_Gen_fragment();
	partial void LeaveRule_synpred130_Gen_fragment();

	// $ANTLR start synpred130_Gen
	public void synpred130_Gen_fragment()
	{
		EnterRule_synpred130_Gen_fragment();
		EnterRule("synpred130_Gen_fragment", 194);
		TraceIn("synpred130_Gen_fragment", 194);
		try
		{
			// Gen.g:782:4: ( rotLiteral )
			DebugEnterAlt(1);
			// Gen.g:782:4: rotLiteral
			{
			DebugLocation(782, 4);
			PushFollow(Follow._rotLiteral_in_synpred130_Gen5173);
			rotLiteral();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred130_Gen_fragment", 194);
			LeaveRule("synpred130_Gen_fragment", 194);
			LeaveRule_synpred130_Gen_fragment();
		}
	}
	// $ANTLR end synpred130_Gen
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA9 dfa9;
	private DFA17 dfa17;
	private DFA27 dfa27;
	private DFA29 dfa29;
	private DFA67 dfa67;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa9 = new DFA9( this );
		dfa17 = new DFA17( this );
		dfa27 = new DFA27( this, SpecialStateTransition27 );
		dfa29 = new DFA29( this );
		dfa67 = new DFA67( this, SpecialStateTransition67 );
	}

	private class DFA9 : DFA
	{
		private const string DFA9_eotS =
			"\xE\xFFFF";
		private const string DFA9_eofS =
			"\xE\xFFFF";
		private const string DFA9_minS =
			"\x1\xC\x1\x2\x1\x13\x1\x11\x2\x2\x1\x3\x2\xFFFF\x1\x2\x1\x11\x1\x4\x2"+
			"\x3";
		private const string DFA9_maxS =
			"\x1\xC\x1\x2\x1\x13\x1\x20\x1\x2\x1\x3\x1\x5F\x2\xFFFF\x1\x5F\x1\x20"+
			"\x3\x5F";
		private const string DFA9_acceptS =
			"\x7\xFFFF\x1\x1\x1\x2\x5\xFFFF";
		private const string DFA9_specialS =
			"\xE\xFFFF}>";
		private static readonly string[] DFA9_transitionS =
			{
				"\x1\x1",
				"\x1\x2",
				"\x1\x3",
				"\x1\x5\xE\xFFFF\x1\x4",
				"\x1\x6",
				"\x1\x7\x1\x8",
				"\x1\xA\x5C\x9",
				"",
				"",
				"\x1\xB\x1\xA\x5C\x9",
				"\x1\x5\xE\xFFFF\x1\x4",
				"\x5C\xC",
				"\x1\xD\x5C\xC",
				"\x1\xA\x5C\x9"
			};

		private static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
		private static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
		private static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
		private static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
		private static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
		private static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
		private static readonly short[][] DFA9_transition;

		static DFA9()
		{
			int numStates = DFA9_transitionS.Length;
			DFA9_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
			}
		}

		public DFA9( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 9;
			this.eot = DFA9_eot;
			this.eof = DFA9_eof;
			this.min = DFA9_min;
			this.max = DFA9_max;
			this.accept = DFA9_accept;
			this.special = DFA9_special;
			this.transition = DFA9_transition;
		}

		public override string Description { get { return "96:1: eventDef : ( ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) ) -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=$fbc)| ^( EVENT_DEF ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK ) -> eventdef(eventname=es.FullEventNameargcount=es.Members.Countlocalscount=es.CurrentVariableIndex - es.Members.Countcontent=null));"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA17 : DFA
	{
		private const string DFA17_eotS =
			"\xF\xFFFF";
		private const string DFA17_eofS =
			"\xF\xFFFF";
		private const string DFA17_minS =
			"\x1\x1D\x1\x2\x2\x13\x1\x11\x2\x2\x1\x3\x2\xFFFF\x1\x2\x1\x11\x1\x4\x2"+
			"\x3";
		private const string DFA17_maxS =
			"\x1\x1D\x1\x2\x1\x2E\x1\x13\x1\x20\x1\x2\x1\x3\x1\x5F\x2\xFFFF\x1\x5F"+
			"\x1\x20\x3\x5F";
		private const string DFA17_acceptS =
			"\x8\xFFFF\x1\x1\x1\x2\x5\xFFFF";
		private const string DFA17_specialS =
			"\xF\xFFFF}>";
		private static readonly string[] DFA17_transitionS =
			{
				"\x1\x1",
				"\x1\x2",
				"\x1\x4\x1A\xFFFF\x1\x3",
				"\x1\x4",
				"\x1\x6\xE\xFFFF\x1\x5",
				"\x1\x7",
				"\x1\x8\x1\x9",
				"\x1\xB\x5C\xA",
				"",
				"",
				"\x1\xC\x1\xB\x5C\xA",
				"\x1\x6\xE\xFFFF\x1\x5",
				"\x5C\xD",
				"\x1\xE\x5C\xD",
				"\x1\xB\x5C\xA"
			};

		private static readonly short[] DFA17_eot = DFA.UnpackEncodedString(DFA17_eotS);
		private static readonly short[] DFA17_eof = DFA.UnpackEncodedString(DFA17_eofS);
		private static readonly char[] DFA17_min = DFA.UnpackEncodedStringToUnsignedChars(DFA17_minS);
		private static readonly char[] DFA17_max = DFA.UnpackEncodedStringToUnsignedChars(DFA17_maxS);
		private static readonly short[] DFA17_accept = DFA.UnpackEncodedString(DFA17_acceptS);
		private static readonly short[] DFA17_special = DFA.UnpackEncodedString(DFA17_specialS);
		private static readonly short[][] DFA17_transition;

		static DFA17()
		{
			int numStates = DFA17_transitionS.Length;
			DFA17_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA17_transition[i] = DFA.UnpackEncodedString(DFA17_transitionS[i]);
			}
		}

		public DFA17( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 17;
			this.eot = DFA17_eot;
			this.eof = DFA17_eof;
			this.min = DFA17_min;
			this.max = DFA17_max;
			this.accept = DFA17_accept;
			this.special = DFA17_special;
			this.transition = DFA17_transition;
		}

		public override string Description { get { return "116:1: functions : ( ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* ^( FUNC_BLOCK (fbc+= funcBlockContent )+ ) ) -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=$fbc)| ^( METHOD_DEF ( TYPE )? ID ( ^( PARAM_DECL ( . )* ) )* FUNC_BLOCK ) -> methoddef(methodname=ms.RawNameargcount=ms.Members.Countlocalscount=ms.CurrentVariableIndex - ms.Members.Countcontent=null));"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA27 : DFA
	{
		private const string DFA27_eotS =
			"\x3F\xFFFF";
		private const string DFA27_eofS =
			"\x3F\xFFFF";
		private const string DFA27_minS =
			"\x1\x4\x1\xFFFF\x1\x0\x9\xFFFF\x1\x0\x32\xFFFF";
		private const string DFA27_maxS =
			"\x1\x5D\x1\xFFFF\x1\x0\x9\xFFFF\x1\x0\x32\xFFFF";
		private const string DFA27_acceptS =
			"\x1\xFFFF\x1\x1\x1\xFFFF\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA\x1"+
			"\xB\x1\xC\x1\xFFFF\x1\x12\x2A\xFFFF\x1\x2\x1\x3\x1\xD\x1\xE\x1\xF\x1"+
			"\x10\x1\x11";
		private const string DFA27_specialS =
			"\x2\xFFFF\x1\x0\x9\xFFFF\x1\x1\x32\xFFFF}>";
		private static readonly string[] DFA27_transitionS =
			{
				"\x1\xD\x3\xFFFF\x1\x9\x5\xFFFF\x1\xC\x1\xD\x1\xA\x1\x6\x2\xD\x1\x7\x1"+
				"\xFFFF\x1\xD\x1\x5\x1\x4\x1\xD\x1\xFFFF\x2\xD\x1\xFFFF\x1\xD\x2\xFFFF"+
				"\x4\xD\x1\x3\x1\xD\x1\xFFFF\x1\x1\x1\xFFFF\x1\xB\x1\xFFFF\x2\xD\x1\xFFFF"+
				"\x4\xD\x1\x2\x1\xD\x1\x8\x2\xFFFF\x8\xD\x1\xFFFF\x1\xD\x1\xFFFF\x1\xD"+
				"\x1\xFFFF\x9\xD\x3\xFFFF\x1\xD\xA\xFFFF\x2\xD",
				"",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA27_eot = DFA.UnpackEncodedString(DFA27_eotS);
		private static readonly short[] DFA27_eof = DFA.UnpackEncodedString(DFA27_eofS);
		private static readonly char[] DFA27_min = DFA.UnpackEncodedStringToUnsignedChars(DFA27_minS);
		private static readonly char[] DFA27_max = DFA.UnpackEncodedStringToUnsignedChars(DFA27_maxS);
		private static readonly short[] DFA27_accept = DFA.UnpackEncodedString(DFA27_acceptS);
		private static readonly short[] DFA27_special = DFA.UnpackEncodedString(DFA27_specialS);
		private static readonly short[][] DFA27_transition;

		static DFA27()
		{
			int numStates = DFA27_transitionS.Length;
			DFA27_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA27_transition[i] = DFA.UnpackEncodedString(DFA27_transitionS[i]);
			}
		}

		public DFA27( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 27;
			this.eot = DFA27_eot;
			this.eof = DFA27_eof;
			this.min = DFA27_min;
			this.max = DFA27_max;
			this.accept = DFA27_accept;
			this.special = DFA27_special;
			this.transition = DFA27_transition;
		}

		public override string Description { get { return "138:1: funcBlockContent : ( SEMI | ^( VAR_DECL TYPE ID e= expression ) -> lstore(expression=$e.stgindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( VAR_DECL TYPE ID ) -> linit(subtemplate=TemplateMapping.Init[$ID.symbol.Type.TypeIndex] + \"l\"lindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ^( RETURN_STMT (e= expression )? ) -> return(expression=$e.st)| ^( LABEL ID ) -> label(id=((LabelSymbol)$ID.symbol).DecoratedName)| ^( JUMP_STMT ID ) -> jump(id=((LabelSymbol)$ID.symbol).DecoratedName)| funcBlock -> {$funcBlock.st}| ^( IF_STMT e= expression stmt= statement ( ^( ELSE_PART eelse= statement ) | ELSE_PART ) ) -> ifelse(evalexpr=$e.ststmt=$stmt.staltstmt=$eelse.stendlabel=System.String.Format(\"if_end_{0}\", LabelId++)altlabel=System.String.Format(\"if_else_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( WHILE_STMT e= expression stmt= statement ) -> while(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( DO_WHILE_STMT e= expression stmt= statement ) -> dowhile(evalexpr=$e.ststmt=$stmt.stloopstartlabel=System.String.Format(\"do_while_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"do_while_out_{0}\", LabelId++)needsBoolEval=$expression.start.evalType != SymbolTable.INT)| ^( FOR_STMT body= statement (inits= SEMI |init= expression ) (conds= SEMI |cond= expression ) (eloop= expression )? ) -> forloop(initexpr=$init.stcondexpr=$cond.stloopexpr=$eloop.ststmt=$body.stloopstartlabel=System.String.Format(\"forloop_start_{0}\", LabelId++)loopoutlabel=System.String.Format(\"forloop_out_{0}\", LabelId++)needsBoolEval=cond != null && $cond.start.evalType != SymbolTable.INT)| ( ^( STATE_CHG ID ) | STATE_CHG ) -> statechg(id=$ID)| ^( EXPR methodCall[true, true] ) -> {$methodCall.st}| ^( EXPR preIncrement ) -> pop(expression=$preIncrement.st)| ^( EXPR postIncrement ) -> pop(expression=$postIncrement.st)| ^( EXPR preDecrement ) -> pop(expression=$preDecrement.st)| ^( EXPR postDecrement ) -> pop(expression=$postDecrement.st)| assignmentExpression[false] -> {$assignmentExpression.st});"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition27(DFA dfa, int s, IIntStream _input)
	{
		ITreeNodeStream input = (ITreeNodeStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA27_2 = input.LA(1);


				int index27_2 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred24_Gen_fragment))) {s = 56;}

				else if ((EvaluatePredicate(synpred25_Gen_fragment))) {s = 57;}


				input.Seek(index27_2);
				if (s >= 0) return s;
				break;
			case 1:
				int LA27_12 = input.LA(1);


				int index27_12 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred41_Gen_fragment))) {s = 58;}

				else if ((EvaluatePredicate(synpred42_Gen_fragment))) {s = 59;}

				else if ((EvaluatePredicate(synpred43_Gen_fragment))) {s = 60;}

				else if ((EvaluatePredicate(synpred44_Gen_fragment))) {s = 61;}

				else if ((EvaluatePredicate(synpred45_Gen_fragment))) {s = 62;}

				else if ((true)) {s = 13;}


				input.Seek(index27_12);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 27, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA29 : DFA
	{
		private const string DFA29_eotS =
			"\xA\xFFFF";
		private const string DFA29_eofS =
			"\xA\xFFFF";
		private const string DFA29_minS =
			"\x1\x4\x9\xFFFF";
		private const string DFA29_maxS =
			"\x1\x5D\x9\xFFFF";
		private const string DFA29_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9";
		private const string DFA29_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA29_transitionS =
			{
				"\x1\x1\x9\xFFFF\x2\x9\x2\xFFFF\x2\x9\x2\xFFFF\x1\x9\x2\xFFFF\x1\x9\x1"+
				"\xFFFF\x2\x9\x1\xFFFF\x1\x9\x2\xFFFF\x4\x9\x1\xFFFF\x1\x9\x5\xFFFF\x2"+
				"\x9\x1\xFFFF\x4\x9\x1\xFFFF\x1\x9\x3\xFFFF\x2\x9\x1\x6\x3\x9\x1\x4\x1"+
				"\x9\x1\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x1\x9\x1\x5\x1\x9\x1\x7\x4"+
				"\x9\x1\x8\x3\xFFFF\x1\x9\xA\xFFFF\x2\x9",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA29_eot = DFA.UnpackEncodedString(DFA29_eotS);
		private static readonly short[] DFA29_eof = DFA.UnpackEncodedString(DFA29_eofS);
		private static readonly char[] DFA29_min = DFA.UnpackEncodedStringToUnsignedChars(DFA29_minS);
		private static readonly char[] DFA29_max = DFA.UnpackEncodedStringToUnsignedChars(DFA29_maxS);
		private static readonly short[] DFA29_accept = DFA.UnpackEncodedString(DFA29_acceptS);
		private static readonly short[] DFA29_special = DFA.UnpackEncodedString(DFA29_specialS);
		private static readonly short[][] DFA29_transition;

		static DFA29()
		{
			int numStates = DFA29_transitionS.Length;
			DFA29_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA29_transition[i] = DFA.UnpackEncodedString(DFA29_transitionS[i]);
			}
		}

		public DFA29( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 29;
			this.eot = DFA29_eot;
			this.eof = DFA29_eof;
			this.min = DFA29_min;
			this.max = DFA29_max;
			this.accept = DFA29_accept;
			this.special = DFA29_special;
			this.transition = DFA29_transition;
		}

		public override string Description { get { return "252:1: assignmentExpression[bool pushfinal] : ( assign[pushfinal] -> {$assign.st}| addassign[pushfinal] -> {$addassign.st}| subtractassign[pushfinal] -> {$subtractassign.st}| multassign[pushfinal] -> {$multassign.st}| divassign[pushfinal] -> {$divassign.st}| modassign[pushfinal] -> {$modassign.st}| lshassign[pushfinal] -> {$lshassign.st}| rshassign[pushfinal] -> {$rshassign.st}| booleanExpression {...}? -> {$booleanExpression.st});"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA67 : DFA
	{
		private const string DFA67_eotS =
			"\xF\xFFFF";
		private const string DFA67_eofS =
			"\xF\xFFFF";
		private const string DFA67_minS =
			"\x1\xE\x3\xFFFF\x3\x0\x8\xFFFF";
		private const string DFA67_maxS =
			"\x1\x34\x3\xFFFF\x3\x0\x8\xFFFF";
		private const string DFA67_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x3\xFFFF\x1\xA\x1\xB\x1\x4\x1\x5\x1\x6\x1"+
			"\x7\x1\x8\x1\x9";
		private const string DFA67_specialS =
			"\x4\xFFFF\x1\x0\x1\x1\x1\x2\x8\xFFFF}>";
		private static readonly string[] DFA67_transitionS =
			{
				"\x1\x8\x1\x3\x3\xFFFF\x1\x4\x2\xFFFF\x1\x2\x2\xFFFF\x1\x7\xC\xFFFF\x1"+
				"\x6\x5\xFFFF\x1\x1\x7\xFFFF\x1\x5",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA67_eot = DFA.UnpackEncodedString(DFA67_eotS);
		private static readonly short[] DFA67_eof = DFA.UnpackEncodedString(DFA67_eofS);
		private static readonly char[] DFA67_min = DFA.UnpackEncodedStringToUnsignedChars(DFA67_minS);
		private static readonly char[] DFA67_max = DFA.UnpackEncodedStringToUnsignedChars(DFA67_maxS);
		private static readonly short[] DFA67_accept = DFA.UnpackEncodedString(DFA67_acceptS);
		private static readonly short[] DFA67_special = DFA.UnpackEncodedString(DFA67_specialS);
		private static readonly short[][] DFA67_transition;

		static DFA67()
		{
			int numStates = DFA67_transitionS.Length;
			DFA67_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA67_transition[i] = DFA.UnpackEncodedString(DFA67_transitionS[i]);
			}
		}

		public DFA67( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 67;
			this.eot = DFA67_eot;
			this.eof = DFA67_eof;
			this.min = DFA67_min;
			this.max = DFA67_max;
			this.accept = DFA67_accept;
			this.special = DFA67_special;
			this.transition = DFA67_transition;
		}

		public override string Description { get { return "761:1: primary : ( STRING_LITERAL -> sconst(constText=$STRING_LITERAL.text)| INTEGER_LITERAL -> iconst(constText=$INTEGER_LITERAL.text)| FLOAT_LITERAL -> fconst(constText=this.FormatFloat($FLOAT_LITERAL.text))| ID {...}? -> sysconstload(template=((ConstantSymbol)$ID.symbol).TemplateNamevalue=((ConstantSymbol)$ID.symbol).ConstValue)| ID {...}? -> idload(isglobal=((VariableSymbol)$ID.symbol).IsGlobalindex=((VariableSymbol)$ID.symbol).ScopeIndex)| ( vecConst )=> vecConst -> {$vecConst.st}| vecLiteral -> {$vecLiteral.st}| ( rotConst )=> rotConst -> {$rotConst.st}| rotLiteral -> {$rotLiteral.st}| listLiteral -> {$listLiteral.st}| expression -> {$expression.st});"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition67(DFA dfa, int s, IIntStream _input)
	{
		ITreeNodeStream input = (ITreeNodeStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA67_4 = input.LA(1);


				int index67_4 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred125_Gen_fragment))) {s = 9;}

				else if ((EvaluatePredicate(synpred126_Gen_fragment))) {s = 10;}


				input.Seek(index67_4);
				if (s >= 0) return s;
				break;
			case 1:
				int LA67_5 = input.LA(1);


				int index67_5 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred127_Gen_fragment))) {s = 11;}

				else if ((EvaluatePredicate(synpred128_Gen_fragment))) {s = 12;}


				input.Seek(index67_5);
				if (s >= 0) return s;
				break;
			case 2:
				int LA67_6 = input.LA(1);


				int index67_6 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred129_Gen_fragment))) {s = 13;}

				else if ((EvaluatePredicate(synpred130_Gen_fragment))) {s = 14;}


				input.Seek(index67_6);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 67, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _globalInits_in_script85 = new BitSet(new ulong[]{0x8080020000002UL});
		public static readonly BitSet _functions_in_script91 = new BitSet(new ulong[]{0x8080020000002UL});
		public static readonly BitSet _states_in_script97 = new BitSet(new ulong[]{0x8080020000002UL});
		public static readonly BitSet _STATE_DEF_in_states170 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_states172 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _STATE_BLOCK_in_states175 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _eventDef_in_states179 = new BitSet(new ulong[]{0x1008UL});
		public static readonly BitSet _STATE_DEF_in_states187 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_states189 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _STATE_BLOCK_in_states191 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EVENT_DEF_in_eventDef220 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_eventDef222 = new BitSet(new ulong[]{0x100020000UL});
		public static readonly BitSet _PARAM_DECL_in_eventDef226 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FUNC_BLOCK_in_eventDef235 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _funcBlockContent_in_eventDef239 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EVENT_DEF_in_eventDef294 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_eventDef296 = new BitSet(new ulong[]{0x100020000UL});
		public static readonly BitSet _PARAM_DECL_in_eventDef300 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FUNC_BLOCK_in_eventDef308 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _METHOD_DEF_in_functions372 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_functions374 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_functions377 = new BitSet(new ulong[]{0x100020000UL});
		public static readonly BitSet _PARAM_DECL_in_functions381 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FUNC_BLOCK_in_functions390 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _funcBlockContent_in_functions394 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _METHOD_DEF_in_functions435 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_functions437 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_functions440 = new BitSet(new ulong[]{0x100020000UL});
		public static readonly BitSet _PARAM_DECL_in_functions444 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FUNC_BLOCK_in_functions452 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNC_BLOCK_in_funcBlock498 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _funcBlockContent_in_funcBlock502 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _FUNC_BLOCK_in_funcBlock508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcBlock_in_statement531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcBlockContent_in_statement540 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMI_in_funcBlockContent558 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_DECL_in_funcBlockContent565 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_funcBlockContent567 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent569 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expression_in_funcBlockContent573 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_DECL_in_funcBlockContent607 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_funcBlockContent609 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent611 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RETURN_STMT_in_funcBlockContent645 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_funcBlockContent649 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LABEL_in_funcBlockContent670 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_funcBlockContent672 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _JUMP_STMT_in_funcBlockContent692 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_funcBlockContent694 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _funcBlock_in_funcBlockContent712 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_STMT_in_funcBlockContent726 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_funcBlockContent730 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _statement_in_funcBlockContent734 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ELSE_PART_in_funcBlockContent738 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_funcBlockContent742 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ELSE_PART_in_funcBlockContent747 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _WHILE_STMT_in_funcBlockContent818 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_funcBlockContent822 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _statement_in_funcBlockContent826 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DO_WHILE_STMT_in_funcBlockContent886 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_funcBlockContent890 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _statement_in_funcBlockContent894 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FOR_STMT_in_funcBlockContent955 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_funcBlockContent959 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _SEMI_in_funcBlockContent964 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expression_in_funcBlockContent970 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _SEMI_in_funcBlockContent976 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expression_in_funcBlockContent982 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expression_in_funcBlockContent987 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STATE_CHG_in_funcBlockContent1066 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_funcBlockContent1068 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STATE_CHG_in_funcBlockContent1073 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXPR_in_funcBlockContent1093 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _methodCall_in_funcBlockContent1095 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_funcBlockContent1109 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _preIncrement_in_funcBlockContent1111 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_funcBlockContent1132 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _postIncrement_in_funcBlockContent1134 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_funcBlockContent1155 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _preDecrement_in_funcBlockContent1157 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_funcBlockContent1178 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _postDecrement_in_funcBlockContent1180 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_funcBlockContent1200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_DECL_in_globalInits1217 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_globalInits1219 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_globalInits1221 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expression_in_globalInits1225 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_DECL_in_globalInits1259 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_globalInits1261 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_globalInits1263 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_expression1311 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expression1313 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_expr1340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_in_assignmentExpression1367 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _addassign_in_assignmentExpression1377 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtractassign_in_assignmentExpression1387 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multassign_in_assignmentExpression1397 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _divassign_in_assignmentExpression1407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modassign_in_assignmentExpression1417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lshassign_in_assignmentExpression1427 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rshassign_in_assignmentExpression1437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanExpression_in_assignmentExpression1447 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _77_in_rshassign1466 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_rshassign1471 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_rshassign1476 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_rshassign1480 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_rshassign1486 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _72_in_lshassign1550 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_lshassign1555 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_lshassign1560 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_lshassign1564 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_lshassign1570 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _58_in_modassign1634 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_modassign1639 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_modassign1644 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_modassign1648 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_modassign1654 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _70_in_divassign1718 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_divassign1723 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_divassign1728 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_divassign1732 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_divassign1738 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _70_in_divassign1797 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_divassign1800 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_divassign1806 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_divassign1810 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_divassign1817 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_divassign1821 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_divassign1826 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_divassign1833 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _62_in_multassign1905 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_multassign1910 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_multassign1915 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_multassign1919 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_multassign1925 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _62_in_multassign1984 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_multassign1987 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_multassign1993 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_multassign1997 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_multassign2004 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_multassign2008 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_multassign2013 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_multassign2020 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _67_in_subtractassign2092 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_subtractassign2097 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_subtractassign2102 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_subtractassign2106 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_subtractassign2112 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _67_in_subtractassign2171 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_subtractassign2174 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_subtractassign2180 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_subtractassign2184 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_subtractassign2191 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_subtractassign2195 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_subtractassign2200 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_subtractassign2207 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _65_in_addassign2279 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_addassign2284 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_addassign2289 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_addassign2293 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_addassign2299 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _65_in_addassign2358 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_addassign2361 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_addassign2367 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_addassign2371 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_addassign2378 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_addassign2382 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_addassign2387 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_addassign2394 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_EQ_in_assign2466 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign2471 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _EXPR_in_assign2476 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign2480 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_assign2486 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_EQ_in_assign2537 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_assign2540 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign2546 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_assign2550 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_assign2557 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign2561 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_assign2566 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignmentExpression_in_assign2573 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _boolor_in_booleanExpression2646 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booland_in_booleanExpression2655 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseExpression_in_booleanExpression2664 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _93_in_boolor2680 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _booleanExpression_in_boolor2684 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _booleanExpression_in_boolor2688 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _59_in_booland2717 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _booleanExpression_in_booland2721 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _booleanExpression_in_booland2725 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _bitor_in_bitwiseExpression2763 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitand_in_bitwiseExpression2772 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitxor_in_bitwiseExpression2781 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpression_in_bitwiseExpression2790 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _92_in_bitor2806 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _bitwiseExpression_in_bitor2810 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _bitwiseExpression_in_bitor2814 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _60_in_bitand2843 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _bitwiseExpression_in_bitand2847 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _bitwiseExpression_in_bitand2851 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _81_in_bitxor2880 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _bitwiseExpression_in_bitxor2884 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _bitwiseExpression_in_bitxor2888 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _equals_in_equalityExpression2916 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _notEquals_in_equalityExpression2925 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression2934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _74_in_equals2952 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _relationalExpression_in_equals2956 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _relationalExpression_in_equals2960 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _56_in_notEquals3006 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _relationalExpression_in_notEquals3010 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _relationalExpression_in_notEquals3014 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _lessThan_in_relationalExpression3067 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _greaterThan_in_relationalExpression3076 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lessOrEquals_in_relationalExpression3085 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _greaterOrEquals_in_relationalExpression3094 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _binaryBitwiseExpression_in_relationalExpression3103 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _73_in_lessOrEquals3119 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _binaryBitwiseExpression_in_lessOrEquals3123 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _binaryBitwiseExpression_in_lessOrEquals3127 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _75_in_greaterOrEquals3161 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _binaryBitwiseExpression_in_greaterOrEquals3165 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _binaryBitwiseExpression_in_greaterOrEquals3169 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LT_in_lessThan3203 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _binaryBitwiseExpression_in_lessThan3207 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _binaryBitwiseExpression_in_lessThan3211 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GT_in_greaterThan3245 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _binaryBitwiseExpression_in_greaterThan3249 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _binaryBitwiseExpression_in_greaterThan3253 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _leftShift_in_binaryBitwiseExpression3296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rightShift_in_binaryBitwiseExpression3305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _additiveExpression_in_binaryBitwiseExpression3314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _71_in_leftShift3330 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _binaryBitwiseExpression_in_leftShift3334 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _binaryBitwiseExpression_in_leftShift3338 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _76_in_rightShift3367 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _binaryBitwiseExpression_in_rightShift3371 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _binaryBitwiseExpression_in_rightShift3375 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _add_in_additiveExpression3413 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtract_in_additiveExpression3422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression3431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_subtract3449 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _additiveExpression_in_subtract3453 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _additiveExpression_in_subtract3457 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _63_in_add3493 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _additiveExpression_in_add3497 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _additiveExpression_in_add3501 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _mult_in_multiplicativeExpression3545 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _div_in_multiplicativeExpression3554 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mod_in_multiplicativeExpression3563 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression3572 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _57_in_mod3590 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _multiplicativeExpression_in_mod3594 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _multiplicativeExpression_in_mod3598 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _69_in_div3634 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _multiplicativeExpression_in_div3638 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _multiplicativeExpression_in_div3642 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _61_in_mult3678 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _multiplicativeExpression_in_mult3682 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _multiplicativeExpression_in_mult3686 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _unaryMinus_in_unaryExpression3729 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryBoolNot_in_unaryExpression3738 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _uBitNot_in_unaryExpression3747 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeCastExpression_in_unaryExpression3756 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UNARY_BIT_NOT_in_uBitNot3772 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_uBitNot3774 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_BOOL_NOT_in_unaryBoolNot3798 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_unaryBoolNot3800 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_unaryMinus3828 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INTEGER_LITERAL_in_unaryMinus3830 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_unaryMinus3850 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FLOAT_LITERAL_in_unaryMinus3852 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_unaryMinus3872 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_unaryMinus3874 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_unaryMinus3896 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_unaryMinus3898 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_unaryMinus3920 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_unaryMinus3922 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_unaryMinus3944 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_unaryMinus3946 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _typeCast_in_typeCastExpression3981 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preIncDecExpression_in_typeCastExpression3990 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_CAST_in_typeCast4006 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast4008 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_typeCast4010 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_typeCast4032 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast4034 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_typeCast4036 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_typeCast4058 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast4060 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_typeCast4062 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_typeCast4084 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast4086 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_typeCast4088 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_typeCast4110 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast4112 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_typeCast4114 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_typeCast4136 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast4138 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_typeCast4140 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_typeCast4162 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast4164 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_typeCast4166 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _preIncrement_in_preIncDecExpression4201 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preDecrement_in_preIncDecExpression4210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_preIncDecExpression4219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PRE_DECREMENT_in_preDecrement4235 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_preDecrement4237 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_DECREMENT_in_preDecrement4274 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_preDecrement4276 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_DECREMENT_in_preDecrement4313 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_preDecrement4316 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_preDecrement4320 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_preDecrement4324 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_INCREMENT_in_preIncrement4375 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_preIncrement4377 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_INCREMENT_in_preIncrement4414 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_preIncrement4416 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_INCREMENT_in_preIncrement4453 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_preIncrement4456 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_preIncrement4460 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_preIncrement4464 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _postIncrement_in_postfixExpression4524 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postDecrement_in_postfixExpression4533 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subscript_in_postfixExpression4542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodCall_in_postfixExpression4551 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primary_in_postfixExpression4561 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _METHOD_CALL_in_methodCall4579 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_methodCall4583 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ELIST_in_methodCall4587 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_methodCall4591 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _ELIST_in_methodCall4597 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SUBSCRIPT_in_subscript4663 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_subscript4667 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_subscript4671 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_INCREMENT_in_postIncrement4718 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_postIncrement4720 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_INCREMENT_in_postIncrement4761 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_postIncrement4763 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_INCREMENT_in_postIncrement4804 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_postIncrement4807 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_postIncrement4811 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_postIncrement4815 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_DECREMENT_in_postDecrement4863 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_postDecrement4865 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_DECREMENT_in_postDecrement4906 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_postDecrement4908 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_DECREMENT_in_postDecrement4949 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_postDecrement4952 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_postDecrement4956 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_postDecrement4960 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STRING_LITERAL_in_primary5019 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_LITERAL_in_primary5033 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_LITERAL_in_primary5047 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary5064 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary5101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vecConst_in_primary5140 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vecLiteral_in_primary5149 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rotConst_in_primary5164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rotLiteral_in_primary5173 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _listLiteral_in_primary5182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_primary5191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VECTOR_LITERAL_in_vecConst5207 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FLOAT_LITERAL_in_vecConst5211 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _FLOAT_LITERAL_in_vecConst5215 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _FLOAT_LITERAL_in_vecConst5219 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VECTOR_LITERAL_in_vecLiteral5253 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_vecLiteral5257 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_vecLiteral5261 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_vecLiteral5265 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ROTATION_LITERAL_in_rotConst5299 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FLOAT_LITERAL_in_rotConst5303 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _FLOAT_LITERAL_in_rotConst5307 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _FLOAT_LITERAL_in_rotConst5311 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _FLOAT_LITERAL_in_rotConst5315 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ROTATION_LITERAL_in_rotLiteral5356 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_rotLiteral5360 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_rotLiteral5364 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_rotLiteral5368 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_rotLiteral5372 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LIST_LITERAL_in_listLiteral5412 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ELIST_in_listLiteral5416 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_listLiteral5420 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _ELIST_in_listLiteral5426 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _funcBlock_in_synpred22_Gen531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_DECL_in_synpred24_Gen565 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred24_Gen567 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_synpred24_Gen569 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _expression_in_synpred24_Gen573 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_DECL_in_synpred25_Gen607 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred25_Gen609 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_synpred25_Gen611 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_synpred41_Gen1093 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _methodCall_in_synpred41_Gen1095 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_synpred42_Gen1109 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _preIncrement_in_synpred42_Gen1111 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_synpred43_Gen1132 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _postIncrement_in_synpred43_Gen1134 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_synpred44_Gen1155 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _preDecrement_in_synpred44_Gen1157 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXPR_in_synpred45_Gen1178 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _postDecrement_in_synpred45_Gen1180 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_synpred94_Gen3828 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INTEGER_LITERAL_in_synpred94_Gen3830 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_synpred95_Gen3850 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FLOAT_LITERAL_in_synpred95_Gen3852 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_synpred96_Gen3872 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_synpred96_Gen3874 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_synpred97_Gen3896 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_synpred97_Gen3898 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_synpred98_Gen3920 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _unaryExpression_in_synpred98_Gen3922 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_synpred100_Gen4006 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred100_Gen4008 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_synpred100_Gen4010 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_synpred101_Gen4032 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred101_Gen4034 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_synpred101_Gen4036 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_synpred102_Gen4058 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred102_Gen4060 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_synpred102_Gen4062 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_synpred103_Gen4084 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred103_Gen4086 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_synpred103_Gen4088 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_synpred104_Gen4110 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred104_Gen4112 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_synpred104_Gen4114 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_CAST_in_synpred105_Gen4136 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_synpred105_Gen4138 = new BitSet(new ulong[]{0xFF3FB57E5BDFC118UL,0x30023FEAUL});
		public static readonly BitSet _unaryExpression_in_synpred105_Gen4140 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_DECREMENT_in_synpred108_Gen4235 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred108_Gen4237 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_DECREMENT_in_synpred109_Gen4274 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred109_Gen4276 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_INCREMENT_in_synpred110_Gen4375 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred110_Gen4377 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_INCREMENT_in_synpred111_Gen4414 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred111_Gen4416 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_INCREMENT_in_synpred118_Gen4718 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred118_Gen4720 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_INCREMENT_in_synpred119_Gen4761 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred119_Gen4763 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_DECREMENT_in_synpred120_Gen4863 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred120_Gen4865 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_DECREMENT_in_synpred121_Gen4906 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred121_Gen4908 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_synpred125_Gen5064 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred126_Gen5101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vecConst_in_synpred127_Gen5135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vecLiteral_in_synpred128_Gen5149 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rotConst_in_synpred129_Gen5159 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rotLiteral_in_synpred130_Gen5173 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  Halcyon.Phlox.Compiler 
