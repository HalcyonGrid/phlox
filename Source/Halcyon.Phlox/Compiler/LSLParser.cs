//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 LSL.g 2012-05-22 12:14:56

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Halcyon.Phlox.Compiler 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class LSLParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN_EQ", "COMMA", "COMMENT_BLOCK", "COMMENT_SINGLE", "DO_WHILE_STMT", "ELIST", "ELSE_PART", "ESC_SEQ", "EVENT_DEF", "EXPONENT", "EXPR", "FLOAT_LITERAL", "FOR_STMT", "FUNC_BLOCK", "GT", "ID", "IF_STMT", "INDEX", "INTEGER_LITERAL", "JUMP_STMT", "LABEL", "LIST_LITERAL", "LPAREN", "LT", "METHOD_CALL", "METHOD_DEF", "MINUS", "NEWLINE", "PARAM_DECL", "POST_DECREMENT", "POST_INCREMENT", "PRE_DECREMENT", "PRE_INCREMENT", "RETURN_STMT", "ROTATION_LITERAL", "RPAREN", "SEMI", "STATE_BLOCK", "STATE_CHG", "STATE_DEF", "STRING_LITERAL", "SUBSCRIPT", "TYPE", "TYPE_CAST", "UNARY_BIT_NOT", "UNARY_BOOL_NOT", "UNARY_MINUS", "VAR_DECL", "VECTOR_LITERAL", "WHILE_STMT", "WS", "'!'", "'!='", "'%'", "'%='", "'&&'", "'&'", "'*'", "'*='", "'+'", "'++'", "'+='", "'--'", "'-='", "'.'", "'/'", "'/='", "'<<'", "'<<='", "'<='", "'=='", "'>='", "'>>'", "'>>='", "'@'", "'['", "']'", "'^'", "'default'", "'do'", "'else'", "'for'", "'if'", "'jump'", "'return'", "'state'", "'while'", "'{'", "'|'", "'||'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int ASSIGN_EQ=4;
	public const int COMMA=5;
	public const int COMMENT_BLOCK=6;
	public const int COMMENT_SINGLE=7;
	public const int DO_WHILE_STMT=8;
	public const int ELIST=9;
	public const int ELSE_PART=10;
	public const int ESC_SEQ=11;
	public const int EVENT_DEF=12;
	public const int EXPONENT=13;
	public const int EXPR=14;
	public const int FLOAT_LITERAL=15;
	public const int FOR_STMT=16;
	public const int FUNC_BLOCK=17;
	public const int GT=18;
	public const int ID=19;
	public const int IF_STMT=20;
	public const int INDEX=21;
	public const int INTEGER_LITERAL=22;
	public const int JUMP_STMT=23;
	public const int LABEL=24;
	public const int LIST_LITERAL=25;
	public const int LPAREN=26;
	public const int LT=27;
	public const int METHOD_CALL=28;
	public const int METHOD_DEF=29;
	public const int MINUS=30;
	public const int NEWLINE=31;
	public const int PARAM_DECL=32;
	public const int POST_DECREMENT=33;
	public const int POST_INCREMENT=34;
	public const int PRE_DECREMENT=35;
	public const int PRE_INCREMENT=36;
	public const int RETURN_STMT=37;
	public const int ROTATION_LITERAL=38;
	public const int RPAREN=39;
	public const int SEMI=40;
	public const int STATE_BLOCK=41;
	public const int STATE_CHG=42;
	public const int STATE_DEF=43;
	public const int STRING_LITERAL=44;
	public const int SUBSCRIPT=45;
	public const int TYPE=46;
	public const int TYPE_CAST=47;
	public const int UNARY_BIT_NOT=48;
	public const int UNARY_BOOL_NOT=49;
	public const int UNARY_MINUS=50;
	public const int VAR_DECL=51;
	public const int VECTOR_LITERAL=52;
	public const int WHILE_STMT=53;
	public const int WS=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;

	// delegates
	// delegators

	public LSLParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public LSLParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[140+1];

		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);

		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();


		OnCreated();
	}
		
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return LSLParser.tokenNames; } }
	public override string GrammarFileName { get { return "LSL.g"; } }


		int ErrorCount = 0;
		bool GTDisabled = false;

		public override void Recover(IIntStream input, RecognitionException re)
	    {
			if (++ErrorCount == 10) throw new Halcyon.Phlox.Types.TooManyErrorsException("Too many errors", re);
	        base.Recover(input, re);
	    }

		private bool IsNotVector() 
	    { 
	        IToken tok1 = input.LT(1);
	        IToken tok2 = input.LT(2);

	        //"standard vector" case
	        if (tok1 != null && tok1.Type == LT)
	        {
	            return false;
	        }

	        //"negative vector" case
	        if (tok2 != null && tok2.Type == LT && tok1.Type == MINUS)
	        {
	            return false;
	        }

	        return true; 
	    }

		private bool GTNotDisabled()
		{
			return !GTDisabled;
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	public sealed partial class prog_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public prog_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_prog();
	partial void LeaveRule_prog();

	// $ANTLR start "prog"
	// LSL.g:95:8: public prog : ( globalStmt )+ EOF ;
	[GrammarRule("prog")]
	public LSLParser.prog_return prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
		LSLParser.prog_return retval = new LSLParser.prog_return(this);
		retval.Start = (IToken)input.LT(1);
		int prog_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken EOF2 = default(IToken);
		LSLParser.globalStmt_return globalStmt1 = default(LSLParser.globalStmt_return);

		LSLAst EOF2_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(95, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }
			// LSL.g:96:3: ( ( globalStmt )+ EOF )
			DebugEnterAlt(1);
			// LSL.g:96:3: ( globalStmt )+ EOF
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(96, 3);
			// LSL.g:96:3: ( globalStmt )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>=COMMENT_BLOCK && LA1_0<=COMMENT_SINGLE)||LA1_0==ID||LA1_0==NEWLINE||LA1_0==TYPE||LA1_0==82||LA1_0==89))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:96:3: globalStmt
					{
					DebugLocation(96, 3);
					PushFollow(Follow._globalStmt_in_prog283);
					globalStmt1=globalStmt();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, globalStmt1.Tree);

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(96, 15);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_prog286); if (state.failed) return retval;
			if (state.backtracking == 0) {
			EOF2_tree = (LSLAst)adaptor.Create(EOF2);
			adaptor.AddChild(root_0, EOF2_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
			if (state.backtracking > 0) { Memoize(input, 1, prog_StartIndex); }
		}
		DebugLocation(97, 1);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return retval;

	}
	// $ANTLR end "prog"

	private sealed partial class globalStmt_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public globalStmt_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_globalStmt();
	partial void LeaveRule_globalStmt();

	// $ANTLR start "globalStmt"
	// LSL.g:99:1: globalStmt : ( varDecl | NEWLINE | COMMENT_SINGLE | COMMENT_BLOCK | funcDef | stateDef );
	[GrammarRule("globalStmt")]
	private LSLParser.globalStmt_return globalStmt()
	{
		EnterRule_globalStmt();
		EnterRule("globalStmt", 2);
		TraceIn("globalStmt", 2);
		LSLParser.globalStmt_return retval = new LSLParser.globalStmt_return(this);
		retval.Start = (IToken)input.LT(1);
		int globalStmt_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken NEWLINE4 = default(IToken);
		IToken COMMENT_SINGLE5 = default(IToken);
		IToken COMMENT_BLOCK6 = default(IToken);
		LSLParser.varDecl_return varDecl3 = default(LSLParser.varDecl_return);
		LSLParser.funcDef_return funcDef7 = default(LSLParser.funcDef_return);
		LSLParser.stateDef_return stateDef8 = default(LSLParser.stateDef_return);

		LSLAst NEWLINE4_tree = default(LSLAst);
		LSLAst COMMENT_SINGLE5_tree = default(LSLAst);
		LSLAst COMMENT_BLOCK6_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "globalStmt");
		DebugLocation(99, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }
			// LSL.g:100:2: ( varDecl | NEWLINE | COMMENT_SINGLE | COMMENT_BLOCK | funcDef | stateDef )
			int alt2=6;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case TYPE:
				{
				int LA2_1 = input.LA(2);

				if ((LA2_1==ID))
				{
					int LA2_7 = input.LA(3);

					if ((LA2_7==LPAREN))
					{
						alt2 = 5;
					}
					else if ((LA2_7==ASSIGN_EQ||LA2_7==SEMI))
					{
						alt2 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 2, 7, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NEWLINE:
				{
				alt2 = 2;
				}
				break;
			case COMMENT_SINGLE:
				{
				alt2 = 3;
				}
				break;
			case COMMENT_BLOCK:
				{
				alt2 = 4;
				}
				break;
			case ID:
				{
				alt2 = 5;
				}
				break;
			case 82:
			case 89:
				{
				alt2 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:100:4: varDecl
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(100, 4);
				PushFollow(Follow._varDecl_in_globalStmt299);
				varDecl3=varDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varDecl3.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:101:4: NEWLINE
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(101, 11);
				NEWLINE4=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_globalStmt304); if (state.failed) return retval;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// LSL.g:102:4: COMMENT_SINGLE
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(102, 18);
				COMMENT_SINGLE5=(IToken)Match(input,COMMENT_SINGLE,Follow._COMMENT_SINGLE_in_globalStmt310); if (state.failed) return retval;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// LSL.g:103:5: COMMENT_BLOCK
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(103, 18);
				COMMENT_BLOCK6=(IToken)Match(input,COMMENT_BLOCK,Follow._COMMENT_BLOCK_in_globalStmt317); if (state.failed) return retval;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// LSL.g:104:4: funcDef
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(104, 4);
				PushFollow(Follow._funcDef_in_globalStmt323);
				funcDef7=funcDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcDef7.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// LSL.g:105:4: stateDef
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(105, 4);
				PushFollow(Follow._stateDef_in_globalStmt328);
				stateDef8=stateDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, stateDef8.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("globalStmt", 2);
			LeaveRule("globalStmt", 2);
			LeaveRule_globalStmt();
			if (state.backtracking > 0) { Memoize(input, 2, globalStmt_StartIndex); }
		}
		DebugLocation(106, 1);
		} finally { DebugExitRule(GrammarFileName, "globalStmt"); }
		return retval;

	}
	// $ANTLR end "globalStmt"

	private sealed partial class stateDef_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public stateDef_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_stateDef();
	partial void LeaveRule_stateDef();

	// $ANTLR start "stateDef"
	// LSL.g:108:1: stateDef : ( 'state' ID stateBlock -> ^( STATE_DEF[$ID] ID stateBlock ) |d= 'default' stateBlock -> ^( STATE_DEF[$d] $d stateBlock ) );
	[GrammarRule("stateDef")]
	private LSLParser.stateDef_return stateDef()
	{
		EnterRule_stateDef();
		EnterRule("stateDef", 3);
		TraceIn("stateDef", 3);
		LSLParser.stateDef_return retval = new LSLParser.stateDef_return(this);
		retval.Start = (IToken)input.LT(1);
		int stateDef_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken d = default(IToken);
		IToken string_literal9 = default(IToken);
		IToken ID10 = default(IToken);
		LSLParser.stateBlock_return stateBlock11 = default(LSLParser.stateBlock_return);
		LSLParser.stateBlock_return stateBlock12 = default(LSLParser.stateBlock_return);

		LSLAst d_tree = default(LSLAst);
		LSLAst string_literal9_tree = default(LSLAst);
		LSLAst ID10_tree = default(LSLAst);
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleSubtreeStream stream_stateBlock=new RewriteRuleSubtreeStream(adaptor,"rule stateBlock");
		try { DebugEnterRule(GrammarFileName, "stateDef");
		DebugLocation(108, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }
			// LSL.g:109:2: ( 'state' ID stateBlock -> ^( STATE_DEF[$ID] ID stateBlock ) |d= 'default' stateBlock -> ^( STATE_DEF[$d] $d stateBlock ) )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==89))
			{
				alt3 = 1;
			}
			else if ((LA3_0==82))
			{
				alt3 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:109:4: 'state' ID stateBlock
				{
				DebugLocation(109, 4);
				string_literal9=(IToken)Match(input,89,Follow._89_in_stateDef339); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_89.Add(string_literal9);

				DebugLocation(109, 12);
				ID10=(IToken)Match(input,ID,Follow._ID_in_stateDef341); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID10);

				DebugLocation(109, 15);
				PushFollow(Follow._stateBlock_in_stateDef343);
				stateBlock11=stateBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_stateBlock.Add(stateBlock11.Tree);


				{
				// AST REWRITE
				// elements: ID, stateBlock
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 109:26: -> ^( STATE_DEF[$ID] ID stateBlock )
				{
					DebugLocation(109, 29);
					// LSL.g:109:29: ^( STATE_DEF[$ID] ID stateBlock )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(109, 31);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(STATE_DEF, ID10), root_1);

					DebugLocation(109, 46);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(109, 49);
					adaptor.AddChild(root_1, stream_stateBlock.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:110:4: d= 'default' stateBlock
				{
				DebugLocation(110, 5);
				d=(IToken)Match(input,82,Follow._82_in_stateDef361); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_82.Add(d);

				DebugLocation(110, 16);
				PushFollow(Follow._stateBlock_in_stateDef363);
				stateBlock12=stateBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_stateBlock.Add(stateBlock12.Tree);
				DebugLocation(110, 27);
				if (state.backtracking == 0)
				{
					d.Type = ID;
				}


				{
				// AST REWRITE
				// elements: d, stateBlock
				// token labels: d
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_d=new RewriteRuleITokenStream(adaptor,"token d",d);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 110:43: -> ^( STATE_DEF[$d] $d stateBlock )
				{
					DebugLocation(110, 46);
					// LSL.g:110:46: ^( STATE_DEF[$d] $d stateBlock )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(110, 48);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(STATE_DEF, d), root_1);

					DebugLocation(110, 63);
					adaptor.AddChild(root_1, stream_d.NextNode());
					DebugLocation(110, 65);
					adaptor.AddChild(root_1, stream_stateBlock.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stateDef", 3);
			LeaveRule("stateDef", 3);
			LeaveRule_stateDef();
			if (state.backtracking > 0) { Memoize(input, 3, stateDef_StartIndex); }
		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "stateDef"); }
		return retval;

	}
	// $ANTLR end "stateDef"

	private sealed partial class stateBlock_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public stateBlock_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_stateBlock();
	partial void LeaveRule_stateBlock();

	// $ANTLR start "stateBlock"
	// LSL.g:113:1: stateBlock : '{' ( stateBlockContent )* '}' -> ^( STATE_BLOCK ( stateBlockContent )* ) ;
	[GrammarRule("stateBlock")]
	private LSLParser.stateBlock_return stateBlock()
	{
		EnterRule_stateBlock();
		EnterRule("stateBlock", 4);
		TraceIn("stateBlock", 4);
		LSLParser.stateBlock_return retval = new LSLParser.stateBlock_return(this);
		retval.Start = (IToken)input.LT(1);
		int stateBlock_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal13 = default(IToken);
		IToken char_literal15 = default(IToken);
		LSLParser.stateBlockContent_return stateBlockContent14 = default(LSLParser.stateBlockContent_return);

		LSLAst char_literal13_tree = default(LSLAst);
		LSLAst char_literal15_tree = default(LSLAst);
		RewriteRuleITokenStream stream_91=new RewriteRuleITokenStream(adaptor,"token 91");
		RewriteRuleITokenStream stream_94=new RewriteRuleITokenStream(adaptor,"token 94");
		RewriteRuleSubtreeStream stream_stateBlockContent=new RewriteRuleSubtreeStream(adaptor,"rule stateBlockContent");
		try { DebugEnterRule(GrammarFileName, "stateBlock");
		DebugLocation(113, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }
			// LSL.g:114:2: ( '{' ( stateBlockContent )* '}' -> ^( STATE_BLOCK ( stateBlockContent )* ) )
			DebugEnterAlt(1);
			// LSL.g:114:4: '{' ( stateBlockContent )* '}'
			{
			DebugLocation(114, 4);
			char_literal13=(IToken)Match(input,91,Follow._91_in_stateBlock389); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_91.Add(char_literal13);

			DebugLocation(114, 8);
			// LSL.g:114:8: ( stateBlockContent )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if (((LA4_0>=COMMENT_BLOCK && LA4_0<=COMMENT_SINGLE)||LA4_0==ID||LA4_0==NEWLINE))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:114:8: stateBlockContent
					{
					DebugLocation(114, 8);
					PushFollow(Follow._stateBlockContent_in_stateBlock391);
					stateBlockContent14=stateBlockContent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_stateBlockContent.Add(stateBlockContent14.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(114, 27);
			char_literal15=(IToken)Match(input,94,Follow._94_in_stateBlock394); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_94.Add(char_literal15);



			{
			// AST REWRITE
			// elements: stateBlockContent
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 114:31: -> ^( STATE_BLOCK ( stateBlockContent )* )
			{
				DebugLocation(114, 34);
				// LSL.g:114:34: ^( STATE_BLOCK ( stateBlockContent )* )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(114, 36);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(STATE_BLOCK, "STATE_BLOCK"), root_1);

				DebugLocation(114, 48);
				// LSL.g:114:48: ( stateBlockContent )*
				while ( stream_stateBlockContent.HasNext )
				{
					DebugLocation(114, 48);
					adaptor.AddChild(root_1, stream_stateBlockContent.NextTree());

				}
				stream_stateBlockContent.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stateBlock", 4);
			LeaveRule("stateBlock", 4);
			LeaveRule_stateBlock();
			if (state.backtracking > 0) { Memoize(input, 4, stateBlock_StartIndex); }
		}
		DebugLocation(115, 1);
		} finally { DebugExitRule(GrammarFileName, "stateBlock"); }
		return retval;

	}
	// $ANTLR end "stateBlock"

	private sealed partial class stateBlockContent_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public stateBlockContent_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_stateBlockContent();
	partial void LeaveRule_stateBlockContent();

	// $ANTLR start "stateBlockContent"
	// LSL.g:117:1: stateBlockContent : ( NEWLINE | COMMENT_SINGLE | COMMENT_BLOCK | eventDef );
	[GrammarRule("stateBlockContent")]
	private LSLParser.stateBlockContent_return stateBlockContent()
	{
		EnterRule_stateBlockContent();
		EnterRule("stateBlockContent", 5);
		TraceIn("stateBlockContent", 5);
		LSLParser.stateBlockContent_return retval = new LSLParser.stateBlockContent_return(this);
		retval.Start = (IToken)input.LT(1);
		int stateBlockContent_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken NEWLINE16 = default(IToken);
		IToken COMMENT_SINGLE17 = default(IToken);
		IToken COMMENT_BLOCK18 = default(IToken);
		LSLParser.eventDef_return eventDef19 = default(LSLParser.eventDef_return);

		LSLAst NEWLINE16_tree = default(LSLAst);
		LSLAst COMMENT_SINGLE17_tree = default(LSLAst);
		LSLAst COMMENT_BLOCK18_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "stateBlockContent");
		DebugLocation(117, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }
			// LSL.g:118:2: ( NEWLINE | COMMENT_SINGLE | COMMENT_BLOCK | eventDef )
			int alt5=4;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case NEWLINE:
				{
				alt5 = 1;
				}
				break;
			case COMMENT_SINGLE:
				{
				alt5 = 2;
				}
				break;
			case COMMENT_BLOCK:
				{
				alt5 = 3;
				}
				break;
			case ID:
				{
				alt5 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:119:3: NEWLINE
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(119, 10);
				NEWLINE16=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_stateBlockContent418); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:120:4: COMMENT_SINGLE
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(120, 18);
				COMMENT_SINGLE17=(IToken)Match(input,COMMENT_SINGLE,Follow._COMMENT_SINGLE_in_stateBlockContent424); if (state.failed) return retval;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// LSL.g:121:5: COMMENT_BLOCK
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(121, 18);
				COMMENT_BLOCK18=(IToken)Match(input,COMMENT_BLOCK,Follow._COMMENT_BLOCK_in_stateBlockContent431); if (state.failed) return retval;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// LSL.g:122:4: eventDef
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(122, 4);
				PushFollow(Follow._eventDef_in_stateBlockContent437);
				eventDef19=eventDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, eventDef19.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stateBlockContent", 5);
			LeaveRule("stateBlockContent", 5);
			LeaveRule_stateBlockContent();
			if (state.backtracking > 0) { Memoize(input, 5, stateBlockContent_StartIndex); }
		}
		DebugLocation(123, 1);
		} finally { DebugExitRule(GrammarFileName, "stateBlockContent"); }
		return retval;

	}
	// $ANTLR end "stateBlockContent"

	private sealed partial class funcDef_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public funcDef_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_funcDef();
	partial void LeaveRule_funcDef();

	// $ANTLR start "funcDef"
	// LSL.g:125:1: funcDef : ( TYPE )? ID LPAREN ( paramList )? RPAREN funcBlock -> ^( METHOD_DEF ( TYPE )? ID ( paramList )? funcBlock ) ;
	[GrammarRule("funcDef")]
	private LSLParser.funcDef_return funcDef()
	{
		EnterRule_funcDef();
		EnterRule("funcDef", 6);
		TraceIn("funcDef", 6);
		LSLParser.funcDef_return retval = new LSLParser.funcDef_return(this);
		retval.Start = (IToken)input.LT(1);
		int funcDef_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken TYPE20 = default(IToken);
		IToken ID21 = default(IToken);
		IToken LPAREN22 = default(IToken);
		IToken RPAREN24 = default(IToken);
		LSLParser.paramList_return paramList23 = default(LSLParser.paramList_return);
		LSLParser.funcBlock_return funcBlock25 = default(LSLParser.funcBlock_return);

		LSLAst TYPE20_tree = default(LSLAst);
		LSLAst ID21_tree = default(LSLAst);
		LSLAst LPAREN22_tree = default(LSLAst);
		LSLAst RPAREN24_tree = default(LSLAst);
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_paramList=new RewriteRuleSubtreeStream(adaptor,"rule paramList");
		RewriteRuleSubtreeStream stream_funcBlock=new RewriteRuleSubtreeStream(adaptor,"rule funcBlock");
		try { DebugEnterRule(GrammarFileName, "funcDef");
		DebugLocation(125, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }
			// LSL.g:125:8: ( ( TYPE )? ID LPAREN ( paramList )? RPAREN funcBlock -> ^( METHOD_DEF ( TYPE )? ID ( paramList )? funcBlock ) )
			DebugEnterAlt(1);
			// LSL.g:125:10: ( TYPE )? ID LPAREN ( paramList )? RPAREN funcBlock
			{
			DebugLocation(125, 10);
			// LSL.g:125:10: ( TYPE )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==TYPE))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:125:11: TYPE
				{
				DebugLocation(125, 11);
				TYPE20=(IToken)Match(input,TYPE,Follow._TYPE_in_funcDef447); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TYPE.Add(TYPE20);


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(125, 18);
			ID21=(IToken)Match(input,ID,Follow._ID_in_funcDef451); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID21);

			DebugLocation(125, 21);
			LPAREN22=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcDef453); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN22);

			DebugLocation(125, 28);
			// LSL.g:125:28: ( paramList )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==TYPE))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:125:29: paramList
				{
				DebugLocation(125, 29);
				PushFollow(Follow._paramList_in_funcDef456);
				paramList23=paramList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_paramList.Add(paramList23.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(125, 41);
			RPAREN24=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcDef460); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN24);

			DebugLocation(125, 48);
			PushFollow(Follow._funcBlock_in_funcDef462);
			funcBlock25=funcBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_funcBlock.Add(funcBlock25.Tree);


			{
			// AST REWRITE
			// elements: TYPE, ID, paramList, funcBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 126:3: -> ^( METHOD_DEF ( TYPE )? ID ( paramList )? funcBlock )
			{
				DebugLocation(126, 6);
				// LSL.g:126:6: ^( METHOD_DEF ( TYPE )? ID ( paramList )? funcBlock )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(126, 8);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);

				DebugLocation(126, 19);
				// LSL.g:126:19: ( TYPE )?
				if (stream_TYPE.HasNext)
				{
					DebugLocation(126, 19);
					adaptor.AddChild(root_1, stream_TYPE.NextNode());

				}
				stream_TYPE.Reset();
				DebugLocation(126, 25);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(126, 28);
				// LSL.g:126:28: ( paramList )?
				if (stream_paramList.HasNext)
				{
					DebugLocation(126, 28);
					adaptor.AddChild(root_1, stream_paramList.NextTree());

				}
				stream_paramList.Reset();
				DebugLocation(126, 39);
				adaptor.AddChild(root_1, stream_funcBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcDef", 6);
			LeaveRule("funcDef", 6);
			LeaveRule_funcDef();
			if (state.backtracking > 0) { Memoize(input, 6, funcDef_StartIndex); }
		}
		DebugLocation(127, 1);
		} finally { DebugExitRule(GrammarFileName, "funcDef"); }
		return retval;

	}
	// $ANTLR end "funcDef"

	private sealed partial class funcBlock_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public funcBlock_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_funcBlock();
	partial void LeaveRule_funcBlock();

	// $ANTLR start "funcBlock"
	// LSL.g:129:1: funcBlock : '{' ( funcBlockContent )* '}' -> ^( FUNC_BLOCK ( funcBlockContent )* ) ;
	[GrammarRule("funcBlock")]
	private LSLParser.funcBlock_return funcBlock()
	{
		EnterRule_funcBlock();
		EnterRule("funcBlock", 7);
		TraceIn("funcBlock", 7);
		LSLParser.funcBlock_return retval = new LSLParser.funcBlock_return(this);
		retval.Start = (IToken)input.LT(1);
		int funcBlock_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal26 = default(IToken);
		IToken char_literal28 = default(IToken);
		LSLParser.funcBlockContent_return funcBlockContent27 = default(LSLParser.funcBlockContent_return);

		LSLAst char_literal26_tree = default(LSLAst);
		LSLAst char_literal28_tree = default(LSLAst);
		RewriteRuleITokenStream stream_91=new RewriteRuleITokenStream(adaptor,"token 91");
		RewriteRuleITokenStream stream_94=new RewriteRuleITokenStream(adaptor,"token 94");
		RewriteRuleSubtreeStream stream_funcBlockContent=new RewriteRuleSubtreeStream(adaptor,"rule funcBlockContent");
		try { DebugEnterRule(GrammarFileName, "funcBlock");
		DebugLocation(129, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }
			// LSL.g:130:2: ( '{' ( funcBlockContent )* '}' -> ^( FUNC_BLOCK ( funcBlockContent )* ) )
			DebugEnterAlt(1);
			// LSL.g:130:4: '{' ( funcBlockContent )* '}'
			{
			DebugLocation(130, 4);
			char_literal26=(IToken)Match(input,91,Follow._91_in_funcBlock491); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_91.Add(char_literal26);

			DebugLocation(130, 8);
			// LSL.g:130:8: ( funcBlockContent )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if (((LA8_0>=COMMENT_BLOCK && LA8_0<=COMMENT_SINGLE)||LA8_0==ID||LA8_0==LPAREN||LA8_0==NEWLINE||LA8_0==SEMI||LA8_0==TYPE||LA8_0==64||LA8_0==66||LA8_0==78||LA8_0==83||(LA8_0>=85 && LA8_0<=91)))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:130:8: funcBlockContent
					{
					DebugLocation(130, 8);
					PushFollow(Follow._funcBlockContent_in_funcBlock493);
					funcBlockContent27=funcBlockContent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_funcBlockContent.Add(funcBlockContent27.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(130, 26);
			char_literal28=(IToken)Match(input,94,Follow._94_in_funcBlock496); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_94.Add(char_literal28);



			{
			// AST REWRITE
			// elements: funcBlockContent
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 130:30: -> ^( FUNC_BLOCK ( funcBlockContent )* )
			{
				DebugLocation(130, 33);
				// LSL.g:130:33: ^( FUNC_BLOCK ( funcBlockContent )* )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(130, 35);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(FUNC_BLOCK, "FUNC_BLOCK"), root_1);

				DebugLocation(130, 46);
				// LSL.g:130:46: ( funcBlockContent )*
				while ( stream_funcBlockContent.HasNext )
				{
					DebugLocation(130, 46);
					adaptor.AddChild(root_1, stream_funcBlockContent.NextTree());

				}
				stream_funcBlockContent.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcBlock", 7);
			LeaveRule("funcBlock", 7);
			LeaveRule_funcBlock();
			if (state.backtracking > 0) { Memoize(input, 7, funcBlock_StartIndex); }
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "funcBlock"); }
		return retval;

	}
	// $ANTLR end "funcBlock"

	private sealed partial class statement_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public statement_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// LSL.g:133:1: statement : ( funcBlock | funcBlockContent );
	[GrammarRule("statement")]
	private LSLParser.statement_return statement()
	{
		EnterRule_statement();
		EnterRule("statement", 8);
		TraceIn("statement", 8);
		LSLParser.statement_return retval = new LSLParser.statement_return(this);
		retval.Start = (IToken)input.LT(1);
		int statement_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		LSLParser.funcBlock_return funcBlock29 = default(LSLParser.funcBlock_return);
		LSLParser.funcBlockContent_return funcBlockContent30 = default(LSLParser.funcBlockContent_return);


		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(133, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }
			// LSL.g:134:2: ( funcBlock | funcBlockContent )
			int alt9=2;
			try { DebugEnterDecision(9, false);
			try
			{
				alt9 = dfa9.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:134:4: funcBlock
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(134, 4);
				PushFollow(Follow._funcBlock_in_statement516);
				funcBlock29=funcBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcBlock29.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:135:4: funcBlockContent
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(135, 4);
				PushFollow(Follow._funcBlockContent_in_statement521);
				funcBlockContent30=funcBlockContent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcBlockContent30.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 8);
			LeaveRule("statement", 8);
			LeaveRule_statement();
			if (state.backtracking > 0) { Memoize(input, 8, statement_StartIndex); }
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	private sealed partial class exprStatement_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public exprStatement_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_exprStatement();
	partial void LeaveRule_exprStatement();

	// $ANTLR start "exprStatement"
	// LSL.g:138:1: exprStatement : ( SEMI | expression SEMI );
	[GrammarRule("exprStatement")]
	private LSLParser.exprStatement_return exprStatement()
	{
		EnterRule_exprStatement();
		EnterRule("exprStatement", 9);
		TraceIn("exprStatement", 9);
		LSLParser.exprStatement_return retval = new LSLParser.exprStatement_return(this);
		retval.Start = (IToken)input.LT(1);
		int exprStatement_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken SEMI31 = default(IToken);
		IToken SEMI33 = default(IToken);
		LSLParser.expression_return expression32 = default(LSLParser.expression_return);

		LSLAst SEMI31_tree = default(LSLAst);
		LSLAst SEMI33_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "exprStatement");
		DebugLocation(138, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }
			// LSL.g:139:2: ( SEMI | expression SEMI )
			int alt10=2;
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==SEMI))
			{
				alt10 = 1;
			}
			else if ((LA10_0==FLOAT_LITERAL||LA10_0==ID||LA10_0==INTEGER_LITERAL||(LA10_0>=LPAREN && LA10_0<=LT)||LA10_0==MINUS||LA10_0==STRING_LITERAL||LA10_0==55||LA10_0==64||LA10_0==66||LA10_0==79||LA10_0==95))
			{
				alt10 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:139:4: SEMI
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(139, 4);
				SEMI31=(IToken)Match(input,SEMI,Follow._SEMI_in_exprStatement532); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SEMI31_tree = (LSLAst)adaptor.Create(SEMI31);
				adaptor.AddChild(root_0, SEMI31_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:140:4: expression SEMI
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(140, 4);
				PushFollow(Follow._expression_in_exprStatement537);
				expression32=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression32.Tree);
				DebugLocation(140, 19);
				SEMI33=(IToken)Match(input,SEMI,Follow._SEMI_in_exprStatement539); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprStatement", 9);
			LeaveRule("exprStatement", 9);
			LeaveRule_exprStatement();
			if (state.backtracking > 0) { Memoize(input, 9, exprStatement_StartIndex); }
		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "exprStatement"); }
		return retval;

	}
	// $ANTLR end "exprStatement"

	private sealed partial class label_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public label_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_label();
	partial void LeaveRule_label();

	// $ANTLR start "label"
	// LSL.g:143:1: label : '@' ID -> ^( LABEL ID ) ;
	[GrammarRule("label")]
	private LSLParser.label_return label()
	{
		EnterRule_label();
		EnterRule("label", 10);
		TraceIn("label", 10);
		LSLParser.label_return retval = new LSLParser.label_return(this);
		retval.Start = (IToken)input.LT(1);
		int label_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal34 = default(IToken);
		IToken ID35 = default(IToken);

		LSLAst char_literal34_tree = default(LSLAst);
		LSLAst ID35_tree = default(LSLAst);
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "label");
		DebugLocation(143, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }
			// LSL.g:143:7: ( '@' ID -> ^( LABEL ID ) )
			DebugEnterAlt(1);
			// LSL.g:144:2: '@' ID
			{
			DebugLocation(144, 2);
			char_literal34=(IToken)Match(input,78,Follow._78_in_label553); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_78.Add(char_literal34);

			DebugLocation(144, 6);
			ID35=(IToken)Match(input,ID,Follow._ID_in_label555); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID35);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 144:9: -> ^( LABEL ID )
			{
				DebugLocation(144, 12);
				// LSL.g:144:12: ^( LABEL ID )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(144, 14);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(LABEL, "LABEL"), root_1);

				DebugLocation(144, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("label", 10);
			LeaveRule("label", 10);
			LeaveRule_label();
			if (state.backtracking > 0) { Memoize(input, 10, label_StartIndex); }
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "label"); }
		return retval;

	}
	// $ANTLR end "label"

	private sealed partial class funcBlockContent_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public funcBlockContent_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_funcBlockContent();
	partial void LeaveRule_funcBlockContent();

	// $ANTLR start "funcBlockContent"
	// LSL.g:147:1: funcBlockContent : ( SEMI | ( LPAREN )? lhs ( '.' subscript= ID )? (t= '=' |t= '+=' |t= '-=' |t= '*=' |t= '/=' |t= '%=' |t= '<<=' |t= '>>=' ) expression ( RPAREN )? SEMI -> {$subscript!=null}? ^( $t ^( SUBSCRIPT lhs $subscript) expression ) -> ^( $t lhs expression ) |i= 'if' '(' expression ')' s= statement ( 'else' e= statement )? -> ^( IF_STMT[$i] expression $s ^( ELSE_PART ( $e)? ) ) |w= 'while' '(' expression ')' statement -> ^( WHILE_STMT[$w] expression statement ) |f= 'for' '(' init= exprStatement cond= exprStatement (loop= expression )? ')' statement -> ^( FOR_STMT[$f] statement $init $cond ( $loop)? ) |d= 'do' statement 'while' '(' expression ')' SEMI -> ^( DO_WHILE_STMT[$d] expression statement ) | varDecl | funcCall -> ^( EXPR funcCall ) | '++' ID ( '.' subscript= ID )? SEMI -> {$subscript == null}? ^( EXPR ^( PRE_INCREMENT ID ) ) -> ^( EXPR ^( PRE_INCREMENT ^( SUBSCRIPT ID $subscript) ) ) | '--' ID ( '.' subscript= ID )? SEMI -> {$subscript == null}? ^( EXPR ^( PRE_DECREMENT ID ) ) -> ^( EXPR ^( PRE_DECREMENT ^( SUBSCRIPT ID $subscript) ) ) | ID ( '.' subscript= ID )? '++' SEMI -> {$subscript == null}? ^( EXPR ^( POST_INCREMENT ID ) ) -> ^( EXPR ^( POST_INCREMENT ^( SUBSCRIPT ID $subscript) ) ) | ID ( '.' subscript= ID )? '--' SEMI -> {$subscript == null}? ^( EXPR ^( POST_DECREMENT ID ) ) -> ^( EXPR ^( POST_DECREMENT ^( SUBSCRIPT ID $subscript) ) ) |r= 'return' ( expression )? SEMI -> ^( RETURN_STMT[$r] ( expression )? ) |stateNode= 'state' ( ID | 'default' ) SEMI -> ^( STATE_CHG[$stateNode] ( ID )? ) | label SEMI | 'jump' ID SEMI -> ^( JUMP_STMT ID ) | funcBlock | NEWLINE | COMMENT_SINGLE | COMMENT_BLOCK );
	[GrammarRule("funcBlockContent")]
	private LSLParser.funcBlockContent_return funcBlockContent()
	{
		EnterRule_funcBlockContent();
		EnterRule("funcBlockContent", 11);
		TraceIn("funcBlockContent", 11);
		LSLParser.funcBlockContent_return retval = new LSLParser.funcBlockContent_return(this);
		retval.Start = (IToken)input.LT(1);
		int funcBlockContent_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken subscript = default(IToken);
		IToken t = default(IToken);
		IToken i = default(IToken);
		IToken w = default(IToken);
		IToken f = default(IToken);
		IToken d = default(IToken);
		IToken r = default(IToken);
		IToken stateNode = default(IToken);
		IToken SEMI36 = default(IToken);
		IToken LPAREN37 = default(IToken);
		IToken char_literal39 = default(IToken);
		IToken RPAREN41 = default(IToken);
		IToken SEMI42 = default(IToken);
		IToken char_literal43 = default(IToken);
		IToken char_literal45 = default(IToken);
		IToken string_literal46 = default(IToken);
		IToken char_literal47 = default(IToken);
		IToken char_literal49 = default(IToken);
		IToken char_literal51 = default(IToken);
		IToken char_literal52 = default(IToken);
		IToken string_literal55 = default(IToken);
		IToken char_literal56 = default(IToken);
		IToken char_literal58 = default(IToken);
		IToken SEMI59 = default(IToken);
		IToken string_literal62 = default(IToken);
		IToken ID63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken SEMI65 = default(IToken);
		IToken string_literal66 = default(IToken);
		IToken ID67 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken SEMI69 = default(IToken);
		IToken ID70 = default(IToken);
		IToken char_literal71 = default(IToken);
		IToken string_literal72 = default(IToken);
		IToken SEMI73 = default(IToken);
		IToken ID74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken string_literal76 = default(IToken);
		IToken SEMI77 = default(IToken);
		IToken SEMI79 = default(IToken);
		IToken ID80 = default(IToken);
		IToken string_literal81 = default(IToken);
		IToken SEMI82 = default(IToken);
		IToken SEMI84 = default(IToken);
		IToken string_literal85 = default(IToken);
		IToken ID86 = default(IToken);
		IToken SEMI87 = default(IToken);
		IToken NEWLINE89 = default(IToken);
		IToken COMMENT_SINGLE90 = default(IToken);
		IToken COMMENT_BLOCK91 = default(IToken);
		LSLParser.statement_return s = default(LSLParser.statement_return);
		LSLParser.statement_return e = default(LSLParser.statement_return);
		LSLParser.exprStatement_return init = default(LSLParser.exprStatement_return);
		LSLParser.exprStatement_return cond = default(LSLParser.exprStatement_return);
		LSLParser.expression_return loop = default(LSLParser.expression_return);
		LSLParser.lhs_return lhs38 = default(LSLParser.lhs_return);
		LSLParser.expression_return expression40 = default(LSLParser.expression_return);
		LSLParser.expression_return expression44 = default(LSLParser.expression_return);
		LSLParser.expression_return expression48 = default(LSLParser.expression_return);
		LSLParser.statement_return statement50 = default(LSLParser.statement_return);
		LSLParser.statement_return statement53 = default(LSLParser.statement_return);
		LSLParser.statement_return statement54 = default(LSLParser.statement_return);
		LSLParser.expression_return expression57 = default(LSLParser.expression_return);
		LSLParser.varDecl_return varDecl60 = default(LSLParser.varDecl_return);
		LSLParser.funcCall_return funcCall61 = default(LSLParser.funcCall_return);
		LSLParser.expression_return expression78 = default(LSLParser.expression_return);
		LSLParser.label_return label83 = default(LSLParser.label_return);
		LSLParser.funcBlock_return funcBlock88 = default(LSLParser.funcBlock_return);

		LSLAst subscript_tree = default(LSLAst);
		LSLAst t_tree = default(LSLAst);
		LSLAst i_tree = default(LSLAst);
		LSLAst w_tree = default(LSLAst);
		LSLAst f_tree = default(LSLAst);
		LSLAst d_tree = default(LSLAst);
		LSLAst r_tree = default(LSLAst);
		LSLAst stateNode_tree = default(LSLAst);
		LSLAst SEMI36_tree = default(LSLAst);
		LSLAst LPAREN37_tree = default(LSLAst);
		LSLAst char_literal39_tree = default(LSLAst);
		LSLAst RPAREN41_tree = default(LSLAst);
		LSLAst SEMI42_tree = default(LSLAst);
		LSLAst char_literal43_tree = default(LSLAst);
		LSLAst char_literal45_tree = default(LSLAst);
		LSLAst string_literal46_tree = default(LSLAst);
		LSLAst char_literal47_tree = default(LSLAst);
		LSLAst char_literal49_tree = default(LSLAst);
		LSLAst char_literal51_tree = default(LSLAst);
		LSLAst char_literal52_tree = default(LSLAst);
		LSLAst string_literal55_tree = default(LSLAst);
		LSLAst char_literal56_tree = default(LSLAst);
		LSLAst char_literal58_tree = default(LSLAst);
		LSLAst SEMI59_tree = default(LSLAst);
		LSLAst string_literal62_tree = default(LSLAst);
		LSLAst ID63_tree = default(LSLAst);
		LSLAst char_literal64_tree = default(LSLAst);
		LSLAst SEMI65_tree = default(LSLAst);
		LSLAst string_literal66_tree = default(LSLAst);
		LSLAst ID67_tree = default(LSLAst);
		LSLAst char_literal68_tree = default(LSLAst);
		LSLAst SEMI69_tree = default(LSLAst);
		LSLAst ID70_tree = default(LSLAst);
		LSLAst char_literal71_tree = default(LSLAst);
		LSLAst string_literal72_tree = default(LSLAst);
		LSLAst SEMI73_tree = default(LSLAst);
		LSLAst ID74_tree = default(LSLAst);
		LSLAst char_literal75_tree = default(LSLAst);
		LSLAst string_literal76_tree = default(LSLAst);
		LSLAst SEMI77_tree = default(LSLAst);
		LSLAst SEMI79_tree = default(LSLAst);
		LSLAst ID80_tree = default(LSLAst);
		LSLAst string_literal81_tree = default(LSLAst);
		LSLAst SEMI82_tree = default(LSLAst);
		LSLAst SEMI84_tree = default(LSLAst);
		LSLAst string_literal85_tree = default(LSLAst);
		LSLAst ID86_tree = default(LSLAst);
		LSLAst SEMI87_tree = default(LSLAst);
		LSLAst NEWLINE89_tree = default(LSLAst);
		LSLAst COMMENT_SINGLE90_tree = default(LSLAst);
		LSLAst COMMENT_BLOCK91_tree = default(LSLAst);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN_EQ=new RewriteRuleITokenStream(adaptor,"token ASSIGN_EQ");
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_86=new RewriteRuleITokenStream(adaptor,"token 86");
		RewriteRuleITokenStream stream_84=new RewriteRuleITokenStream(adaptor,"token 84");
		RewriteRuleITokenStream stream_90=new RewriteRuleITokenStream(adaptor,"token 90");
		RewriteRuleITokenStream stream_85=new RewriteRuleITokenStream(adaptor,"token 85");
		RewriteRuleITokenStream stream_83=new RewriteRuleITokenStream(adaptor,"token 83");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_88=new RewriteRuleITokenStream(adaptor,"token 88");
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleITokenStream stream_87=new RewriteRuleITokenStream(adaptor,"token 87");
		RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"rule lhs");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_exprStatement=new RewriteRuleSubtreeStream(adaptor,"rule exprStatement");
		RewriteRuleSubtreeStream stream_funcCall=new RewriteRuleSubtreeStream(adaptor,"rule funcCall");
		try { DebugEnterRule(GrammarFileName, "funcBlockContent");
		DebugLocation(147, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }
			// LSL.g:148:2: ( SEMI | ( LPAREN )? lhs ( '.' subscript= ID )? (t= '=' |t= '+=' |t= '-=' |t= '*=' |t= '/=' |t= '%=' |t= '<<=' |t= '>>=' ) expression ( RPAREN )? SEMI -> {$subscript!=null}? ^( $t ^( SUBSCRIPT lhs $subscript) expression ) -> ^( $t lhs expression ) |i= 'if' '(' expression ')' s= statement ( 'else' e= statement )? -> ^( IF_STMT[$i] expression $s ^( ELSE_PART ( $e)? ) ) |w= 'while' '(' expression ')' statement -> ^( WHILE_STMT[$w] expression statement ) |f= 'for' '(' init= exprStatement cond= exprStatement (loop= expression )? ')' statement -> ^( FOR_STMT[$f] statement $init $cond ( $loop)? ) |d= 'do' statement 'while' '(' expression ')' SEMI -> ^( DO_WHILE_STMT[$d] expression statement ) | varDecl | funcCall -> ^( EXPR funcCall ) | '++' ID ( '.' subscript= ID )? SEMI -> {$subscript == null}? ^( EXPR ^( PRE_INCREMENT ID ) ) -> ^( EXPR ^( PRE_INCREMENT ^( SUBSCRIPT ID $subscript) ) ) | '--' ID ( '.' subscript= ID )? SEMI -> {$subscript == null}? ^( EXPR ^( PRE_DECREMENT ID ) ) -> ^( EXPR ^( PRE_DECREMENT ^( SUBSCRIPT ID $subscript) ) ) | ID ( '.' subscript= ID )? '++' SEMI -> {$subscript == null}? ^( EXPR ^( POST_INCREMENT ID ) ) -> ^( EXPR ^( POST_INCREMENT ^( SUBSCRIPT ID $subscript) ) ) | ID ( '.' subscript= ID )? '--' SEMI -> {$subscript == null}? ^( EXPR ^( POST_DECREMENT ID ) ) -> ^( EXPR ^( POST_DECREMENT ^( SUBSCRIPT ID $subscript) ) ) |r= 'return' ( expression )? SEMI -> ^( RETURN_STMT[$r] ( expression )? ) |stateNode= 'state' ( ID | 'default' ) SEMI -> ^( STATE_CHG[$stateNode] ( ID )? ) | label SEMI | 'jump' ID SEMI -> ^( JUMP_STMT ID ) | funcBlock | NEWLINE | COMMENT_SINGLE | COMMENT_BLOCK )
			int alt23=20;
			try { DebugEnterDecision(23, false);
			try
			{
				alt23 = dfa23.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:149:3: SEMI
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(149, 3);
				SEMI36=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent578); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SEMI36_tree = (LSLAst)adaptor.Create(SEMI36);
				adaptor.AddChild(root_0, SEMI36_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:151:4: ( LPAREN )? lhs ( '.' subscript= ID )? (t= '=' |t= '+=' |t= '-=' |t= '*=' |t= '/=' |t= '%=' |t= '<<=' |t= '>>=' ) expression ( RPAREN )? SEMI
				{
				DebugLocation(151, 4);
				// LSL.g:151:4: ( LPAREN )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==LPAREN))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:151:4: LPAREN
					{
					DebugLocation(151, 4);
					LPAREN37=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcBlockContent585); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LPAREN.Add(LPAREN37);


					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(151, 12);
				PushFollow(Follow._lhs_in_funcBlockContent588);
				lhs38=lhs();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_lhs.Add(lhs38.Tree);
				DebugLocation(151, 16);
				// LSL.g:151:16: ( '.' subscript= ID )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==68))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:151:17: '.' subscript= ID
					{
					DebugLocation(151, 17);
					char_literal39=(IToken)Match(input,68,Follow._68_in_funcBlockContent591); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_68.Add(char_literal39);

					DebugLocation(151, 30);
					subscript=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent595); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(subscript);


					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(151, 36);
				// LSL.g:151:36: (t= '=' |t= '+=' |t= '-=' |t= '*=' |t= '/=' |t= '%=' |t= '<<=' |t= '>>=' )
				int alt13=8;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				switch (input.LA(1))
				{
				case ASSIGN_EQ:
					{
					alt13 = 1;
					}
					break;
				case 65:
					{
					alt13 = 2;
					}
					break;
				case 67:
					{
					alt13 = 3;
					}
					break;
				case 62:
					{
					alt13 = 4;
					}
					break;
				case 70:
					{
					alt13 = 5;
					}
					break;
				case 58:
					{
					alt13 = 6;
					}
					break;
				case 72:
					{
					alt13 = 7;
					}
					break;
				case 77:
					{
					alt13 = 8;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:151:37: t= '='
					{
					DebugLocation(151, 38);
					t=(IToken)Match(input,ASSIGN_EQ,Follow._ASSIGN_EQ_in_funcBlockContent602); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ASSIGN_EQ.Add(t);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// LSL.g:151:45: t= '+='
					{
					DebugLocation(151, 46);
					t=(IToken)Match(input,65,Follow._65_in_funcBlockContent608); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_65.Add(t);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// LSL.g:151:54: t= '-='
					{
					DebugLocation(151, 55);
					t=(IToken)Match(input,67,Follow._67_in_funcBlockContent614); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_67.Add(t);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// LSL.g:151:63: t= '*='
					{
					DebugLocation(151, 64);
					t=(IToken)Match(input,62,Follow._62_in_funcBlockContent620); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_62.Add(t);


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// LSL.g:151:72: t= '/='
					{
					DebugLocation(151, 73);
					t=(IToken)Match(input,70,Follow._70_in_funcBlockContent626); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_70.Add(t);


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// LSL.g:151:81: t= '%='
					{
					DebugLocation(151, 82);
					t=(IToken)Match(input,58,Follow._58_in_funcBlockContent632); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_58.Add(t);


					}
					break;
				case 7:
					DebugEnterAlt(7);
					// LSL.g:151:90: t= '<<='
					{
					DebugLocation(151, 91);
					t=(IToken)Match(input,72,Follow._72_in_funcBlockContent638); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_72.Add(t);


					}
					break;
				case 8:
					DebugEnterAlt(8);
					// LSL.g:151:100: t= '>>='
					{
					DebugLocation(151, 101);
					t=(IToken)Match(input,77,Follow._77_in_funcBlockContent644); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_77.Add(t);


					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(151, 109);
				PushFollow(Follow._expression_in_funcBlockContent647);
				expression40=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression40.Tree);
				DebugLocation(151, 120);
				// LSL.g:151:120: ( RPAREN )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==RPAREN))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:151:120: RPAREN
					{
					DebugLocation(151, 120);
					RPAREN41=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcBlockContent649); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RPAREN.Add(RPAREN41);


					}
					break;

				}
				} finally { DebugExitSubRule(14); }

				DebugLocation(151, 128);
				SEMI42=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent652); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI42);



				{
				// AST REWRITE
				// elements: t, lhs, subscript, expression, t, lhs, expression
				// token labels: t, subscript
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_t=new RewriteRuleITokenStream(adaptor,"token t",t);
				RewriteRuleITokenStream stream_subscript=new RewriteRuleITokenStream(adaptor,"token subscript",subscript);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 152:4: -> {$subscript!=null}? ^( $t ^( SUBSCRIPT lhs $subscript) expression )
				if (subscript!=null)
				{
					DebugLocation(152, 27);
					// LSL.g:152:27: ^( $t ^( SUBSCRIPT lhs $subscript) expression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(152, 30);
					root_1 = (LSLAst)adaptor.BecomeRoot(stream_t.NextNode(), root_1);

					DebugLocation(152, 32);
					// LSL.g:152:32: ^( SUBSCRIPT lhs $subscript)
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(152, 34);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(SUBSCRIPT, "SUBSCRIPT"), root_2);

					DebugLocation(152, 44);
					adaptor.AddChild(root_2, stream_lhs.NextTree());
					DebugLocation(152, 49);
					adaptor.AddChild(root_2, stream_subscript.NextNode());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(152, 60);
					adaptor.AddChild(root_1, stream_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 153:4: -> ^( $t lhs expression )
				{
					DebugLocation(153, 7);
					// LSL.g:153:7: ^( $t lhs expression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(153, 10);
					root_1 = (LSLAst)adaptor.BecomeRoot(stream_t.NextNode(), root_1);

					DebugLocation(153, 12);
					adaptor.AddChild(root_1, stream_lhs.NextTree());
					DebugLocation(153, 16);
					adaptor.AddChild(root_1, stream_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// LSL.g:155:4: i= 'if' '(' expression ')' s= statement ( 'else' e= statement )?
				{
				DebugLocation(155, 5);
				i=(IToken)Match(input,86,Follow._86_in_funcBlockContent701); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_86.Add(i);

				DebugLocation(155, 11);
				char_literal43=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcBlockContent703); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(char_literal43);

				DebugLocation(155, 15);
				PushFollow(Follow._expression_in_funcBlockContent705);
				expression44=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression44.Tree);
				DebugLocation(155, 26);
				char_literal45=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcBlockContent707); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(char_literal45);

				DebugLocation(155, 31);
				PushFollow(Follow._statement_in_funcBlockContent711);
				s=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(s.Tree);
				DebugLocation(155, 42);
				// LSL.g:155:42: ( 'else' e= statement )?
				int alt15=2;
				try { DebugEnterSubRule(15);
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==84))
				{
					int LA15_1 = input.LA(2);

					if ((EvaluatePredicate(synpred29_LSL_fragment)))
					{
						alt15 = 1;
					}
				}
				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:155:43: 'else' e= statement
					{
					DebugLocation(155, 43);
					string_literal46=(IToken)Match(input,84,Follow._84_in_funcBlockContent714); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_84.Add(string_literal46);

					DebugLocation(155, 51);
					PushFollow(Follow._statement_in_funcBlockContent718);
					e=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(e.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(15); }



				{
				// AST REWRITE
				// elements: expression, s, e
				// token labels: 
				// rule labels: s, e, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.Tree:null);
				RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 156:4: -> ^( IF_STMT[$i] expression $s ^( ELSE_PART ( $e)? ) )
				{
					DebugLocation(156, 7);
					// LSL.g:156:7: ^( IF_STMT[$i] expression $s ^( ELSE_PART ( $e)? ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(156, 9);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(IF_STMT, i), root_1);

					DebugLocation(156, 21);
					adaptor.AddChild(root_1, stream_expression.NextTree());
					DebugLocation(156, 33);
					adaptor.AddChild(root_1, stream_s.NextTree());
					DebugLocation(156, 35);
					// LSL.g:156:35: ^( ELSE_PART ( $e)? )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(156, 37);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(ELSE_PART, "ELSE_PART"), root_2);

					DebugLocation(156, 48);
					// LSL.g:156:48: ( $e)?
					if (stream_e.HasNext)
					{
						DebugLocation(156, 48);
						adaptor.AddChild(root_2, stream_e.NextTree());

					}
					stream_e.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// LSL.g:158:4: w= 'while' '(' expression ')' statement
				{
				DebugLocation(158, 5);
				w=(IToken)Match(input,90,Follow._90_in_funcBlockContent753); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_90.Add(w);

				DebugLocation(158, 14);
				char_literal47=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcBlockContent755); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(char_literal47);

				DebugLocation(158, 18);
				PushFollow(Follow._expression_in_funcBlockContent757);
				expression48=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression48.Tree);
				DebugLocation(158, 29);
				char_literal49=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcBlockContent759); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(char_literal49);

				DebugLocation(158, 33);
				PushFollow(Follow._statement_in_funcBlockContent761);
				statement50=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement50.Tree);


				{
				// AST REWRITE
				// elements: expression, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 158:43: -> ^( WHILE_STMT[$w] expression statement )
				{
					DebugLocation(158, 46);
					// LSL.g:158:46: ^( WHILE_STMT[$w] expression statement )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(158, 48);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(WHILE_STMT, w), root_1);

					DebugLocation(158, 63);
					adaptor.AddChild(root_1, stream_expression.NextTree());
					DebugLocation(158, 74);
					adaptor.AddChild(root_1, stream_statement.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// LSL.g:160:4: f= 'for' '(' init= exprStatement cond= exprStatement (loop= expression )? ')' statement
				{
				DebugLocation(160, 5);
				f=(IToken)Match(input,85,Follow._85_in_funcBlockContent781); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_85.Add(f);

				DebugLocation(160, 12);
				char_literal51=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcBlockContent783); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(char_literal51);

				DebugLocation(160, 20);
				PushFollow(Follow._exprStatement_in_funcBlockContent787);
				init=exprStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_exprStatement.Add(init.Tree);
				DebugLocation(160, 39);
				PushFollow(Follow._exprStatement_in_funcBlockContent791);
				cond=exprStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_exprStatement.Add(cond.Tree);
				DebugLocation(160, 58);
				// LSL.g:160:58: (loop= expression )?
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==FLOAT_LITERAL||LA16_0==ID||LA16_0==INTEGER_LITERAL||(LA16_0>=LPAREN && LA16_0<=LT)||LA16_0==MINUS||LA16_0==STRING_LITERAL||LA16_0==55||LA16_0==64||LA16_0==66||LA16_0==79||LA16_0==95))
				{
					alt16 = 1;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:160:58: loop= expression
					{
					DebugLocation(160, 58);
					PushFollow(Follow._expression_in_funcBlockContent795);
					loop=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(loop.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(16); }

				DebugLocation(160, 71);
				char_literal52=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcBlockContent798); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(char_literal52);

				DebugLocation(160, 75);
				PushFollow(Follow._statement_in_funcBlockContent800);
				statement53=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement53.Tree);


				{
				// AST REWRITE
				// elements: statement, init, cond, loop
				// token labels: 
				// rule labels: init, cond, loop, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_init=new RewriteRuleSubtreeStream(adaptor,"rule init",init!=null?init.Tree:null);
				RewriteRuleSubtreeStream stream_cond=new RewriteRuleSubtreeStream(adaptor,"rule cond",cond!=null?cond.Tree:null);
				RewriteRuleSubtreeStream stream_loop=new RewriteRuleSubtreeStream(adaptor,"rule loop",loop!=null?loop.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 161:4: -> ^( FOR_STMT[$f] statement $init $cond ( $loop)? )
				{
					DebugLocation(161, 7);
					// LSL.g:161:7: ^( FOR_STMT[$f] statement $init $cond ( $loop)? )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(161, 9);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(FOR_STMT, f), root_1);

					DebugLocation(161, 22);
					adaptor.AddChild(root_1, stream_statement.NextTree());
					DebugLocation(161, 33);
					adaptor.AddChild(root_1, stream_init.NextTree());
					DebugLocation(161, 39);
					adaptor.AddChild(root_1, stream_cond.NextTree());
					DebugLocation(161, 45);
					// LSL.g:161:45: ( $loop)?
					if (stream_loop.HasNext)
					{
						DebugLocation(161, 45);
						adaptor.AddChild(root_1, stream_loop.NextTree());

					}
					stream_loop.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// LSL.g:163:4: d= 'do' statement 'while' '(' expression ')' SEMI
				{
				DebugLocation(163, 5);
				d=(IToken)Match(input,83,Follow._83_in_funcBlockContent831); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_83.Add(d);

				DebugLocation(163, 11);
				PushFollow(Follow._statement_in_funcBlockContent833);
				statement54=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement54.Tree);
				DebugLocation(163, 21);
				string_literal55=(IToken)Match(input,90,Follow._90_in_funcBlockContent835); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_90.Add(string_literal55);

				DebugLocation(163, 29);
				char_literal56=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcBlockContent837); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(char_literal56);

				DebugLocation(163, 33);
				PushFollow(Follow._expression_in_funcBlockContent839);
				expression57=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression57.Tree);
				DebugLocation(163, 44);
				char_literal58=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcBlockContent841); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(char_literal58);

				DebugLocation(163, 48);
				SEMI59=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent843); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI59);



				{
				// AST REWRITE
				// elements: expression, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 164:4: -> ^( DO_WHILE_STMT[$d] expression statement )
				{
					DebugLocation(164, 7);
					// LSL.g:164:7: ^( DO_WHILE_STMT[$d] expression statement )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(164, 9);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(DO_WHILE_STMT, d), root_1);

					DebugLocation(164, 27);
					adaptor.AddChild(root_1, stream_expression.NextTree());
					DebugLocation(164, 38);
					adaptor.AddChild(root_1, stream_statement.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// LSL.g:166:4: varDecl
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(166, 4);
				PushFollow(Follow._varDecl_in_funcBlockContent864);
				varDecl60=varDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varDecl60.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// LSL.g:167:4: funcCall
				{
				DebugLocation(167, 4);
				PushFollow(Follow._funcCall_in_funcBlockContent869);
				funcCall61=funcCall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_funcCall.Add(funcCall61.Tree);


				{
				// AST REWRITE
				// elements: funcCall
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 167:13: -> ^( EXPR funcCall )
				{
					DebugLocation(167, 16);
					// LSL.g:167:16: ^( EXPR funcCall )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(167, 18);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(167, 23);
					adaptor.AddChild(root_1, stream_funcCall.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// LSL.g:169:4: '++' ID ( '.' subscript= ID )? SEMI
				{
				DebugLocation(169, 4);
				string_literal62=(IToken)Match(input,64,Follow._64_in_funcBlockContent884); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal62);

				DebugLocation(169, 9);
				ID63=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent886); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID63);

				DebugLocation(169, 12);
				// LSL.g:169:12: ( '.' subscript= ID )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==68))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:169:13: '.' subscript= ID
					{
					DebugLocation(169, 13);
					char_literal64=(IToken)Match(input,68,Follow._68_in_funcBlockContent889); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_68.Add(char_literal64);

					DebugLocation(169, 26);
					subscript=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent893); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(subscript);


					}
					break;

				}
				} finally { DebugExitSubRule(17); }

				DebugLocation(169, 32);
				SEMI65=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent897); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI65);



				{
				// AST REWRITE
				// elements: ID, ID, subscript
				// token labels: subscript
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_subscript=new RewriteRuleITokenStream(adaptor,"token subscript",subscript);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 170:4: -> {$subscript == null}? ^( EXPR ^( PRE_INCREMENT ID ) )
				if (subscript == null)
				{
					DebugLocation(170, 29);
					// LSL.g:170:29: ^( EXPR ^( PRE_INCREMENT ID ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(170, 31);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(170, 36);
					// LSL.g:170:36: ^( PRE_INCREMENT ID )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(170, 38);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(PRE_INCREMENT, "PRE_INCREMENT"), root_2);

					DebugLocation(170, 52);
					adaptor.AddChild(root_2, stream_ID.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 171:4: -> ^( EXPR ^( PRE_INCREMENT ^( SUBSCRIPT ID $subscript) ) )
				{
					DebugLocation(171, 7);
					// LSL.g:171:7: ^( EXPR ^( PRE_INCREMENT ^( SUBSCRIPT ID $subscript) ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(171, 9);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(171, 14);
					// LSL.g:171:14: ^( PRE_INCREMENT ^( SUBSCRIPT ID $subscript) )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(171, 16);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(PRE_INCREMENT, "PRE_INCREMENT"), root_2);

					DebugLocation(171, 30);
					// LSL.g:171:30: ^( SUBSCRIPT ID $subscript)
					{
					LSLAst root_3 = (LSLAst)adaptor.Nil();
					DebugLocation(171, 32);
					root_3 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(SUBSCRIPT, "SUBSCRIPT"), root_3);

					DebugLocation(171, 42);
					adaptor.AddChild(root_3, stream_ID.NextNode());
					DebugLocation(171, 46);
					adaptor.AddChild(root_3, stream_subscript.NextNode());

					adaptor.AddChild(root_2, root_3);
					}

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// LSL.g:173:4: '--' ID ( '.' subscript= ID )? SEMI
				{
				DebugLocation(173, 4);
				string_literal66=(IToken)Match(input,66,Follow._66_in_funcBlockContent946); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_66.Add(string_literal66);

				DebugLocation(173, 9);
				ID67=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent948); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID67);

				DebugLocation(173, 12);
				// LSL.g:173:12: ( '.' subscript= ID )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==68))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:173:13: '.' subscript= ID
					{
					DebugLocation(173, 13);
					char_literal68=(IToken)Match(input,68,Follow._68_in_funcBlockContent951); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_68.Add(char_literal68);

					DebugLocation(173, 26);
					subscript=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent955); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(subscript);


					}
					break;

				}
				} finally { DebugExitSubRule(18); }

				DebugLocation(173, 32);
				SEMI69=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent959); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI69);



				{
				// AST REWRITE
				// elements: ID, ID, subscript
				// token labels: subscript
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_subscript=new RewriteRuleITokenStream(adaptor,"token subscript",subscript);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 174:4: -> {$subscript == null}? ^( EXPR ^( PRE_DECREMENT ID ) )
				if (subscript == null)
				{
					DebugLocation(174, 29);
					// LSL.g:174:29: ^( EXPR ^( PRE_DECREMENT ID ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(174, 31);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(174, 36);
					// LSL.g:174:36: ^( PRE_DECREMENT ID )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(174, 38);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(PRE_DECREMENT, "PRE_DECREMENT"), root_2);

					DebugLocation(174, 52);
					adaptor.AddChild(root_2, stream_ID.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 175:4: -> ^( EXPR ^( PRE_DECREMENT ^( SUBSCRIPT ID $subscript) ) )
				{
					DebugLocation(175, 7);
					// LSL.g:175:7: ^( EXPR ^( PRE_DECREMENT ^( SUBSCRIPT ID $subscript) ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(175, 9);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(175, 14);
					// LSL.g:175:14: ^( PRE_DECREMENT ^( SUBSCRIPT ID $subscript) )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(175, 16);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(PRE_DECREMENT, "PRE_DECREMENT"), root_2);

					DebugLocation(175, 30);
					// LSL.g:175:30: ^( SUBSCRIPT ID $subscript)
					{
					LSLAst root_3 = (LSLAst)adaptor.Nil();
					DebugLocation(175, 32);
					root_3 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(SUBSCRIPT, "SUBSCRIPT"), root_3);

					DebugLocation(175, 42);
					adaptor.AddChild(root_3, stream_ID.NextNode());
					DebugLocation(175, 46);
					adaptor.AddChild(root_3, stream_subscript.NextNode());

					adaptor.AddChild(root_2, root_3);
					}

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// LSL.g:177:4: ID ( '.' subscript= ID )? '++' SEMI
				{
				DebugLocation(177, 4);
				ID70=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent1006); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID70);

				DebugLocation(177, 7);
				// LSL.g:177:7: ( '.' subscript= ID )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==68))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:177:8: '.' subscript= ID
					{
					DebugLocation(177, 8);
					char_literal71=(IToken)Match(input,68,Follow._68_in_funcBlockContent1009); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_68.Add(char_literal71);

					DebugLocation(177, 21);
					subscript=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent1013); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(subscript);


					}
					break;

				}
				} finally { DebugExitSubRule(19); }

				DebugLocation(177, 27);
				string_literal72=(IToken)Match(input,64,Follow._64_in_funcBlockContent1017); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal72);

				DebugLocation(177, 32);
				SEMI73=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent1019); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI73);



				{
				// AST REWRITE
				// elements: ID, ID, subscript
				// token labels: subscript
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_subscript=new RewriteRuleITokenStream(adaptor,"token subscript",subscript);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 178:4: -> {$subscript == null}? ^( EXPR ^( POST_INCREMENT ID ) )
				if (subscript == null)
				{
					DebugLocation(178, 29);
					// LSL.g:178:29: ^( EXPR ^( POST_INCREMENT ID ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(178, 31);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(178, 36);
					// LSL.g:178:36: ^( POST_INCREMENT ID )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(178, 38);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(POST_INCREMENT, "POST_INCREMENT"), root_2);

					DebugLocation(178, 53);
					adaptor.AddChild(root_2, stream_ID.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 179:4: -> ^( EXPR ^( POST_INCREMENT ^( SUBSCRIPT ID $subscript) ) )
				{
					DebugLocation(179, 7);
					// LSL.g:179:7: ^( EXPR ^( POST_INCREMENT ^( SUBSCRIPT ID $subscript) ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(179, 9);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(179, 14);
					// LSL.g:179:14: ^( POST_INCREMENT ^( SUBSCRIPT ID $subscript) )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(179, 16);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(POST_INCREMENT, "POST_INCREMENT"), root_2);

					DebugLocation(179, 31);
					// LSL.g:179:31: ^( SUBSCRIPT ID $subscript)
					{
					LSLAst root_3 = (LSLAst)adaptor.Nil();
					DebugLocation(179, 33);
					root_3 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(SUBSCRIPT, "SUBSCRIPT"), root_3);

					DebugLocation(179, 43);
					adaptor.AddChild(root_3, stream_ID.NextNode());
					DebugLocation(179, 47);
					adaptor.AddChild(root_3, stream_subscript.NextNode());

					adaptor.AddChild(root_2, root_3);
					}

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// LSL.g:181:4: ID ( '.' subscript= ID )? '--' SEMI
				{
				DebugLocation(181, 4);
				ID74=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent1068); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID74);

				DebugLocation(181, 7);
				// LSL.g:181:7: ( '.' subscript= ID )?
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==68))
				{
					alt20 = 1;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:181:8: '.' subscript= ID
					{
					DebugLocation(181, 8);
					char_literal75=(IToken)Match(input,68,Follow._68_in_funcBlockContent1071); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_68.Add(char_literal75);

					DebugLocation(181, 21);
					subscript=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent1075); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(subscript);


					}
					break;

				}
				} finally { DebugExitSubRule(20); }

				DebugLocation(181, 27);
				string_literal76=(IToken)Match(input,66,Follow._66_in_funcBlockContent1079); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_66.Add(string_literal76);

				DebugLocation(181, 32);
				SEMI77=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent1081); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI77);



				{
				// AST REWRITE
				// elements: ID, ID, subscript
				// token labels: subscript
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_subscript=new RewriteRuleITokenStream(adaptor,"token subscript",subscript);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 182:4: -> {$subscript == null}? ^( EXPR ^( POST_DECREMENT ID ) )
				if (subscript == null)
				{
					DebugLocation(182, 29);
					// LSL.g:182:29: ^( EXPR ^( POST_DECREMENT ID ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(182, 31);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(182, 36);
					// LSL.g:182:36: ^( POST_DECREMENT ID )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(182, 38);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(POST_DECREMENT, "POST_DECREMENT"), root_2);

					DebugLocation(182, 53);
					adaptor.AddChild(root_2, stream_ID.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 183:4: -> ^( EXPR ^( POST_DECREMENT ^( SUBSCRIPT ID $subscript) ) )
				{
					DebugLocation(183, 7);
					// LSL.g:183:7: ^( EXPR ^( POST_DECREMENT ^( SUBSCRIPT ID $subscript) ) )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(183, 9);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, "EXPR"), root_1);

					DebugLocation(183, 14);
					// LSL.g:183:14: ^( POST_DECREMENT ^( SUBSCRIPT ID $subscript) )
					{
					LSLAst root_2 = (LSLAst)adaptor.Nil();
					DebugLocation(183, 16);
					root_2 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(POST_DECREMENT, "POST_DECREMENT"), root_2);

					DebugLocation(183, 31);
					// LSL.g:183:31: ^( SUBSCRIPT ID $subscript)
					{
					LSLAst root_3 = (LSLAst)adaptor.Nil();
					DebugLocation(183, 33);
					root_3 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(SUBSCRIPT, "SUBSCRIPT"), root_3);

					DebugLocation(183, 43);
					adaptor.AddChild(root_3, stream_ID.NextNode());
					DebugLocation(183, 47);
					adaptor.AddChild(root_3, stream_subscript.NextNode());

					adaptor.AddChild(root_2, root_3);
					}

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// LSL.g:185:4: r= 'return' ( expression )? SEMI
				{
				DebugLocation(185, 5);
				r=(IToken)Match(input,88,Follow._88_in_funcBlockContent1132); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_88.Add(r);

				DebugLocation(185, 15);
				// LSL.g:185:15: ( expression )?
				int alt21=2;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==FLOAT_LITERAL||LA21_0==ID||LA21_0==INTEGER_LITERAL||(LA21_0>=LPAREN && LA21_0<=LT)||LA21_0==MINUS||LA21_0==STRING_LITERAL||LA21_0==55||LA21_0==64||LA21_0==66||LA21_0==79||LA21_0==95))
				{
					alt21 = 1;
				}
				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:185:15: expression
					{
					DebugLocation(185, 15);
					PushFollow(Follow._expression_in_funcBlockContent1134);
					expression78=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression78.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(21); }

				DebugLocation(185, 27);
				SEMI79=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent1137); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI79);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 185:32: -> ^( RETURN_STMT[$r] ( expression )? )
				{
					DebugLocation(185, 35);
					// LSL.g:185:35: ^( RETURN_STMT[$r] ( expression )? )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(185, 37);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(RETURN_STMT, r), root_1);

					DebugLocation(185, 53);
					// LSL.g:185:53: ( expression )?
					if (stream_expression.HasNext)
					{
						DebugLocation(185, 53);
						adaptor.AddChild(root_1, stream_expression.NextTree());

					}
					stream_expression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// LSL.g:186:4: stateNode= 'state' ( ID | 'default' ) SEMI
				{
				DebugLocation(186, 13);
				stateNode=(IToken)Match(input,89,Follow._89_in_funcBlockContent1154); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_89.Add(stateNode);

				DebugLocation(186, 22);
				// LSL.g:186:22: ( ID | 'default' )
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==ID))
				{
					alt22 = 1;
				}
				else if ((LA22_0==82))
				{
					alt22 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:186:23: ID
					{
					DebugLocation(186, 23);
					ID80=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent1157); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID80);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// LSL.g:186:28: 'default'
					{
					DebugLocation(186, 28);
					string_literal81=(IToken)Match(input,82,Follow._82_in_funcBlockContent1161); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_82.Add(string_literal81);


					}
					break;

				}
				} finally { DebugExitSubRule(22); }

				DebugLocation(186, 39);
				SEMI82=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent1164); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI82);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 186:44: -> ^( STATE_CHG[$stateNode] ( ID )? )
				{
					DebugLocation(186, 47);
					// LSL.g:186:47: ^( STATE_CHG[$stateNode] ( ID )? )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(186, 49);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(STATE_CHG, stateNode), root_1);

					DebugLocation(186, 71);
					// LSL.g:186:71: ( ID )?
					if (stream_ID.HasNext)
					{
						DebugLocation(186, 71);
						adaptor.AddChild(root_1, stream_ID.NextNode());

					}
					stream_ID.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// LSL.g:187:4: label SEMI
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(187, 4);
				PushFollow(Follow._label_in_funcBlockContent1179);
				label83=label();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, label83.Tree);
				DebugLocation(187, 14);
				SEMI84=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent1181); if (state.failed) return retval;

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// LSL.g:188:4: 'jump' ID SEMI
				{
				DebugLocation(188, 4);
				string_literal85=(IToken)Match(input,87,Follow._87_in_funcBlockContent1187); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_87.Add(string_literal85);

				DebugLocation(188, 11);
				ID86=(IToken)Match(input,ID,Follow._ID_in_funcBlockContent1189); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID86);

				DebugLocation(188, 14);
				SEMI87=(IToken)Match(input,SEMI,Follow._SEMI_in_funcBlockContent1191); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI87);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 188:19: -> ^( JUMP_STMT ID )
				{
					DebugLocation(188, 22);
					// LSL.g:188:22: ^( JUMP_STMT ID )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(188, 24);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(JUMP_STMT, "JUMP_STMT"), root_1);

					DebugLocation(188, 34);
					adaptor.AddChild(root_1, stream_ID.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// LSL.g:189:4: funcBlock
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(189, 4);
				PushFollow(Follow._funcBlock_in_funcBlockContent1204);
				funcBlock88=funcBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcBlock88.Tree);

				}
				break;
			case 18:
				DebugEnterAlt(18);
				// LSL.g:190:4: NEWLINE
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(190, 11);
				NEWLINE89=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_funcBlockContent1210); if (state.failed) return retval;

				}
				break;
			case 19:
				DebugEnterAlt(19);
				// LSL.g:191:4: COMMENT_SINGLE
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(191, 18);
				COMMENT_SINGLE90=(IToken)Match(input,COMMENT_SINGLE,Follow._COMMENT_SINGLE_in_funcBlockContent1216); if (state.failed) return retval;

				}
				break;
			case 20:
				DebugEnterAlt(20);
				// LSL.g:192:5: COMMENT_BLOCK
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(192, 18);
				COMMENT_BLOCK91=(IToken)Match(input,COMMENT_BLOCK,Follow._COMMENT_BLOCK_in_funcBlockContent1223); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcBlockContent", 11);
			LeaveRule("funcBlockContent", 11);
			LeaveRule_funcBlockContent();
			if (state.backtracking > 0) { Memoize(input, 11, funcBlockContent_StartIndex); }
		}
		DebugLocation(193, 1);
		} finally { DebugExitRule(GrammarFileName, "funcBlockContent"); }
		return retval;

	}
	// $ANTLR end "funcBlockContent"

	private sealed partial class lhs_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public lhs_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_lhs();
	partial void LeaveRule_lhs();

	// $ANTLR start "lhs"
	// LSL.g:195:1: lhs : ID -> ^( EXPR[$ID] ID ) ;
	[GrammarRule("lhs")]
	private LSLParser.lhs_return lhs()
	{
		EnterRule_lhs();
		EnterRule("lhs", 12);
		TraceIn("lhs", 12);
		LSLParser.lhs_return retval = new LSLParser.lhs_return(this);
		retval.Start = (IToken)input.LT(1);
		int lhs_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken ID92 = default(IToken);

		LSLAst ID92_tree = default(LSLAst);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "lhs");
		DebugLocation(195, 27);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }
			// LSL.g:195:5: ( ID -> ^( EXPR[$ID] ID ) )
			DebugEnterAlt(1);
			// LSL.g:195:7: ID
			{
			DebugLocation(195, 7);
			ID92=(IToken)Match(input,ID,Follow._ID_in_lhs1235); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID92);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 195:10: -> ^( EXPR[$ID] ID )
			{
				DebugLocation(195, 13);
				// LSL.g:195:13: ^( EXPR[$ID] ID )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(195, 15);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, ID92), root_1);

				DebugLocation(195, 25);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lhs", 12);
			LeaveRule("lhs", 12);
			LeaveRule_lhs();
			if (state.backtracking > 0) { Memoize(input, 12, lhs_StartIndex); }
		}
		DebugLocation(195, 27);
		} finally { DebugExitRule(GrammarFileName, "lhs"); }
		return retval;

	}
	// $ANTLR end "lhs"

	private sealed partial class funcCall_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public funcCall_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_funcCall();
	partial void LeaveRule_funcCall();

	// $ANTLR start "funcCall"
	// LSL.g:197:1: funcCall : ID '(' callParamList ')' SEMI -> ^( METHOD_CALL[$ID] ID callParamList ) ;
	[GrammarRule("funcCall")]
	private LSLParser.funcCall_return funcCall()
	{
		EnterRule_funcCall();
		EnterRule("funcCall", 13);
		TraceIn("funcCall", 13);
		LSLParser.funcCall_return retval = new LSLParser.funcCall_return(this);
		retval.Start = (IToken)input.LT(1);
		int funcCall_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken ID93 = default(IToken);
		IToken char_literal94 = default(IToken);
		IToken char_literal96 = default(IToken);
		IToken SEMI97 = default(IToken);
		LSLParser.callParamList_return callParamList95 = default(LSLParser.callParamList_return);

		LSLAst ID93_tree = default(LSLAst);
		LSLAst char_literal94_tree = default(LSLAst);
		LSLAst char_literal96_tree = default(LSLAst);
		LSLAst SEMI97_tree = default(LSLAst);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_callParamList=new RewriteRuleSubtreeStream(adaptor,"rule callParamList");
		try { DebugEnterRule(GrammarFileName, "funcCall");
		DebugLocation(197, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }
			// LSL.g:197:9: ( ID '(' callParamList ')' SEMI -> ^( METHOD_CALL[$ID] ID callParamList ) )
			DebugEnterAlt(1);
			// LSL.g:197:11: ID '(' callParamList ')' SEMI
			{
			DebugLocation(197, 11);
			ID93=(IToken)Match(input,ID,Follow._ID_in_funcCall1252); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID93);

			DebugLocation(197, 14);
			char_literal94=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcCall1254); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(char_literal94);

			DebugLocation(197, 18);
			PushFollow(Follow._callParamList_in_funcCall1256);
			callParamList95=callParamList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_callParamList.Add(callParamList95.Tree);
			DebugLocation(197, 32);
			char_literal96=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcCall1258); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(char_literal96);

			DebugLocation(197, 36);
			SEMI97=(IToken)Match(input,SEMI,Follow._SEMI_in_funcCall1260); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI97);



			{
			// AST REWRITE
			// elements: ID, callParamList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 197:41: -> ^( METHOD_CALL[$ID] ID callParamList )
			{
				DebugLocation(197, 44);
				// LSL.g:197:44: ^( METHOD_CALL[$ID] ID callParamList )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(197, 46);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(METHOD_CALL, ID93), root_1);

				DebugLocation(197, 63);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(197, 66);
				adaptor.AddChild(root_1, stream_callParamList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcCall", 13);
			LeaveRule("funcCall", 13);
			LeaveRule_funcCall();
			if (state.backtracking > 0) { Memoize(input, 13, funcCall_StartIndex); }
		}
		DebugLocation(198, 1);
		} finally { DebugExitRule(GrammarFileName, "funcCall"); }
		return retval;

	}
	// $ANTLR end "funcCall"

	private sealed partial class eventDef_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public eventDef_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_eventDef();
	partial void LeaveRule_eventDef();

	// $ANTLR start "eventDef"
	// LSL.g:200:1: eventDef : ID LPAREN ( paramList )? RPAREN funcBlock -> ^( EVENT_DEF ID ( paramList )? funcBlock ) ;
	[GrammarRule("eventDef")]
	private LSLParser.eventDef_return eventDef()
	{
		EnterRule_eventDef();
		EnterRule("eventDef", 14);
		TraceIn("eventDef", 14);
		LSLParser.eventDef_return retval = new LSLParser.eventDef_return(this);
		retval.Start = (IToken)input.LT(1);
		int eventDef_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken ID98 = default(IToken);
		IToken LPAREN99 = default(IToken);
		IToken RPAREN101 = default(IToken);
		LSLParser.paramList_return paramList100 = default(LSLParser.paramList_return);
		LSLParser.funcBlock_return funcBlock102 = default(LSLParser.funcBlock_return);

		LSLAst ID98_tree = default(LSLAst);
		LSLAst LPAREN99_tree = default(LSLAst);
		LSLAst RPAREN101_tree = default(LSLAst);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_paramList=new RewriteRuleSubtreeStream(adaptor,"rule paramList");
		RewriteRuleSubtreeStream stream_funcBlock=new RewriteRuleSubtreeStream(adaptor,"rule funcBlock");
		try { DebugEnterRule(GrammarFileName, "eventDef");
		DebugLocation(200, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }
			// LSL.g:200:9: ( ID LPAREN ( paramList )? RPAREN funcBlock -> ^( EVENT_DEF ID ( paramList )? funcBlock ) )
			DebugEnterAlt(1);
			// LSL.g:200:11: ID LPAREN ( paramList )? RPAREN funcBlock
			{
			DebugLocation(200, 11);
			ID98=(IToken)Match(input,ID,Follow._ID_in_eventDef1280); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID98);

			DebugLocation(200, 14);
			LPAREN99=(IToken)Match(input,LPAREN,Follow._LPAREN_in_eventDef1282); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN99);

			DebugLocation(200, 21);
			// LSL.g:200:21: ( paramList )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==TYPE))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:200:22: paramList
				{
				DebugLocation(200, 22);
				PushFollow(Follow._paramList_in_eventDef1285);
				paramList100=paramList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_paramList.Add(paramList100.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(200, 34);
			RPAREN101=(IToken)Match(input,RPAREN,Follow._RPAREN_in_eventDef1289); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN101);

			DebugLocation(200, 41);
			PushFollow(Follow._funcBlock_in_eventDef1291);
			funcBlock102=funcBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_funcBlock.Add(funcBlock102.Tree);


			{
			// AST REWRITE
			// elements: ID, paramList, funcBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 201:3: -> ^( EVENT_DEF ID ( paramList )? funcBlock )
			{
				DebugLocation(201, 6);
				// LSL.g:201:6: ^( EVENT_DEF ID ( paramList )? funcBlock )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(201, 8);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EVENT_DEF, "EVENT_DEF"), root_1);

				DebugLocation(201, 18);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(201, 21);
				// LSL.g:201:21: ( paramList )?
				if (stream_paramList.HasNext)
				{
					DebugLocation(201, 21);
					adaptor.AddChild(root_1, stream_paramList.NextTree());

				}
				stream_paramList.Reset();
				DebugLocation(201, 32);
				adaptor.AddChild(root_1, stream_funcBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("eventDef", 14);
			LeaveRule("eventDef", 14);
			LeaveRule_eventDef();
			if (state.backtracking > 0) { Memoize(input, 14, eventDef_StartIndex); }
		}
		DebugLocation(202, 1);
		} finally { DebugExitRule(GrammarFileName, "eventDef"); }
		return retval;

	}
	// $ANTLR end "eventDef"

	private sealed partial class paramList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public paramList_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_paramList();
	partial void LeaveRule_paramList();

	// $ANTLR start "paramList"
	// LSL.g:204:1: paramList : paramDecl ( ',' paramDecl )* -> ( paramDecl )+ ;
	[GrammarRule("paramList")]
	private LSLParser.paramList_return paramList()
	{
		EnterRule_paramList();
		EnterRule("paramList", 15);
		TraceIn("paramList", 15);
		LSLParser.paramList_return retval = new LSLParser.paramList_return(this);
		retval.Start = (IToken)input.LT(1);
		int paramList_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal104 = default(IToken);
		LSLParser.paramDecl_return paramDecl103 = default(LSLParser.paramDecl_return);
		LSLParser.paramDecl_return paramDecl105 = default(LSLParser.paramDecl_return);

		LSLAst char_literal104_tree = default(LSLAst);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_paramDecl=new RewriteRuleSubtreeStream(adaptor,"rule paramDecl");
		try { DebugEnterRule(GrammarFileName, "paramList");
		DebugLocation(204, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }
			// LSL.g:205:2: ( paramDecl ( ',' paramDecl )* -> ( paramDecl )+ )
			DebugEnterAlt(1);
			// LSL.g:205:4: paramDecl ( ',' paramDecl )*
			{
			DebugLocation(205, 4);
			PushFollow(Follow._paramDecl_in_paramList1318);
			paramDecl103=paramDecl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_paramDecl.Add(paramDecl103.Tree);
			DebugLocation(205, 14);
			// LSL.g:205:14: ( ',' paramDecl )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==COMMA))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:205:15: ',' paramDecl
					{
					DebugLocation(205, 15);
					char_literal104=(IToken)Match(input,COMMA,Follow._COMMA_in_paramList1321); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(char_literal104);

					DebugLocation(205, 19);
					PushFollow(Follow._paramDecl_in_paramList1323);
					paramDecl105=paramDecl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_paramDecl.Add(paramDecl105.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }



			{
			// AST REWRITE
			// elements: paramDecl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 205:31: -> ( paramDecl )+
			{
				DebugLocation(205, 34);
				if (!(stream_paramDecl.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_paramDecl.HasNext )
				{
					DebugLocation(205, 34);
					adaptor.AddChild(root_0, stream_paramDecl.NextTree());

				}
				stream_paramDecl.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("paramList", 15);
			LeaveRule("paramList", 15);
			LeaveRule_paramList();
			if (state.backtracking > 0) { Memoize(input, 15, paramList_StartIndex); }
		}
		DebugLocation(206, 1);
		} finally { DebugExitRule(GrammarFileName, "paramList"); }
		return retval;

	}
	// $ANTLR end "paramList"

	private sealed partial class paramDecl_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public paramDecl_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_paramDecl();
	partial void LeaveRule_paramDecl();

	// $ANTLR start "paramDecl"
	// LSL.g:208:1: paramDecl : TYPE ID -> ^( PARAM_DECL TYPE ID ) ;
	[GrammarRule("paramDecl")]
	private LSLParser.paramDecl_return paramDecl()
	{
		EnterRule_paramDecl();
		EnterRule("paramDecl", 16);
		TraceIn("paramDecl", 16);
		LSLParser.paramDecl_return retval = new LSLParser.paramDecl_return(this);
		retval.Start = (IToken)input.LT(1);
		int paramDecl_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken TYPE106 = default(IToken);
		IToken ID107 = default(IToken);

		LSLAst TYPE106_tree = default(LSLAst);
		LSLAst ID107_tree = default(LSLAst);
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "paramDecl");
		DebugLocation(208, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }
			// LSL.g:209:2: ( TYPE ID -> ^( PARAM_DECL TYPE ID ) )
			DebugEnterAlt(1);
			// LSL.g:209:4: TYPE ID
			{
			DebugLocation(209, 4);
			TYPE106=(IToken)Match(input,TYPE,Follow._TYPE_in_paramDecl1342); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE106);

			DebugLocation(209, 9);
			ID107=(IToken)Match(input,ID,Follow._ID_in_paramDecl1344); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID107);



			{
			// AST REWRITE
			// elements: TYPE, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 209:12: -> ^( PARAM_DECL TYPE ID )
			{
				DebugLocation(209, 15);
				// LSL.g:209:15: ^( PARAM_DECL TYPE ID )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(209, 17);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(PARAM_DECL, "PARAM_DECL"), root_1);

				DebugLocation(209, 28);
				adaptor.AddChild(root_1, stream_TYPE.NextNode());
				DebugLocation(209, 33);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("paramDecl", 16);
			LeaveRule("paramDecl", 16);
			LeaveRule_paramDecl();
			if (state.backtracking > 0) { Memoize(input, 16, paramDecl_StartIndex); }
		}
		DebugLocation(210, 1);
		} finally { DebugExitRule(GrammarFileName, "paramDecl"); }
		return retval;

	}
	// $ANTLR end "paramDecl"

	private sealed partial class varDecl_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public varDecl_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_varDecl();
	partial void LeaveRule_varDecl();

	// $ANTLR start "varDecl"
	// LSL.g:212:1: varDecl : TYPE ID ( '=' expression )? SEMI -> ^( VAR_DECL[$TYPE] TYPE ID ( expression )? ) ;
	[GrammarRule("varDecl")]
	private LSLParser.varDecl_return varDecl()
	{
		EnterRule_varDecl();
		EnterRule("varDecl", 17);
		TraceIn("varDecl", 17);
		LSLParser.varDecl_return retval = new LSLParser.varDecl_return(this);
		retval.Start = (IToken)input.LT(1);
		int varDecl_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken TYPE108 = default(IToken);
		IToken ID109 = default(IToken);
		IToken char_literal110 = default(IToken);
		IToken SEMI112 = default(IToken);
		LSLParser.expression_return expression111 = default(LSLParser.expression_return);

		LSLAst TYPE108_tree = default(LSLAst);
		LSLAst ID109_tree = default(LSLAst);
		LSLAst char_literal110_tree = default(LSLAst);
		LSLAst SEMI112_tree = default(LSLAst);
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN_EQ=new RewriteRuleITokenStream(adaptor,"token ASSIGN_EQ");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "varDecl");
		DebugLocation(212, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }
			// LSL.g:212:9: ( TYPE ID ( '=' expression )? SEMI -> ^( VAR_DECL[$TYPE] TYPE ID ( expression )? ) )
			DebugEnterAlt(1);
			// LSL.g:212:11: TYPE ID ( '=' expression )? SEMI
			{
			DebugLocation(212, 11);
			TYPE108=(IToken)Match(input,TYPE,Follow._TYPE_in_varDecl1365); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE108);

			DebugLocation(212, 16);
			ID109=(IToken)Match(input,ID,Follow._ID_in_varDecl1367); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID109);

			DebugLocation(212, 19);
			// LSL.g:212:19: ( '=' expression )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==ASSIGN_EQ))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:212:20: '=' expression
				{
				DebugLocation(212, 20);
				char_literal110=(IToken)Match(input,ASSIGN_EQ,Follow._ASSIGN_EQ_in_varDecl1370); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN_EQ.Add(char_literal110);

				DebugLocation(212, 24);
				PushFollow(Follow._expression_in_varDecl1372);
				expression111=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression111.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(212, 37);
			SEMI112=(IToken)Match(input,SEMI,Follow._SEMI_in_varDecl1376); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI112);



			{
			// AST REWRITE
			// elements: TYPE, ID, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 212:42: -> ^( VAR_DECL[$TYPE] TYPE ID ( expression )? )
			{
				DebugLocation(212, 45);
				// LSL.g:212:45: ^( VAR_DECL[$TYPE] TYPE ID ( expression )? )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(212, 47);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(VAR_DECL, TYPE108), root_1);

				DebugLocation(212, 63);
				adaptor.AddChild(root_1, stream_TYPE.NextNode());
				DebugLocation(212, 68);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(212, 71);
				// LSL.g:212:71: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(212, 71);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varDecl", 17);
			LeaveRule("varDecl", 17);
			LeaveRule_varDecl();
			if (state.backtracking > 0) { Memoize(input, 17, varDecl_StartIndex); }
		}
		DebugLocation(213, 1);
		} finally { DebugExitRule(GrammarFileName, "varDecl"); }
		return retval;

	}
	// $ANTLR end "varDecl"

	private sealed partial class callParamList_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public callParamList_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_callParamList();
	partial void LeaveRule_callParamList();

	// $ANTLR start "callParamList"
	// LSL.g:215:1: callParamList : ( expr ( ',' expr )* -> ^( ELIST ( expr )+ ) | -> ELIST );
	[GrammarRule("callParamList")]
	private LSLParser.callParamList_return callParamList()
	{
		EnterRule_callParamList();
		EnterRule("callParamList", 18);
		TraceIn("callParamList", 18);
		LSLParser.callParamList_return retval = new LSLParser.callParamList_return(this);
		retval.Start = (IToken)input.LT(1);
		int callParamList_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal114 = default(IToken);
		LSLParser.expr_return expr113 = default(LSLParser.expr_return);
		LSLParser.expr_return expr115 = default(LSLParser.expr_return);

		LSLAst char_literal114_tree = default(LSLAst);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "callParamList");
		DebugLocation(215, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }
			// LSL.g:216:2: ( expr ( ',' expr )* -> ^( ELIST ( expr )+ ) | -> ELIST )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==FLOAT_LITERAL||LA28_0==ID||LA28_0==INTEGER_LITERAL||(LA28_0>=LPAREN && LA28_0<=LT)||LA28_0==MINUS||LA28_0==STRING_LITERAL||LA28_0==55||LA28_0==64||LA28_0==66||LA28_0==79||LA28_0==95))
			{
				alt28 = 1;
			}
			else if ((LA28_0==RPAREN))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:216:4: expr ( ',' expr )*
				{
				DebugLocation(216, 4);
				PushFollow(Follow._expr_in_callParamList1402);
				expr113=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr113.Tree);
				DebugLocation(216, 9);
				// LSL.g:216:9: ( ',' expr )*
				try { DebugEnterSubRule(27);
				while (true)
				{
					int alt27=2;
					try { DebugEnterDecision(27, false);
					int LA27_0 = input.LA(1);

					if ((LA27_0==COMMA))
					{
						alt27 = 1;
					}


					} finally { DebugExitDecision(27); }
					switch ( alt27 )
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:216:10: ',' expr
						{
						DebugLocation(216, 10);
						char_literal114=(IToken)Match(input,COMMA,Follow._COMMA_in_callParamList1405); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(char_literal114);

						DebugLocation(216, 14);
						PushFollow(Follow._expr_in_callParamList1407);
						expr115=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr115.Tree);

						}
						break;

					default:
						goto loop27;
					}
				}

				loop27:
					;

				} finally { DebugExitSubRule(27); }



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 216:21: -> ^( ELIST ( expr )+ )
				{
					DebugLocation(216, 24);
					// LSL.g:216:24: ^( ELIST ( expr )+ )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(216, 26);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(ELIST, "ELIST"), root_1);

					DebugLocation(216, 32);
					if (!(stream_expr.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(216, 32);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:217:4: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 217:4: -> ELIST
				{
					DebugLocation(217, 7);
					adaptor.AddChild(root_0, (LSLAst)adaptor.Create(ELIST, "ELIST"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("callParamList", 18);
			LeaveRule("callParamList", 18);
			LeaveRule_callParamList();
			if (state.backtracking > 0) { Memoize(input, 18, callParamList_StartIndex); }
		}
		DebugLocation(218, 1);
		} finally { DebugExitRule(GrammarFileName, "callParamList"); }
		return retval;

	}
	// $ANTLR end "callParamList"

	private sealed partial class expression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public expression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// LSL.g:220:1: expression : expr -> ^( EXPR[$expr.start] expr ) ;
	[GrammarRule("expression")]
	private LSLParser.expression_return expression()
	{
		EnterRule_expression();
		EnterRule("expression", 19);
		TraceIn("expression", 19);
		LSLParser.expression_return retval = new LSLParser.expression_return(this);
		retval.Start = (IToken)input.LT(1);
		int expression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		LSLParser.expr_return expr116 = default(LSLParser.expr_return);

		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(220, 5);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }
			// LSL.g:221:6: ( expr -> ^( EXPR[$expr.start] expr ) )
			DebugEnterAlt(1);
			// LSL.g:221:8: expr
			{
			DebugLocation(221, 8);
			PushFollow(Follow._expr_in_expression1440);
			expr116=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr116.Tree);


			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 221:13: -> ^( EXPR[$expr.start] expr )
			{
				DebugLocation(221, 16);
				// LSL.g:221:16: ^( EXPR[$expr.start] expr )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(221, 18);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(EXPR, (expr116!=null?((IToken)expr116.Start):default(IToken))), root_1);

				DebugLocation(221, 36);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 19);
			LeaveRule("expression", 19);
			LeaveRule_expression();
			if (state.backtracking > 0) { Memoize(input, 19, expression_StartIndex); }
		}
		DebugLocation(222, 5);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	private sealed partial class expr_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public expr_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// LSL.g:224:1: expr : assignmentExpression ;
	[GrammarRule("expr")]
	private LSLParser.expr_return expr()
	{
		EnterRule_expr();
		EnterRule("expr", 20);
		TraceIn("expr", 20);
		LSLParser.expr_return retval = new LSLParser.expr_return(this);
		retval.Start = (IToken)input.LT(1);
		int expr_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		LSLParser.assignmentExpression_return assignmentExpression117 = default(LSLParser.assignmentExpression_return);


		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(224, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }
			// LSL.g:224:6: ( assignmentExpression )
			DebugEnterAlt(1);
			// LSL.g:224:8: assignmentExpression
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(224, 8);
			PushFollow(Follow._assignmentExpression_in_expr1463);
			assignmentExpression117=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression117.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 20);
			LeaveRule("expr", 20);
			LeaveRule_expr();
			if (state.backtracking > 0) { Memoize(input, 20, expr_StartIndex); }
		}
		DebugLocation(225, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	private sealed partial class assignmentExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public assignmentExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();

	// $ANTLR start "assignmentExpression"
	// LSL.g:227:1: assignmentExpression : booleanExpression ( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression )* ;
	[GrammarRule("assignmentExpression")]
	private LSLParser.assignmentExpression_return assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 21);
		TraceIn("assignmentExpression", 21);
		LSLParser.assignmentExpression_return retval = new LSLParser.assignmentExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int assignmentExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal119 = default(IToken);
		IToken string_literal120 = default(IToken);
		IToken string_literal121 = default(IToken);
		IToken string_literal122 = default(IToken);
		IToken string_literal123 = default(IToken);
		IToken string_literal124 = default(IToken);
		IToken string_literal125 = default(IToken);
		IToken string_literal126 = default(IToken);
		LSLParser.booleanExpression_return booleanExpression118 = default(LSLParser.booleanExpression_return);
		LSLParser.assignmentExpression_return assignmentExpression127 = default(LSLParser.assignmentExpression_return);

		LSLAst char_literal119_tree = default(LSLAst);
		LSLAst string_literal120_tree = default(LSLAst);
		LSLAst string_literal121_tree = default(LSLAst);
		LSLAst string_literal122_tree = default(LSLAst);
		LSLAst string_literal123_tree = default(LSLAst);
		LSLAst string_literal124_tree = default(LSLAst);
		LSLAst string_literal125_tree = default(LSLAst);
		LSLAst string_literal126_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(227, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }
			// LSL.g:228:2: ( booleanExpression ( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression )* )
			DebugEnterAlt(1);
			// LSL.g:228:4: booleanExpression ( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(228, 4);
			PushFollow(Follow._booleanExpression_in_assignmentExpression1475);
			booleanExpression118=booleanExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, booleanExpression118.Tree);
			DebugLocation(228, 22);
			// LSL.g:228:22: ( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				try
				{
					alt30 = dfa30.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:228:23: ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression
					{
					DebugLocation(228, 23);
					// LSL.g:228:23: ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' )
					int alt29=8;
					try { DebugEnterSubRule(29);
					try { DebugEnterDecision(29, false);
					switch (input.LA(1))
					{
					case ASSIGN_EQ:
						{
						alt29 = 1;
						}
						break;
					case 65:
						{
						alt29 = 2;
						}
						break;
					case 67:
						{
						alt29 = 3;
						}
						break;
					case 62:
						{
						alt29 = 4;
						}
						break;
					case 70:
						{
						alt29 = 5;
						}
						break;
					case 58:
						{
						alt29 = 6;
						}
						break;
					case 72:
						{
						alt29 = 7;
						}
						break;
					case 77:
						{
						alt29 = 8;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(29); }
					switch (alt29)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:228:24: '='
						{
						DebugLocation(228, 27);
						char_literal119=(IToken)Match(input,ASSIGN_EQ,Follow._ASSIGN_EQ_in_assignmentExpression1479); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal119_tree = (LSLAst)adaptor.Create(char_literal119);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal119_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:228:31: '+='
						{
						DebugLocation(228, 35);
						string_literal120=(IToken)Match(input,65,Follow._65_in_assignmentExpression1484); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal120_tree = (LSLAst)adaptor.Create(string_literal120);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal120_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// LSL.g:228:39: '-='
						{
						DebugLocation(228, 43);
						string_literal121=(IToken)Match(input,67,Follow._67_in_assignmentExpression1489); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal121_tree = (LSLAst)adaptor.Create(string_literal121);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal121_tree, root_0);
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// LSL.g:228:47: '*='
						{
						DebugLocation(228, 51);
						string_literal122=(IToken)Match(input,62,Follow._62_in_assignmentExpression1494); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal122_tree = (LSLAst)adaptor.Create(string_literal122);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal122_tree, root_0);
						}

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// LSL.g:228:55: '/='
						{
						DebugLocation(228, 59);
						string_literal123=(IToken)Match(input,70,Follow._70_in_assignmentExpression1499); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal123_tree = (LSLAst)adaptor.Create(string_literal123);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal123_tree, root_0);
						}

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// LSL.g:228:63: '%='
						{
						DebugLocation(228, 67);
						string_literal124=(IToken)Match(input,58,Follow._58_in_assignmentExpression1504); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal124_tree = (LSLAst)adaptor.Create(string_literal124);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal124_tree, root_0);
						}

						}
						break;
					case 7:
						DebugEnterAlt(7);
						// LSL.g:228:71: '<<='
						{
						DebugLocation(228, 76);
						string_literal125=(IToken)Match(input,72,Follow._72_in_assignmentExpression1509); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal125_tree = (LSLAst)adaptor.Create(string_literal125);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal125_tree, root_0);
						}

						}
						break;
					case 8:
						DebugEnterAlt(8);
						// LSL.g:228:80: '>>='
						{
						DebugLocation(228, 85);
						string_literal126=(IToken)Match(input,77,Follow._77_in_assignmentExpression1514); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal126_tree = (LSLAst)adaptor.Create(string_literal126);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal126_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(29); }

					DebugLocation(228, 88);
					PushFollow(Follow._assignmentExpression_in_assignmentExpression1518);
					assignmentExpression127=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression127.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpression", 21);
			LeaveRule("assignmentExpression", 21);
			LeaveRule_assignmentExpression();
			if (state.backtracking > 0) { Memoize(input, 21, assignmentExpression_StartIndex); }
		}
		DebugLocation(229, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	private sealed partial class booleanExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public booleanExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_booleanExpression();
	partial void LeaveRule_booleanExpression();

	// $ANTLR start "booleanExpression"
	// LSL.g:231:1: booleanExpression : bitwiseExpression ( ( '||' | '&&' ) bitwiseExpression )* ;
	[GrammarRule("booleanExpression")]
	private LSLParser.booleanExpression_return booleanExpression()
	{
		EnterRule_booleanExpression();
		EnterRule("booleanExpression", 22);
		TraceIn("booleanExpression", 22);
		LSLParser.booleanExpression_return retval = new LSLParser.booleanExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int booleanExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken string_literal129 = default(IToken);
		IToken string_literal130 = default(IToken);
		LSLParser.bitwiseExpression_return bitwiseExpression128 = default(LSLParser.bitwiseExpression_return);
		LSLParser.bitwiseExpression_return bitwiseExpression131 = default(LSLParser.bitwiseExpression_return);

		LSLAst string_literal129_tree = default(LSLAst);
		LSLAst string_literal130_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "booleanExpression");
		DebugLocation(231, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }
			// LSL.g:232:2: ( bitwiseExpression ( ( '||' | '&&' ) bitwiseExpression )* )
			DebugEnterAlt(1);
			// LSL.g:232:4: bitwiseExpression ( ( '||' | '&&' ) bitwiseExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(232, 4);
			PushFollow(Follow._bitwiseExpression_in_booleanExpression1532);
			bitwiseExpression128=bitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseExpression128.Tree);
			DebugLocation(232, 22);
			// LSL.g:232:22: ( ( '||' | '&&' ) bitwiseExpression )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_0 = input.LA(1);

				if ((LA32_0==59||LA32_0==93))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:232:23: ( '||' | '&&' ) bitwiseExpression
					{
					DebugLocation(232, 23);
					// LSL.g:232:23: ( '||' | '&&' )
					int alt31=2;
					try { DebugEnterSubRule(31);
					try { DebugEnterDecision(31, false);
					int LA31_0 = input.LA(1);

					if ((LA31_0==93))
					{
						alt31 = 1;
					}
					else if ((LA31_0==59))
					{
						alt31 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(31); }
					switch (alt31)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:232:24: '||'
						{
						DebugLocation(232, 28);
						string_literal129=(IToken)Match(input,93,Follow._93_in_booleanExpression1536); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal129_tree = (LSLAst)adaptor.Create(string_literal129);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal129_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:232:32: '&&'
						{
						DebugLocation(232, 36);
						string_literal130=(IToken)Match(input,59,Follow._59_in_booleanExpression1541); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal130_tree = (LSLAst)adaptor.Create(string_literal130);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal130_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(31); }

					DebugLocation(232, 39);
					PushFollow(Follow._bitwiseExpression_in_booleanExpression1545);
					bitwiseExpression131=bitwiseExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseExpression131.Tree);

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanExpression", 22);
			LeaveRule("booleanExpression", 22);
			LeaveRule_booleanExpression();
			if (state.backtracking > 0) { Memoize(input, 22, booleanExpression_StartIndex); }
		}
		DebugLocation(233, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanExpression"); }
		return retval;

	}
	// $ANTLR end "booleanExpression"

	private sealed partial class bitwiseExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public bitwiseExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_bitwiseExpression();
	partial void LeaveRule_bitwiseExpression();

	// $ANTLR start "bitwiseExpression"
	// LSL.g:235:1: bitwiseExpression : equalityExpression ( ( '|' | '&' | '^' ) equalityExpression )* ;
	[GrammarRule("bitwiseExpression")]
	private LSLParser.bitwiseExpression_return bitwiseExpression()
	{
		EnterRule_bitwiseExpression();
		EnterRule("bitwiseExpression", 23);
		TraceIn("bitwiseExpression", 23);
		LSLParser.bitwiseExpression_return retval = new LSLParser.bitwiseExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int bitwiseExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal133 = default(IToken);
		IToken char_literal134 = default(IToken);
		IToken char_literal135 = default(IToken);
		LSLParser.equalityExpression_return equalityExpression132 = default(LSLParser.equalityExpression_return);
		LSLParser.equalityExpression_return equalityExpression136 = default(LSLParser.equalityExpression_return);

		LSLAst char_literal133_tree = default(LSLAst);
		LSLAst char_literal134_tree = default(LSLAst);
		LSLAst char_literal135_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "bitwiseExpression");
		DebugLocation(235, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return retval; }
			// LSL.g:236:2: ( equalityExpression ( ( '|' | '&' | '^' ) equalityExpression )* )
			DebugEnterAlt(1);
			// LSL.g:236:4: equalityExpression ( ( '|' | '&' | '^' ) equalityExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(236, 4);
			PushFollow(Follow._equalityExpression_in_bitwiseExpression1558);
			equalityExpression132=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression132.Tree);
			DebugLocation(236, 23);
			// LSL.g:236:23: ( ( '|' | '&' | '^' ) equalityExpression )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_0 = input.LA(1);

				if ((LA34_0==60||LA34_0==81||LA34_0==92))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:236:24: ( '|' | '&' | '^' ) equalityExpression
					{
					DebugLocation(236, 24);
					// LSL.g:236:24: ( '|' | '&' | '^' )
					int alt33=3;
					try { DebugEnterSubRule(33);
					try { DebugEnterDecision(33, false);
					switch (input.LA(1))
					{
					case 92:
						{
						alt33 = 1;
						}
						break;
					case 60:
						{
						alt33 = 2;
						}
						break;
					case 81:
						{
						alt33 = 3;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(33); }
					switch (alt33)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:236:25: '|'
						{
						DebugLocation(236, 28);
						char_literal133=(IToken)Match(input,92,Follow._92_in_bitwiseExpression1562); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal133_tree = (LSLAst)adaptor.Create(char_literal133);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal133_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:236:32: '&'
						{
						DebugLocation(236, 35);
						char_literal134=(IToken)Match(input,60,Follow._60_in_bitwiseExpression1567); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal134_tree = (LSLAst)adaptor.Create(char_literal134);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal134_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// LSL.g:236:39: '^'
						{
						DebugLocation(236, 42);
						char_literal135=(IToken)Match(input,81,Follow._81_in_bitwiseExpression1572); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal135_tree = (LSLAst)adaptor.Create(char_literal135);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal135_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(33); }

					DebugLocation(236, 45);
					PushFollow(Follow._equalityExpression_in_bitwiseExpression1576);
					equalityExpression136=equalityExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression136.Tree);

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseExpression", 23);
			LeaveRule("bitwiseExpression", 23);
			LeaveRule_bitwiseExpression();
			if (state.backtracking > 0) { Memoize(input, 23, bitwiseExpression_StartIndex); }
		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseExpression"

	private sealed partial class equalityExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public equalityExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();

	// $ANTLR start "equalityExpression"
	// LSL.g:239:1: equalityExpression : relationalExpression ( ( '!=' | '==' ) relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private LSLParser.equalityExpression_return equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 24);
		TraceIn("equalityExpression", 24);
		LSLParser.equalityExpression_return retval = new LSLParser.equalityExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int equalityExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken string_literal138 = default(IToken);
		IToken string_literal139 = default(IToken);
		LSLParser.relationalExpression_return relationalExpression137 = default(LSLParser.relationalExpression_return);
		LSLParser.relationalExpression_return relationalExpression140 = default(LSLParser.relationalExpression_return);

		LSLAst string_literal138_tree = default(LSLAst);
		LSLAst string_literal139_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(239, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return retval; }
			// LSL.g:240:2: ( relationalExpression ( ( '!=' | '==' ) relationalExpression )* )
			DebugEnterAlt(1);
			// LSL.g:240:4: relationalExpression ( ( '!=' | '==' ) relationalExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(240, 4);
			PushFollow(Follow._relationalExpression_in_equalityExpression1591);
			relationalExpression137=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression137.Tree);
			DebugLocation(240, 25);
			// LSL.g:240:25: ( ( '!=' | '==' ) relationalExpression )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_0 = input.LA(1);

				if ((LA36_0==56||LA36_0==74))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:240:26: ( '!=' | '==' ) relationalExpression
					{
					DebugLocation(240, 26);
					// LSL.g:240:26: ( '!=' | '==' )
					int alt35=2;
					try { DebugEnterSubRule(35);
					try { DebugEnterDecision(35, false);
					int LA35_0 = input.LA(1);

					if ((LA35_0==56))
					{
						alt35 = 1;
					}
					else if ((LA35_0==74))
					{
						alt35 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(35); }
					switch (alt35)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:240:27: '!='
						{
						DebugLocation(240, 31);
						string_literal138=(IToken)Match(input,56,Follow._56_in_equalityExpression1595); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal138_tree = (LSLAst)adaptor.Create(string_literal138);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal138_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:240:35: '=='
						{
						DebugLocation(240, 39);
						string_literal139=(IToken)Match(input,74,Follow._74_in_equalityExpression1600); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal139_tree = (LSLAst)adaptor.Create(string_literal139);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal139_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(35); }

					DebugLocation(240, 42);
					PushFollow(Follow._relationalExpression_in_equalityExpression1604);
					relationalExpression140=relationalExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression140.Tree);

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 24);
			LeaveRule("equalityExpression", 24);
			LeaveRule_equalityExpression();
			if (state.backtracking > 0) { Memoize(input, 24, equalityExpression_StartIndex); }
		}
		DebugLocation(241, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	private sealed partial class relationalExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public relationalExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();

	// $ANTLR start "relationalExpression"
	// LSL.g:243:1: relationalExpression : binaryBitwiseExpression ( ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression )* ;
	[GrammarRule("relationalExpression")]
	private LSLParser.relationalExpression_return relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 25);
		TraceIn("relationalExpression", 25);
		LSLParser.relationalExpression_return retval = new LSLParser.relationalExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int relationalExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal142 = default(IToken);
		IToken char_literal143 = default(IToken);
		IToken string_literal144 = default(IToken);
		IToken string_literal145 = default(IToken);
		LSLParser.binaryBitwiseExpression_return binaryBitwiseExpression141 = default(LSLParser.binaryBitwiseExpression_return);
		LSLParser.binaryBitwiseExpression_return binaryBitwiseExpression146 = default(LSLParser.binaryBitwiseExpression_return);

		LSLAst char_literal142_tree = default(LSLAst);
		LSLAst char_literal143_tree = default(LSLAst);
		LSLAst string_literal144_tree = default(LSLAst);
		LSLAst string_literal145_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(243, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return retval; }
			// LSL.g:244:2: ( binaryBitwiseExpression ( ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression )* )
			DebugEnterAlt(1);
			// LSL.g:244:4: binaryBitwiseExpression ( ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(244, 4);
			PushFollow(Follow._binaryBitwiseExpression_in_relationalExpression1617);
			binaryBitwiseExpression141=binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, binaryBitwiseExpression141.Tree);
			DebugLocation(244, 28);
			// LSL.g:244:28: ( ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression )*
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				try
				{
					alt38 = dfa38.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(38); }
				switch ( alt38 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:244:29: ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression
					{
					DebugLocation(244, 29);
					// LSL.g:244:29: ( '<' |{...}? => '>' | '<=' |{...}? => '>=' )
					int alt37=4;
					try { DebugEnterSubRule(37);
					try { DebugEnterDecision(37, false);
					int LA37_0 = input.LA(1);

					if ((LA37_0==LT))
					{
						alt37 = 1;
					}
					else if ((LA37_0==GT) && ((GTNotDisabled())))
					{
						alt37 = 2;
					}
					else if ((LA37_0==73))
					{
						alt37 = 3;
					}
					else if ((LA37_0==75) && ((GTNotDisabled())))
					{
						alt37 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(37); }
					switch (alt37)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:244:30: '<'
						{
						DebugLocation(244, 33);
						char_literal142=(IToken)Match(input,LT,Follow._LT_in_relationalExpression1621); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal142_tree = (LSLAst)adaptor.Create(char_literal142);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal142_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:244:37: {...}? => '>'
						{
						DebugLocation(244, 37);
						if (!((GTNotDisabled())))
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							throw new FailedPredicateException(input, "relationalExpression", "GTNotDisabled()");
						}
						DebugLocation(244, 62);
						char_literal143=(IToken)Match(input,GT,Follow._GT_in_relationalExpression1630); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal143_tree = (LSLAst)adaptor.Create(char_literal143);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal143_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// LSL.g:244:66: '<='
						{
						DebugLocation(244, 70);
						string_literal144=(IToken)Match(input,73,Follow._73_in_relationalExpression1635); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal144_tree = (LSLAst)adaptor.Create(string_literal144);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal144_tree, root_0);
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// LSL.g:244:74: {...}? => '>='
						{
						DebugLocation(244, 74);
						if (!((GTNotDisabled())))
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							throw new FailedPredicateException(input, "relationalExpression", "GTNotDisabled()");
						}
						DebugLocation(244, 100);
						string_literal145=(IToken)Match(input,75,Follow._75_in_relationalExpression1644); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal145_tree = (LSLAst)adaptor.Create(string_literal145);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal145_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(37); }

					DebugLocation(244, 103);
					if (!((IsNotVector())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "relationalExpression", "IsNotVector()");
					}
					DebugLocation(244, 120);
					PushFollow(Follow._binaryBitwiseExpression_in_relationalExpression1650);
					binaryBitwiseExpression146=binaryBitwiseExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, binaryBitwiseExpression146.Tree);

					}
					break;

				default:
					goto loop38;
				}
			}

			loop38:
				;

			} finally { DebugExitSubRule(38); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 25);
			LeaveRule("relationalExpression", 25);
			LeaveRule_relationalExpression();
			if (state.backtracking > 0) { Memoize(input, 25, relationalExpression_StartIndex); }
		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	private sealed partial class binaryBitwiseExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public binaryBitwiseExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_binaryBitwiseExpression();
	partial void LeaveRule_binaryBitwiseExpression();

	// $ANTLR start "binaryBitwiseExpression"
	// LSL.g:247:1: binaryBitwiseExpression : additiveExpression ( ( '<<' | '>>' ) additiveExpression )* ;
	[GrammarRule("binaryBitwiseExpression")]
	private LSLParser.binaryBitwiseExpression_return binaryBitwiseExpression()
	{
		EnterRule_binaryBitwiseExpression();
		EnterRule("binaryBitwiseExpression", 26);
		TraceIn("binaryBitwiseExpression", 26);
		LSLParser.binaryBitwiseExpression_return retval = new LSLParser.binaryBitwiseExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int binaryBitwiseExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken string_literal148 = default(IToken);
		IToken string_literal149 = default(IToken);
		LSLParser.additiveExpression_return additiveExpression147 = default(LSLParser.additiveExpression_return);
		LSLParser.additiveExpression_return additiveExpression150 = default(LSLParser.additiveExpression_return);

		LSLAst string_literal148_tree = default(LSLAst);
		LSLAst string_literal149_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "binaryBitwiseExpression");
		DebugLocation(247, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return retval; }
			// LSL.g:248:2: ( additiveExpression ( ( '<<' | '>>' ) additiveExpression )* )
			DebugEnterAlt(1);
			// LSL.g:248:4: additiveExpression ( ( '<<' | '>>' ) additiveExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(248, 4);
			PushFollow(Follow._additiveExpression_in_binaryBitwiseExpression1663);
			additiveExpression147=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression147.Tree);
			DebugLocation(248, 23);
			// LSL.g:248:23: ( ( '<<' | '>>' ) additiveExpression )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_0 = input.LA(1);

				if ((LA40_0==71||LA40_0==76))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:248:24: ( '<<' | '>>' ) additiveExpression
					{
					DebugLocation(248, 24);
					// LSL.g:248:24: ( '<<' | '>>' )
					int alt39=2;
					try { DebugEnterSubRule(39);
					try { DebugEnterDecision(39, false);
					int LA39_0 = input.LA(1);

					if ((LA39_0==71))
					{
						alt39 = 1;
					}
					else if ((LA39_0==76))
					{
						alt39 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 39, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(39); }
					switch (alt39)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:248:25: '<<'
						{
						DebugLocation(248, 29);
						string_literal148=(IToken)Match(input,71,Follow._71_in_binaryBitwiseExpression1667); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal148_tree = (LSLAst)adaptor.Create(string_literal148);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal148_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:248:33: '>>'
						{
						DebugLocation(248, 37);
						string_literal149=(IToken)Match(input,76,Follow._76_in_binaryBitwiseExpression1672); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal149_tree = (LSLAst)adaptor.Create(string_literal149);
						root_0 = (LSLAst)adaptor.BecomeRoot(string_literal149_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(39); }

					DebugLocation(248, 40);
					PushFollow(Follow._additiveExpression_in_binaryBitwiseExpression1676);
					additiveExpression150=additiveExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression150.Tree);

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binaryBitwiseExpression", 26);
			LeaveRule("binaryBitwiseExpression", 26);
			LeaveRule_binaryBitwiseExpression();
			if (state.backtracking > 0) { Memoize(input, 26, binaryBitwiseExpression_StartIndex); }
		}
		DebugLocation(249, 1);
		} finally { DebugExitRule(GrammarFileName, "binaryBitwiseExpression"); }
		return retval;

	}
	// $ANTLR end "binaryBitwiseExpression"

	private sealed partial class additiveExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public additiveExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// LSL.g:251:1: additiveExpression : multiplicativeExpression ( ( '+' | '-' ) multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private LSLParser.additiveExpression_return additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 27);
		TraceIn("additiveExpression", 27);
		LSLParser.additiveExpression_return retval = new LSLParser.additiveExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int additiveExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal152 = default(IToken);
		IToken char_literal153 = default(IToken);
		LSLParser.multiplicativeExpression_return multiplicativeExpression151 = default(LSLParser.multiplicativeExpression_return);
		LSLParser.multiplicativeExpression_return multiplicativeExpression154 = default(LSLParser.multiplicativeExpression_return);

		LSLAst char_literal152_tree = default(LSLAst);
		LSLAst char_literal153_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(251, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return retval; }
			// LSL.g:252:2: ( multiplicativeExpression ( ( '+' | '-' ) multiplicativeExpression )* )
			DebugEnterAlt(1);
			// LSL.g:252:4: multiplicativeExpression ( ( '+' | '-' ) multiplicativeExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(252, 4);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression1689);
			multiplicativeExpression151=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression151.Tree);
			DebugLocation(252, 29);
			// LSL.g:252:29: ( ( '+' | '-' ) multiplicativeExpression )*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_0 = input.LA(1);

				if ((LA42_0==MINUS||LA42_0==63))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:252:30: ( '+' | '-' ) multiplicativeExpression
					{
					DebugLocation(252, 30);
					// LSL.g:252:30: ( '+' | '-' )
					int alt41=2;
					try { DebugEnterSubRule(41);
					try { DebugEnterDecision(41, false);
					int LA41_0 = input.LA(1);

					if ((LA41_0==63))
					{
						alt41 = 1;
					}
					else if ((LA41_0==MINUS))
					{
						alt41 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 41, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(41); }
					switch (alt41)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:252:31: '+'
						{
						DebugLocation(252, 34);
						char_literal152=(IToken)Match(input,63,Follow._63_in_additiveExpression1693); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal152_tree = (LSLAst)adaptor.Create(char_literal152);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal152_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:252:38: '-'
						{
						DebugLocation(252, 41);
						char_literal153=(IToken)Match(input,MINUS,Follow._MINUS_in_additiveExpression1698); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal153_tree = (LSLAst)adaptor.Create(char_literal153);
						root_0 = (LSLAst)adaptor.BecomeRoot(char_literal153_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(41); }

					DebugLocation(252, 44);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression1702);
					multiplicativeExpression154=multiplicativeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression154.Tree);

					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 27);
			LeaveRule("additiveExpression", 27);
			LeaveRule_additiveExpression();
			if (state.backtracking > 0) { Memoize(input, 27, additiveExpression_StartIndex); }
		}
		DebugLocation(253, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	private sealed partial class multiplicativeExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public multiplicativeExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// LSL.g:255:1: multiplicativeExpression : ( unaryExpression ) ( '*' unaryExpression | '/' unaryExpression | '%' unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private LSLParser.multiplicativeExpression_return multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 28);
		TraceIn("multiplicativeExpression", 28);
		LSLParser.multiplicativeExpression_return retval = new LSLParser.multiplicativeExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int multiplicativeExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal156 = default(IToken);
		IToken char_literal158 = default(IToken);
		IToken char_literal160 = default(IToken);
		LSLParser.unaryExpression_return unaryExpression155 = default(LSLParser.unaryExpression_return);
		LSLParser.unaryExpression_return unaryExpression157 = default(LSLParser.unaryExpression_return);
		LSLParser.unaryExpression_return unaryExpression159 = default(LSLParser.unaryExpression_return);
		LSLParser.unaryExpression_return unaryExpression161 = default(LSLParser.unaryExpression_return);

		LSLAst char_literal156_tree = default(LSLAst);
		LSLAst char_literal158_tree = default(LSLAst);
		LSLAst char_literal160_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(255, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return retval; }
			// LSL.g:256:2: ( ( unaryExpression ) ( '*' unaryExpression | '/' unaryExpression | '%' unaryExpression )* )
			DebugEnterAlt(1);
			// LSL.g:256:4: ( unaryExpression ) ( '*' unaryExpression | '/' unaryExpression | '%' unaryExpression )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(256, 4);
			// LSL.g:256:4: ( unaryExpression )
			DebugEnterAlt(1);
			// LSL.g:256:5: unaryExpression
			{
			DebugLocation(256, 5);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression1716);
			unaryExpression155=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression155.Tree);

			}

			DebugLocation(256, 22);
			// LSL.g:256:22: ( '*' unaryExpression | '/' unaryExpression | '%' unaryExpression )*
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=4;
				try { DebugEnterDecision(43, false);
				switch (input.LA(1))
				{
				case 61:
					{
					alt43 = 1;
					}
					break;
				case 69:
					{
					alt43 = 2;
					}
					break;
				case 57:
					{
					alt43 = 3;
					}
					break;

				}

				} finally { DebugExitDecision(43); }
				switch ( alt43 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:256:23: '*' unaryExpression
					{
					DebugLocation(256, 26);
					char_literal156=(IToken)Match(input,61,Follow._61_in_multiplicativeExpression1720); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal156_tree = (LSLAst)adaptor.Create(char_literal156);
					root_0 = (LSLAst)adaptor.BecomeRoot(char_literal156_tree, root_0);
					}
					DebugLocation(256, 28);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression1723);
					unaryExpression157=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression157.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// LSL.g:256:46: '/' unaryExpression
					{
					DebugLocation(256, 49);
					char_literal158=(IToken)Match(input,69,Follow._69_in_multiplicativeExpression1727); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal158_tree = (LSLAst)adaptor.Create(char_literal158);
					root_0 = (LSLAst)adaptor.BecomeRoot(char_literal158_tree, root_0);
					}
					DebugLocation(256, 51);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression1730);
					unaryExpression159=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression159.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// LSL.g:256:69: '%' unaryExpression
					{
					DebugLocation(256, 72);
					char_literal160=(IToken)Match(input,57,Follow._57_in_multiplicativeExpression1734); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal160_tree = (LSLAst)adaptor.Create(char_literal160);
					root_0 = (LSLAst)adaptor.BecomeRoot(char_literal160_tree, root_0);
					}
					DebugLocation(256, 74);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression1737);
					unaryExpression161=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression161.Tree);

					}
					break;

				default:
					goto loop43;
				}
			}

			loop43:
				;

			} finally { DebugExitSubRule(43); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 28);
			LeaveRule("multiplicativeExpression", 28);
			LeaveRule_multiplicativeExpression();
			if (state.backtracking > 0) { Memoize(input, 28, multiplicativeExpression_StartIndex); }
		}
		DebugLocation(257, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	private sealed partial class unaryExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public unaryExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();

	// $ANTLR start "unaryExpression"
	// LSL.g:259:1: unaryExpression : (op= '-' unaryExpression -> ^( UNARY_MINUS[$op] unaryExpression ) |op= '!' unaryExpression -> ^( UNARY_BOOL_NOT[$op] unaryExpression ) |op= '~' unaryExpression -> ^( UNARY_BIT_NOT[$op] unaryExpression ) | typeCastExpression );
	[GrammarRule("unaryExpression")]
	private LSLParser.unaryExpression_return unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 29);
		TraceIn("unaryExpression", 29);
		LSLParser.unaryExpression_return retval = new LSLParser.unaryExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int unaryExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken op = default(IToken);
		LSLParser.unaryExpression_return unaryExpression162 = default(LSLParser.unaryExpression_return);
		LSLParser.unaryExpression_return unaryExpression163 = default(LSLParser.unaryExpression_return);
		LSLParser.unaryExpression_return unaryExpression164 = default(LSLParser.unaryExpression_return);
		LSLParser.typeCastExpression_return typeCastExpression165 = default(LSLParser.typeCastExpression_return);

		LSLAst op_tree = default(LSLAst);
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_95=new RewriteRuleITokenStream(adaptor,"token 95");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(259, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return retval; }
			// LSL.g:260:2: (op= '-' unaryExpression -> ^( UNARY_MINUS[$op] unaryExpression ) |op= '!' unaryExpression -> ^( UNARY_BOOL_NOT[$op] unaryExpression ) |op= '~' unaryExpression -> ^( UNARY_BIT_NOT[$op] unaryExpression ) | typeCastExpression )
			int alt44=4;
			try { DebugEnterDecision(44, false);
			switch (input.LA(1))
			{
			case MINUS:
				{
				alt44 = 1;
				}
				break;
			case 55:
				{
				alt44 = 2;
				}
				break;
			case 95:
				{
				alt44 = 3;
				}
				break;
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LPAREN:
			case LT:
			case STRING_LITERAL:
			case 64:
			case 66:
			case 79:
				{
				alt44 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 44, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:261:3: op= '-' unaryExpression
				{
				DebugLocation(261, 5);
				op=(IToken)Match(input,MINUS,Follow._MINUS_in_unaryExpression1755); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(op);

				DebugLocation(261, 10);
				PushFollow(Follow._unaryExpression_in_unaryExpression1757);
				unaryExpression162=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression162.Tree);


				{
				// AST REWRITE
				// elements: unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 261:26: -> ^( UNARY_MINUS[$op] unaryExpression )
				{
					DebugLocation(261, 29);
					// LSL.g:261:29: ^( UNARY_MINUS[$op] unaryExpression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(261, 31);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(UNARY_MINUS, op), root_1);

					DebugLocation(261, 48);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:262:4: op= '!' unaryExpression
				{
				DebugLocation(262, 6);
				op=(IToken)Match(input,55,Follow._55_in_unaryExpression1773); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_55.Add(op);

				DebugLocation(262, 11);
				PushFollow(Follow._unaryExpression_in_unaryExpression1775);
				unaryExpression163=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression163.Tree);


				{
				// AST REWRITE
				// elements: unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 262:27: -> ^( UNARY_BOOL_NOT[$op] unaryExpression )
				{
					DebugLocation(262, 30);
					// LSL.g:262:30: ^( UNARY_BOOL_NOT[$op] unaryExpression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(262, 32);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(UNARY_BOOL_NOT, op), root_1);

					DebugLocation(262, 52);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// LSL.g:263:4: op= '~' unaryExpression
				{
				DebugLocation(263, 6);
				op=(IToken)Match(input,95,Follow._95_in_unaryExpression1791); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_95.Add(op);

				DebugLocation(263, 11);
				PushFollow(Follow._unaryExpression_in_unaryExpression1793);
				unaryExpression164=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression164.Tree);


				{
				// AST REWRITE
				// elements: unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 263:27: -> ^( UNARY_BIT_NOT[$op] unaryExpression )
				{
					DebugLocation(263, 30);
					// LSL.g:263:30: ^( UNARY_BIT_NOT[$op] unaryExpression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(263, 32);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(UNARY_BIT_NOT, op), root_1);

					DebugLocation(263, 51);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// LSL.g:264:4: typeCastExpression
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(264, 4);
				PushFollow(Follow._typeCastExpression_in_unaryExpression1807);
				typeCastExpression165=typeCastExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeCastExpression165.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 29);
			LeaveRule("unaryExpression", 29);
			LeaveRule_unaryExpression();
			if (state.backtracking > 0) { Memoize(input, 29, unaryExpression_StartIndex); }
		}
		DebugLocation(265, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	private sealed partial class typeCastExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public typeCastExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_typeCastExpression();
	partial void LeaveRule_typeCastExpression();

	// $ANTLR start "typeCastExpression"
	// LSL.g:267:1: typeCastExpression : ( LPAREN TYPE RPAREN unaryExpression -> ^( TYPE_CAST TYPE unaryExpression ) | preIncDecExpression );
	[GrammarRule("typeCastExpression")]
	private LSLParser.typeCastExpression_return typeCastExpression()
	{
		EnterRule_typeCastExpression();
		EnterRule("typeCastExpression", 30);
		TraceIn("typeCastExpression", 30);
		LSLParser.typeCastExpression_return retval = new LSLParser.typeCastExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int typeCastExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken LPAREN166 = default(IToken);
		IToken TYPE167 = default(IToken);
		IToken RPAREN168 = default(IToken);
		LSLParser.unaryExpression_return unaryExpression169 = default(LSLParser.unaryExpression_return);
		LSLParser.preIncDecExpression_return preIncDecExpression170 = default(LSLParser.preIncDecExpression_return);

		LSLAst LPAREN166_tree = default(LSLAst);
		LSLAst TYPE167_tree = default(LSLAst);
		LSLAst RPAREN168_tree = default(LSLAst);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "typeCastExpression");
		DebugLocation(267, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return retval; }
			// LSL.g:268:2: ( LPAREN TYPE RPAREN unaryExpression -> ^( TYPE_CAST TYPE unaryExpression ) | preIncDecExpression )
			int alt45=2;
			try { DebugEnterDecision(45, false);
			int LA45_0 = input.LA(1);

			if ((LA45_0==LPAREN))
			{
				int LA45_1 = input.LA(2);

				if ((LA45_1==TYPE))
				{
					alt45 = 1;
				}
				else if ((LA45_1==FLOAT_LITERAL||LA45_1==ID||LA45_1==INTEGER_LITERAL||(LA45_1>=LPAREN && LA45_1<=LT)||LA45_1==MINUS||LA45_1==STRING_LITERAL||LA45_1==55||LA45_1==64||LA45_1==66||LA45_1==79||LA45_1==95))
				{
					alt45 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 45, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA45_0==FLOAT_LITERAL||LA45_0==ID||LA45_0==INTEGER_LITERAL||LA45_0==LT||LA45_0==STRING_LITERAL||LA45_0==64||LA45_0==66||LA45_0==79))
			{
				alt45 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 45, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:268:4: LPAREN TYPE RPAREN unaryExpression
				{
				DebugLocation(268, 4);
				LPAREN166=(IToken)Match(input,LPAREN,Follow._LPAREN_in_typeCastExpression1818); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN166);

				DebugLocation(268, 11);
				TYPE167=(IToken)Match(input,TYPE,Follow._TYPE_in_typeCastExpression1820); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TYPE.Add(TYPE167);

				DebugLocation(268, 16);
				RPAREN168=(IToken)Match(input,RPAREN,Follow._RPAREN_in_typeCastExpression1822); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN168);

				DebugLocation(268, 23);
				PushFollow(Follow._unaryExpression_in_typeCastExpression1824);
				unaryExpression169=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression169.Tree);


				{
				// AST REWRITE
				// elements: TYPE, unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 268:39: -> ^( TYPE_CAST TYPE unaryExpression )
				{
					DebugLocation(268, 42);
					// LSL.g:268:42: ^( TYPE_CAST TYPE unaryExpression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(268, 44);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(TYPE_CAST, "TYPE_CAST"), root_1);

					DebugLocation(268, 54);
					adaptor.AddChild(root_1, stream_TYPE.NextNode());
					DebugLocation(268, 59);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:269:4: preIncDecExpression
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(269, 4);
				PushFollow(Follow._preIncDecExpression_in_typeCastExpression1839);
				preIncDecExpression170=preIncDecExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, preIncDecExpression170.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeCastExpression", 30);
			LeaveRule("typeCastExpression", 30);
			LeaveRule_typeCastExpression();
			if (state.backtracking > 0) { Memoize(input, 30, typeCastExpression_StartIndex); }
		}
		DebugLocation(270, 1);
		} finally { DebugExitRule(GrammarFileName, "typeCastExpression"); }
		return retval;

	}
	// $ANTLR end "typeCastExpression"

	private sealed partial class preIncDecExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public preIncDecExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_preIncDecExpression();
	partial void LeaveRule_preIncDecExpression();

	// $ANTLR start "preIncDecExpression"
	// LSL.g:272:1: preIncDecExpression : (op= '++' postfixExpression -> ^( PRE_INCREMENT[$op] postfixExpression ) |op= '--' postfixExpression -> ^( PRE_DECREMENT[$op] postfixExpression ) | postfixExpression );
	[GrammarRule("preIncDecExpression")]
	private LSLParser.preIncDecExpression_return preIncDecExpression()
	{
		EnterRule_preIncDecExpression();
		EnterRule("preIncDecExpression", 31);
		TraceIn("preIncDecExpression", 31);
		LSLParser.preIncDecExpression_return retval = new LSLParser.preIncDecExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int preIncDecExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken op = default(IToken);
		LSLParser.postfixExpression_return postfixExpression171 = default(LSLParser.postfixExpression_return);
		LSLParser.postfixExpression_return postfixExpression172 = default(LSLParser.postfixExpression_return);
		LSLParser.postfixExpression_return postfixExpression173 = default(LSLParser.postfixExpression_return);

		LSLAst op_tree = default(LSLAst);
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleSubtreeStream stream_postfixExpression=new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
		try { DebugEnterRule(GrammarFileName, "preIncDecExpression");
		DebugLocation(272, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return retval; }
			// LSL.g:273:2: (op= '++' postfixExpression -> ^( PRE_INCREMENT[$op] postfixExpression ) |op= '--' postfixExpression -> ^( PRE_DECREMENT[$op] postfixExpression ) | postfixExpression )
			int alt46=3;
			try { DebugEnterDecision(46, false);
			switch (input.LA(1))
			{
			case 64:
				{
				alt46 = 1;
				}
				break;
			case 66:
				{
				alt46 = 2;
				}
				break;
			case FLOAT_LITERAL:
			case ID:
			case INTEGER_LITERAL:
			case LPAREN:
			case LT:
			case STRING_LITERAL:
			case 79:
				{
				alt46 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:273:4: op= '++' postfixExpression
				{
				DebugLocation(273, 6);
				op=(IToken)Match(input,64,Follow._64_in_preIncDecExpression1852); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(op);

				DebugLocation(273, 12);
				PushFollow(Follow._postfixExpression_in_preIncDecExpression1854);
				postfixExpression171=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_postfixExpression.Add(postfixExpression171.Tree);


				{
				// AST REWRITE
				// elements: postfixExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 273:31: -> ^( PRE_INCREMENT[$op] postfixExpression )
				{
					DebugLocation(273, 34);
					// LSL.g:273:34: ^( PRE_INCREMENT[$op] postfixExpression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(273, 36);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(PRE_INCREMENT, op), root_1);

					DebugLocation(273, 55);
					adaptor.AddChild(root_1, stream_postfixExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:274:4: op= '--' postfixExpression
				{
				DebugLocation(274, 6);
				op=(IToken)Match(input,66,Follow._66_in_preIncDecExpression1871); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_66.Add(op);

				DebugLocation(274, 12);
				PushFollow(Follow._postfixExpression_in_preIncDecExpression1873);
				postfixExpression172=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_postfixExpression.Add(postfixExpression172.Tree);


				{
				// AST REWRITE
				// elements: postfixExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 274:30: -> ^( PRE_DECREMENT[$op] postfixExpression )
				{
					DebugLocation(274, 33);
					// LSL.g:274:33: ^( PRE_DECREMENT[$op] postfixExpression )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(274, 35);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(PRE_DECREMENT, op), root_1);

					DebugLocation(274, 54);
					adaptor.AddChild(root_1, stream_postfixExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// LSL.g:275:4: postfixExpression
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(275, 4);
				PushFollow(Follow._postfixExpression_in_preIncDecExpression1887);
				postfixExpression173=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, postfixExpression173.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("preIncDecExpression", 31);
			LeaveRule("preIncDecExpression", 31);
			LeaveRule_preIncDecExpression();
			if (state.backtracking > 0) { Memoize(input, 31, preIncDecExpression_StartIndex); }
		}
		DebugLocation(276, 1);
		} finally { DebugExitRule(GrammarFileName, "preIncDecExpression"); }
		return retval;

	}
	// $ANTLR end "preIncDecExpression"

	private sealed partial class postfixExpression_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public postfixExpression_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();

	// $ANTLR start "postfixExpression"
	// LSL.g:279:1: postfixExpression : primary ( (r= '(' callParamList ')' |r= '++' |r= '--' |r= '.' ID ) )* ;
	[GrammarRule("postfixExpression")]
	private LSLParser.postfixExpression_return postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 32);
		TraceIn("postfixExpression", 32);
		LSLParser.postfixExpression_return retval = new LSLParser.postfixExpression_return(this);
		retval.Start = (IToken)input.LT(1);
		int postfixExpression_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken r = default(IToken);
		IToken char_literal176 = default(IToken);
		IToken ID177 = default(IToken);
		LSLParser.primary_return primary174 = default(LSLParser.primary_return);
		LSLParser.callParamList_return callParamList175 = default(LSLParser.callParamList_return);

		LSLAst r_tree = default(LSLAst);
		LSLAst char_literal176_tree = default(LSLAst);
		LSLAst ID177_tree = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(279, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return retval; }
			// LSL.g:280:5: ( primary ( (r= '(' callParamList ')' |r= '++' |r= '--' |r= '.' ID ) )* )
			DebugEnterAlt(1);
			// LSL.g:280:9: primary ( (r= '(' callParamList ')' |r= '++' |r= '--' |r= '.' ID ) )*
			{
			root_0 = (LSLAst)adaptor.Nil();

			DebugLocation(280, 9);
			PushFollow(Follow._primary_in_postfixExpression1904);
			primary174=primary();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary174.Tree);
			DebugLocation(281, 6);
			// LSL.g:281:6: ( (r= '(' callParamList ')' |r= '++' |r= '--' |r= '.' ID ) )*
			try { DebugEnterSubRule(48);
			while (true)
			{
				int alt48=2;
				try { DebugEnterDecision(48, false);
				int LA48_0 = input.LA(1);

				if ((LA48_0==LPAREN||LA48_0==64||LA48_0==66||LA48_0==68))
				{
					alt48 = 1;
				}


				} finally { DebugExitDecision(48); }
				switch ( alt48 )
				{
				case 1:
					DebugEnterAlt(1);
					// LSL.g:282:7: (r= '(' callParamList ')' |r= '++' |r= '--' |r= '.' ID )
					{
					DebugLocation(282, 7);
					// LSL.g:282:7: (r= '(' callParamList ')' |r= '++' |r= '--' |r= '.' ID )
					int alt47=4;
					try { DebugEnterSubRule(47);
					try { DebugEnterDecision(47, false);
					switch (input.LA(1))
					{
					case LPAREN:
						{
						alt47 = 1;
						}
						break;
					case 64:
						{
						alt47 = 2;
						}
						break;
					case 66:
						{
						alt47 = 3;
						}
						break;
					case 68:
						{
						alt47 = 4;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(47); }
					switch (alt47)
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:282:9: r= '(' callParamList ')'
						{
						DebugLocation(282, 10);
						r=(IToken)Match(input,LPAREN,Follow._LPAREN_in_postfixExpression1923); if (state.failed) return retval;
						if (state.backtracking == 0) {
						r_tree = (LSLAst)adaptor.Create(r);
						root_0 = (LSLAst)adaptor.BecomeRoot(r_tree, root_0);
						}
						DebugLocation(282, 16);
						PushFollow(Follow._callParamList_in_postfixExpression1926);
						callParamList175=callParamList();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, callParamList175.Tree);
						DebugLocation(282, 33);
						char_literal176=(IToken)Match(input,RPAREN,Follow._RPAREN_in_postfixExpression1928); if (state.failed) return retval;
						DebugLocation(282, 35);
						if (state.backtracking == 0)
						{
							r.Type = METHOD_CALL;
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// LSL.g:283:9: r= '++'
						{
						DebugLocation(283, 10);
						r=(IToken)Match(input,64,Follow._64_in_postfixExpression1943); if (state.failed) return retval;
						if (state.backtracking == 0) {
						r_tree = (LSLAst)adaptor.Create(r);
						root_0 = (LSLAst)adaptor.BecomeRoot(r_tree, root_0);
						}
						DebugLocation(283, 17);
						if (state.backtracking == 0)
						{
							r.Type = POST_INCREMENT;
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// LSL.g:284:9: r= '--'
						{
						DebugLocation(284, 10);
						r=(IToken)Match(input,66,Follow._66_in_postfixExpression1958); if (state.failed) return retval;
						if (state.backtracking == 0) {
						r_tree = (LSLAst)adaptor.Create(r);
						root_0 = (LSLAst)adaptor.BecomeRoot(r_tree, root_0);
						}
						DebugLocation(284, 17);
						if (state.backtracking == 0)
						{
							r.Type = POST_DECREMENT;
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// LSL.g:285:9: r= '.' ID
						{
						DebugLocation(285, 10);
						r=(IToken)Match(input,68,Follow._68_in_postfixExpression1973); if (state.failed) return retval;
						if (state.backtracking == 0) {
						r_tree = (LSLAst)adaptor.Create(r);
						root_0 = (LSLAst)adaptor.BecomeRoot(r_tree, root_0);
						}
						DebugLocation(285, 16);
						ID177=(IToken)Match(input,ID,Follow._ID_in_postfixExpression1976); if (state.failed) return retval;
						if (state.backtracking == 0) {
						ID177_tree = (LSLAst)adaptor.Create(ID177);
						adaptor.AddChild(root_0, ID177_tree);
						}
						DebugLocation(285, 19);
						if (state.backtracking == 0)
						{
							r.Type = SUBSCRIPT;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(47); }


					}
					break;

				default:
					goto loop48;
				}
			}

			loop48:
				;

			} finally { DebugExitSubRule(48); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixExpression", 32);
			LeaveRule("postfixExpression", 32);
			LeaveRule_postfixExpression();
			if (state.backtracking > 0) { Memoize(input, 32, postfixExpression_StartIndex); }
		}
		DebugLocation(288, 4);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	private sealed partial class primary_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primary_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_primary();
	partial void LeaveRule_primary();

	// $ANTLR start "primary"
	// LSL.g:292:1: primary : ( STRING_LITERAL | INTEGER_LITERAL | FLOAT_LITERAL | vecLiteral | listLiteral | rotLiteral | ID | '(' expression ')' -> expression );
	[GrammarRule("primary")]
	private LSLParser.primary_return primary()
	{
		EnterRule_primary();
		EnterRule("primary", 33);
		TraceIn("primary", 33);
		LSLParser.primary_return retval = new LSLParser.primary_return(this);
		retval.Start = (IToken)input.LT(1);
		int primary_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken STRING_LITERAL178 = default(IToken);
		IToken INTEGER_LITERAL179 = default(IToken);
		IToken FLOAT_LITERAL180 = default(IToken);
		IToken ID184 = default(IToken);
		IToken char_literal185 = default(IToken);
		IToken char_literal187 = default(IToken);
		LSLParser.vecLiteral_return vecLiteral181 = default(LSLParser.vecLiteral_return);
		LSLParser.listLiteral_return listLiteral182 = default(LSLParser.listLiteral_return);
		LSLParser.rotLiteral_return rotLiteral183 = default(LSLParser.rotLiteral_return);
		LSLParser.expression_return expression186 = default(LSLParser.expression_return);

		LSLAst STRING_LITERAL178_tree = default(LSLAst);
		LSLAst INTEGER_LITERAL179_tree = default(LSLAst);
		LSLAst FLOAT_LITERAL180_tree = default(LSLAst);
		LSLAst ID184_tree = default(LSLAst);
		LSLAst char_literal185_tree = default(LSLAst);
		LSLAst char_literal187_tree = default(LSLAst);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "primary");
		DebugLocation(292, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 33)) { return retval; }
			// LSL.g:293:2: ( STRING_LITERAL | INTEGER_LITERAL | FLOAT_LITERAL | vecLiteral | listLiteral | rotLiteral | ID | '(' expression ')' -> expression )
			int alt49=8;
			try { DebugEnterDecision(49, false);
			try
			{
				alt49 = dfa49.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:293:4: STRING_LITERAL
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(293, 4);
				STRING_LITERAL178=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_primary2011); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STRING_LITERAL178_tree = (LSLAst)adaptor.Create(STRING_LITERAL178);
				adaptor.AddChild(root_0, STRING_LITERAL178_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:294:4: INTEGER_LITERAL
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(294, 4);
				INTEGER_LITERAL179=(IToken)Match(input,INTEGER_LITERAL,Follow._INTEGER_LITERAL_in_primary2016); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INTEGER_LITERAL179_tree = (LSLAst)adaptor.Create(INTEGER_LITERAL179);
				adaptor.AddChild(root_0, INTEGER_LITERAL179_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// LSL.g:295:5: FLOAT_LITERAL
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(295, 5);
				FLOAT_LITERAL180=(IToken)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_primary2022); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FLOAT_LITERAL180_tree = (LSLAst)adaptor.Create(FLOAT_LITERAL180);
				adaptor.AddChild(root_0, FLOAT_LITERAL180_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// LSL.g:296:4: vecLiteral
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(296, 4);
				PushFollow(Follow._vecLiteral_in_primary2027);
				vecLiteral181=vecLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, vecLiteral181.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// LSL.g:297:4: listLiteral
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(297, 4);
				PushFollow(Follow._listLiteral_in_primary2032);
				listLiteral182=listLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, listLiteral182.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// LSL.g:298:4: rotLiteral
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(298, 4);
				PushFollow(Follow._rotLiteral_in_primary2037);
				rotLiteral183=rotLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, rotLiteral183.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// LSL.g:299:4: ID
				{
				root_0 = (LSLAst)adaptor.Nil();

				DebugLocation(299, 4);
				ID184=(IToken)Match(input,ID,Follow._ID_in_primary2042); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID184_tree = (LSLAst)adaptor.Create(ID184);
				adaptor.AddChild(root_0, ID184_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// LSL.g:300:4: '(' expression ')'
				{
				DebugLocation(300, 4);
				char_literal185=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primary2047); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(char_literal185);

				DebugLocation(300, 8);
				PushFollow(Follow._expression_in_primary2049);
				expression186=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression186.Tree);
				DebugLocation(300, 19);
				char_literal187=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primary2051); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(char_literal187);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 300:23: -> expression
				{
					DebugLocation(300, 26);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primary", 33);
			LeaveRule("primary", 33);
			LeaveRule_primary();
			if (state.backtracking > 0) { Memoize(input, 33, primary_StartIndex); }
		}
		DebugLocation(301, 1);
		} finally { DebugExitRule(GrammarFileName, "primary"); }
		return retval;

	}
	// $ANTLR end "primary"

	private sealed partial class vecLiteral_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public vecLiteral_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_vecLiteral();
	partial void LeaveRule_vecLiteral();

	// $ANTLR start "vecLiteral"
	// LSL.g:303:1: vecLiteral : LT expr ',' expr ',' expr GT -> ^( VECTOR_LITERAL[$LT] expr expr expr ) ;
	[GrammarRule("vecLiteral")]
	private LSLParser.vecLiteral_return vecLiteral()
	{
		EnterRule_vecLiteral();
		EnterRule("vecLiteral", 34);
		TraceIn("vecLiteral", 34);
		LSLParser.vecLiteral_return retval = new LSLParser.vecLiteral_return(this);
		retval.Start = (IToken)input.LT(1);
		int vecLiteral_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken LT188 = default(IToken);
		IToken char_literal190 = default(IToken);
		IToken char_literal192 = default(IToken);
		IToken GT194 = default(IToken);
		LSLParser.expr_return expr189 = default(LSLParser.expr_return);
		LSLParser.expr_return expr191 = default(LSLParser.expr_return);
		LSLParser.expr_return expr193 = default(LSLParser.expr_return);

		LSLAst LT188_tree = default(LSLAst);
		LSLAst char_literal190_tree = default(LSLAst);
		LSLAst char_literal192_tree = default(LSLAst);
		LSLAst GT194_tree = default(LSLAst);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_GT=new RewriteRuleITokenStream(adaptor,"token GT");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		 GTDisabled = true; 
		try { DebugEnterRule(GrammarFileName, "vecLiteral");
		DebugLocation(303, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 34)) { return retval; }
			// LSL.g:305:2: ( LT expr ',' expr ',' expr GT -> ^( VECTOR_LITERAL[$LT] expr expr expr ) )
			DebugEnterAlt(1);
			// LSL.g:305:4: LT expr ',' expr ',' expr GT
			{
			DebugLocation(305, 4);
			LT188=(IToken)Match(input,LT,Follow._LT_in_vecLiteral2071); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LT.Add(LT188);

			DebugLocation(305, 7);
			PushFollow(Follow._expr_in_vecLiteral2073);
			expr189=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr189.Tree);
			DebugLocation(305, 12);
			char_literal190=(IToken)Match(input,COMMA,Follow._COMMA_in_vecLiteral2075); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMMA.Add(char_literal190);

			DebugLocation(305, 16);
			PushFollow(Follow._expr_in_vecLiteral2077);
			expr191=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr191.Tree);
			DebugLocation(305, 21);
			char_literal192=(IToken)Match(input,COMMA,Follow._COMMA_in_vecLiteral2079); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMMA.Add(char_literal192);

			DebugLocation(305, 25);
			PushFollow(Follow._expr_in_vecLiteral2081);
			expr193=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr193.Tree);
			DebugLocation(305, 30);
			GT194=(IToken)Match(input,GT,Follow._GT_in_vecLiteral2083); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GT.Add(GT194);



			{
			// AST REWRITE
			// elements: expr, expr, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 305:33: -> ^( VECTOR_LITERAL[$LT] expr expr expr )
			{
				DebugLocation(305, 36);
				// LSL.g:305:36: ^( VECTOR_LITERAL[$LT] expr expr expr )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(305, 38);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(VECTOR_LITERAL, LT188), root_1);

				DebugLocation(305, 58);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(305, 63);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(305, 68);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vecLiteral", 34);
			LeaveRule("vecLiteral", 34);
			LeaveRule_vecLiteral();
			if (state.backtracking > 0) { Memoize(input, 34, vecLiteral_StartIndex); }

				GTDisabled = false;

		}
		DebugLocation(306, 1);
		} finally { DebugExitRule(GrammarFileName, "vecLiteral"); }
		return retval;

	}
	// $ANTLR end "vecLiteral"

	private sealed partial class rotLiteral_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public rotLiteral_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_rotLiteral();
	partial void LeaveRule_rotLiteral();

	// $ANTLR start "rotLiteral"
	// LSL.g:312:1: rotLiteral : LT expr ',' expr ',' expr ',' expr GT -> ^( ROTATION_LITERAL[$LT] expr expr expr expr ) ;
	[GrammarRule("rotLiteral")]
	private LSLParser.rotLiteral_return rotLiteral()
	{
		EnterRule_rotLiteral();
		EnterRule("rotLiteral", 35);
		TraceIn("rotLiteral", 35);
		LSLParser.rotLiteral_return retval = new LSLParser.rotLiteral_return(this);
		retval.Start = (IToken)input.LT(1);
		int rotLiteral_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken LT195 = default(IToken);
		IToken char_literal197 = default(IToken);
		IToken char_literal199 = default(IToken);
		IToken char_literal201 = default(IToken);
		IToken GT203 = default(IToken);
		LSLParser.expr_return expr196 = default(LSLParser.expr_return);
		LSLParser.expr_return expr198 = default(LSLParser.expr_return);
		LSLParser.expr_return expr200 = default(LSLParser.expr_return);
		LSLParser.expr_return expr202 = default(LSLParser.expr_return);

		LSLAst LT195_tree = default(LSLAst);
		LSLAst char_literal197_tree = default(LSLAst);
		LSLAst char_literal199_tree = default(LSLAst);
		LSLAst char_literal201_tree = default(LSLAst);
		LSLAst GT203_tree = default(LSLAst);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_GT=new RewriteRuleITokenStream(adaptor,"token GT");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		 GTDisabled = true; 
		try { DebugEnterRule(GrammarFileName, "rotLiteral");
		DebugLocation(312, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 35)) { return retval; }
			// LSL.g:314:2: ( LT expr ',' expr ',' expr ',' expr GT -> ^( ROTATION_LITERAL[$LT] expr expr expr expr ) )
			DebugEnterAlt(1);
			// LSL.g:314:4: LT expr ',' expr ',' expr ',' expr GT
			{
			DebugLocation(314, 4);
			LT195=(IToken)Match(input,LT,Follow._LT_in_rotLiteral2117); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LT.Add(LT195);

			DebugLocation(314, 7);
			PushFollow(Follow._expr_in_rotLiteral2119);
			expr196=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr196.Tree);
			DebugLocation(314, 12);
			char_literal197=(IToken)Match(input,COMMA,Follow._COMMA_in_rotLiteral2121); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMMA.Add(char_literal197);

			DebugLocation(314, 16);
			PushFollow(Follow._expr_in_rotLiteral2123);
			expr198=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr198.Tree);
			DebugLocation(314, 21);
			char_literal199=(IToken)Match(input,COMMA,Follow._COMMA_in_rotLiteral2125); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMMA.Add(char_literal199);

			DebugLocation(314, 25);
			PushFollow(Follow._expr_in_rotLiteral2127);
			expr200=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr200.Tree);
			DebugLocation(314, 30);
			char_literal201=(IToken)Match(input,COMMA,Follow._COMMA_in_rotLiteral2129); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMMA.Add(char_literal201);

			DebugLocation(314, 34);
			PushFollow(Follow._expr_in_rotLiteral2131);
			expr202=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr202.Tree);
			DebugLocation(314, 39);
			GT203=(IToken)Match(input,GT,Follow._GT_in_rotLiteral2133); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GT.Add(GT203);



			{
			// AST REWRITE
			// elements: expr, expr, expr, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 314:42: -> ^( ROTATION_LITERAL[$LT] expr expr expr expr )
			{
				DebugLocation(314, 45);
				// LSL.g:314:45: ^( ROTATION_LITERAL[$LT] expr expr expr expr )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(314, 47);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(ROTATION_LITERAL, LT195), root_1);

				DebugLocation(314, 69);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(314, 74);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(314, 79);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(314, 84);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rotLiteral", 35);
			LeaveRule("rotLiteral", 35);
			LeaveRule_rotLiteral();
			if (state.backtracking > 0) { Memoize(input, 35, rotLiteral_StartIndex); }

				GTDisabled = false;

		}
		DebugLocation(315, 1);
		} finally { DebugExitRule(GrammarFileName, "rotLiteral"); }
		return retval;

	}
	// $ANTLR end "rotLiteral"

	private sealed partial class listLiteral_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public listLiteral_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_listLiteral();
	partial void LeaveRule_listLiteral();

	// $ANTLR start "listLiteral"
	// LSL.g:321:1: listLiteral : lo= '[' listContents ']' -> ^( LIST_LITERAL[$lo] listContents ) ;
	[GrammarRule("listLiteral")]
	private LSLParser.listLiteral_return listLiteral()
	{
		EnterRule_listLiteral();
		EnterRule("listLiteral", 36);
		TraceIn("listLiteral", 36);
		LSLParser.listLiteral_return retval = new LSLParser.listLiteral_return(this);
		retval.Start = (IToken)input.LT(1);
		int listLiteral_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken lo = default(IToken);
		IToken char_literal205 = default(IToken);
		LSLParser.listContents_return listContents204 = default(LSLParser.listContents_return);

		LSLAst lo_tree = default(LSLAst);
		LSLAst char_literal205_tree = default(LSLAst);
		RewriteRuleITokenStream stream_79=new RewriteRuleITokenStream(adaptor,"token 79");
		RewriteRuleITokenStream stream_80=new RewriteRuleITokenStream(adaptor,"token 80");
		RewriteRuleSubtreeStream stream_listContents=new RewriteRuleSubtreeStream(adaptor,"rule listContents");
		try { DebugEnterRule(GrammarFileName, "listLiteral");
		DebugLocation(321, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 36)) { return retval; }
			// LSL.g:322:2: (lo= '[' listContents ']' -> ^( LIST_LITERAL[$lo] listContents ) )
			DebugEnterAlt(1);
			// LSL.g:322:4: lo= '[' listContents ']'
			{
			DebugLocation(322, 6);
			lo=(IToken)Match(input,79,Follow._79_in_listLiteral2165); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_79.Add(lo);

			DebugLocation(322, 11);
			PushFollow(Follow._listContents_in_listLiteral2167);
			listContents204=listContents();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_listContents.Add(listContents204.Tree);
			DebugLocation(322, 24);
			char_literal205=(IToken)Match(input,80,Follow._80_in_listLiteral2169); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_80.Add(char_literal205);



			{
			// AST REWRITE
			// elements: listContents
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (LSLAst)adaptor.Nil();
			// 322:28: -> ^( LIST_LITERAL[$lo] listContents )
			{
				DebugLocation(322, 31);
				// LSL.g:322:31: ^( LIST_LITERAL[$lo] listContents )
				{
				LSLAst root_1 = (LSLAst)adaptor.Nil();
				DebugLocation(322, 33);
				root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(LIST_LITERAL, lo), root_1);

				DebugLocation(322, 51);
				adaptor.AddChild(root_1, stream_listContents.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("listLiteral", 36);
			LeaveRule("listLiteral", 36);
			LeaveRule_listLiteral();
			if (state.backtracking > 0) { Memoize(input, 36, listLiteral_StartIndex); }
		}
		DebugLocation(323, 1);
		} finally { DebugExitRule(GrammarFileName, "listLiteral"); }
		return retval;

	}
	// $ANTLR end "listLiteral"

	private sealed partial class listContents_return : ParserRuleReturnScope<IToken>, IAstRuleReturnScope<LSLAst>, IAstRuleReturnScope
	{
		private LSLAst _tree;
		public LSLAst Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public listContents_return(LSLParser grammar) {OnCreated(grammar);}
		partial void OnCreated(LSLParser grammar);
	}

	partial void EnterRule_listContents();
	partial void LeaveRule_listContents();

	// $ANTLR start "listContents"
	// LSL.g:325:1: listContents : ( expr ( ',' expr )* -> ^( ELIST ( expr )+ ) | -> ELIST );
	[GrammarRule("listContents")]
	private LSLParser.listContents_return listContents()
	{
		EnterRule_listContents();
		EnterRule("listContents", 37);
		TraceIn("listContents", 37);
		LSLParser.listContents_return retval = new LSLParser.listContents_return(this);
		retval.Start = (IToken)input.LT(1);
		int listContents_StartIndex = input.Index;
		LSLAst root_0 = default(LSLAst);

		IToken char_literal207 = default(IToken);
		LSLParser.expr_return expr206 = default(LSLParser.expr_return);
		LSLParser.expr_return expr208 = default(LSLParser.expr_return);

		LSLAst char_literal207_tree = default(LSLAst);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "listContents");
		DebugLocation(325, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 37)) { return retval; }
			// LSL.g:326:2: ( expr ( ',' expr )* -> ^( ELIST ( expr )+ ) | -> ELIST )
			int alt51=2;
			try { DebugEnterDecision(51, false);
			int LA51_0 = input.LA(1);

			if ((LA51_0==FLOAT_LITERAL||LA51_0==ID||LA51_0==INTEGER_LITERAL||(LA51_0>=LPAREN && LA51_0<=LT)||LA51_0==MINUS||LA51_0==STRING_LITERAL||LA51_0==55||LA51_0==64||LA51_0==66||LA51_0==79||LA51_0==95))
			{
				alt51 = 1;
			}
			else if ((LA51_0==80))
			{
				alt51 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 51, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:326:4: expr ( ',' expr )*
				{
				DebugLocation(326, 4);
				PushFollow(Follow._expr_in_listContents2189);
				expr206=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr206.Tree);
				DebugLocation(326, 9);
				// LSL.g:326:9: ( ',' expr )*
				try { DebugEnterSubRule(50);
				while (true)
				{
					int alt50=2;
					try { DebugEnterDecision(50, false);
					int LA50_0 = input.LA(1);

					if ((LA50_0==COMMA))
					{
						alt50 = 1;
					}


					} finally { DebugExitDecision(50); }
					switch ( alt50 )
					{
					case 1:
						DebugEnterAlt(1);
						// LSL.g:326:10: ',' expr
						{
						DebugLocation(326, 10);
						char_literal207=(IToken)Match(input,COMMA,Follow._COMMA_in_listContents2192); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(char_literal207);

						DebugLocation(326, 14);
						PushFollow(Follow._expr_in_listContents2194);
						expr208=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr208.Tree);

						}
						break;

					default:
						goto loop50;
					}
				}

				loop50:
					;

				} finally { DebugExitSubRule(50); }



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 326:21: -> ^( ELIST ( expr )+ )
				{
					DebugLocation(326, 24);
					// LSL.g:326:24: ^( ELIST ( expr )+ )
					{
					LSLAst root_1 = (LSLAst)adaptor.Nil();
					DebugLocation(326, 26);
					root_1 = (LSLAst)adaptor.BecomeRoot((LSLAst)adaptor.Create(ELIST, "ELIST"), root_1);

					DebugLocation(326, 32);
					if (!(stream_expr.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(326, 32);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:327:4: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (LSLAst)adaptor.Nil();
				// 327:4: -> ELIST
				{
					DebugLocation(327, 7);
					adaptor.AddChild(root_0, (LSLAst)adaptor.Create(ELIST, "ELIST"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (LSLAst)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (LSLAst)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("listContents", 37);
			LeaveRule("listContents", 37);
			LeaveRule_listContents();
			if (state.backtracking > 0) { Memoize(input, 37, listContents_StartIndex); }
		}
		DebugLocation(328, 1);
		} finally { DebugExitRule(GrammarFileName, "listContents"); }
		return retval;

	}
	// $ANTLR end "listContents"

	partial void EnterRule_synpred15_LSL_fragment();
	partial void LeaveRule_synpred15_LSL_fragment();

	// $ANTLR start synpred15_LSL
	public void synpred15_LSL_fragment()
	{
		EnterRule_synpred15_LSL_fragment();
		EnterRule("synpred15_LSL_fragment", 52);
		TraceIn("synpred15_LSL_fragment", 52);
		try
		{
			// LSL.g:134:4: ( funcBlock )
			DebugEnterAlt(1);
			// LSL.g:134:4: funcBlock
			{
			DebugLocation(134, 4);
			PushFollow(Follow._funcBlock_in_synpred15_LSL516);
			funcBlock();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred15_LSL_fragment", 52);
			LeaveRule("synpred15_LSL_fragment", 52);
			LeaveRule_synpred15_LSL_fragment();
		}
	}
	// $ANTLR end synpred15_LSL

	partial void EnterRule_synpred29_LSL_fragment();
	partial void LeaveRule_synpred29_LSL_fragment();

	// $ANTLR start synpred29_LSL
	public void synpred29_LSL_fragment()
	{
		LSLParser.statement_return e = default(LSLParser.statement_return);

		EnterRule_synpred29_LSL_fragment();
		EnterRule("synpred29_LSL_fragment", 66);
		TraceIn("synpred29_LSL_fragment", 66);
		try
		{
			// LSL.g:155:43: ( 'else' e= statement )
			DebugEnterAlt(1);
			// LSL.g:155:43: 'else' e= statement
			{
			DebugLocation(155, 43);
			Match(input,84,Follow._84_in_synpred29_LSL714); if (state.failed) return;
			DebugLocation(155, 51);
			PushFollow(Follow._statement_in_synpred29_LSL718);
			e=statement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred29_LSL_fragment", 66);
			LeaveRule("synpred29_LSL_fragment", 66);
			LeaveRule_synpred29_LSL_fragment();
		}
	}
	// $ANTLR end synpred29_LSL

	partial void EnterRule_synpred66_LSL_fragment();
	partial void LeaveRule_synpred66_LSL_fragment();

	// $ANTLR start synpred66_LSL
	public void synpred66_LSL_fragment()
	{
		EnterRule_synpred66_LSL_fragment();
		EnterRule("synpred66_LSL_fragment", 103);
		TraceIn("synpred66_LSL_fragment", 103);
		try
		{
			// LSL.g:228:23: ( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression )
			DebugEnterAlt(1);
			// LSL.g:228:23: ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression
			{
			DebugLocation(228, 23);
			if (input.LA(1)==ASSIGN_EQ||input.LA(1)==58||input.LA(1)==62||input.LA(1)==65||input.LA(1)==67||input.LA(1)==70||input.LA(1)==72||input.LA(1)==77)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(228, 88);
			PushFollow(Follow._assignmentExpression_in_synpred66_LSL1518);
			assignmentExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred66_LSL_fragment", 103);
			LeaveRule("synpred66_LSL_fragment", 103);
			LeaveRule_synpred66_LSL_fragment();
		}
	}
	// $ANTLR end synpred66_LSL

	partial void EnterRule_synpred75_LSL_fragment();
	partial void LeaveRule_synpred75_LSL_fragment();

	// $ANTLR start synpred75_LSL
	public void synpred75_LSL_fragment()
	{
		EnterRule_synpred75_LSL_fragment();
		EnterRule("synpred75_LSL_fragment", 112);
		TraceIn("synpred75_LSL_fragment", 112);
		try
		{
			// LSL.g:244:37: ({...}? => '>' )
			DebugEnterAlt(1);
			// LSL.g:244:37: {...}? => '>'
			{
			DebugLocation(244, 37);
			if (!((GTNotDisabled())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred75_LSL", "GTNotDisabled()");
			}
			DebugLocation(244, 59);
			Match(input,GT,Follow._GT_in_synpred75_LSL1630); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred75_LSL_fragment", 112);
			LeaveRule("synpred75_LSL_fragment", 112);
			LeaveRule_synpred75_LSL_fragment();
		}
	}
	// $ANTLR end synpred75_LSL

	partial void EnterRule_synpred77_LSL_fragment();
	partial void LeaveRule_synpred77_LSL_fragment();

	// $ANTLR start synpred77_LSL
	public void synpred77_LSL_fragment()
	{
		EnterRule_synpred77_LSL_fragment();
		EnterRule("synpred77_LSL_fragment", 114);
		TraceIn("synpred77_LSL_fragment", 114);
		try
		{
			// LSL.g:244:29: ( ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression )
			DebugEnterAlt(1);
			// LSL.g:244:29: ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression
			{
			DebugLocation(244, 29);
			// LSL.g:244:29: ( '<' |{...}? => '>' | '<=' |{...}? => '>=' )
			int alt64=4;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_0 = input.LA(1);

			if ((LA64_0==LT))
			{
				alt64 = 1;
			}
			else if ((LA64_0==GT) && ((GTNotDisabled())))
			{
				alt64 = 2;
			}
			else if ((LA64_0==73))
			{
				alt64 = 3;
			}
			else if ((LA64_0==75) && ((GTNotDisabled())))
			{
				alt64 = 4;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 64, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// LSL.g:244:30: '<'
				{
				DebugLocation(244, 30);
				Match(input,LT,Follow._LT_in_synpred77_LSL1621); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// LSL.g:244:37: {...}? => '>'
				{
				DebugLocation(244, 37);
				if (!((GTNotDisabled())))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "synpred77_LSL", "GTNotDisabled()");
				}
				DebugLocation(244, 59);
				Match(input,GT,Follow._GT_in_synpred77_LSL1630); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// LSL.g:244:66: '<='
				{
				DebugLocation(244, 66);
				Match(input,73,Follow._73_in_synpred77_LSL1635); if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// LSL.g:244:74: {...}? => '>='
				{
				DebugLocation(244, 74);
				if (!((GTNotDisabled())))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "synpred77_LSL", "GTNotDisabled()");
				}
				DebugLocation(244, 96);
				Match(input,75,Follow._75_in_synpred77_LSL1644); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(244, 103);
			if (!((IsNotVector())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred77_LSL", "IsNotVector()");
			}
			DebugLocation(244, 120);
			PushFollow(Follow._binaryBitwiseExpression_in_synpred77_LSL1650);
			binaryBitwiseExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred77_LSL_fragment", 114);
			LeaveRule("synpred77_LSL_fragment", 114);
			LeaveRule_synpred77_LSL_fragment();
		}
	}
	// $ANTLR end synpred77_LSL

	partial void EnterRule_synpred98_LSL_fragment();
	partial void LeaveRule_synpred98_LSL_fragment();

	// $ANTLR start synpred98_LSL
	public void synpred98_LSL_fragment()
	{
		EnterRule_synpred98_LSL_fragment();
		EnterRule("synpred98_LSL_fragment", 135);
		TraceIn("synpred98_LSL_fragment", 135);
		try
		{
			// LSL.g:296:4: ( vecLiteral )
			DebugEnterAlt(1);
			// LSL.g:296:4: vecLiteral
			{
			DebugLocation(296, 4);
			PushFollow(Follow._vecLiteral_in_synpred98_LSL2027);
			vecLiteral();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred98_LSL_fragment", 135);
			LeaveRule("synpred98_LSL_fragment", 135);
			LeaveRule_synpred98_LSL_fragment();
		}
	}
	// $ANTLR end synpred98_LSL

	partial void EnterRule_synpred100_LSL_fragment();
	partial void LeaveRule_synpred100_LSL_fragment();

	// $ANTLR start synpred100_LSL
	public void synpred100_LSL_fragment()
	{
		EnterRule_synpred100_LSL_fragment();
		EnterRule("synpred100_LSL_fragment", 137);
		TraceIn("synpred100_LSL_fragment", 137);
		try
		{
			// LSL.g:298:4: ( rotLiteral )
			DebugEnterAlt(1);
			// LSL.g:298:4: rotLiteral
			{
			DebugLocation(298, 4);
			PushFollow(Follow._rotLiteral_in_synpred100_LSL2037);
			rotLiteral();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred100_LSL_fragment", 137);
			LeaveRule("synpred100_LSL_fragment", 137);
			LeaveRule_synpred100_LSL_fragment();
		}
	}
	// $ANTLR end synpred100_LSL
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA9 dfa9;
	private DFA23 dfa23;
	private DFA30 dfa30;
	private DFA38 dfa38;
	private DFA49 dfa49;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa9 = new DFA9( this, SpecialStateTransition9 );
		dfa23 = new DFA23( this );
		dfa30 = new DFA30( this, SpecialStateTransition30 );
		dfa38 = new DFA38( this, SpecialStateTransition38 );
		dfa49 = new DFA49( this, SpecialStateTransition49 );
	}

	private class DFA9 : DFA
	{
		private const string DFA9_eotS =
			"\x14\xFFFF";
		private const string DFA9_eofS =
			"\x14\xFFFF";
		private const string DFA9_minS =
			"\x1\x6\x1\x0\x12\xFFFF";
		private const string DFA9_maxS =
			"\x1\x5B\x1\x0\x12\xFFFF";
		private const string DFA9_acceptS =
			"\x2\xFFFF\x1\x2\x10\xFFFF\x1\x1";
		private const string DFA9_specialS =
			"\x1\xFFFF\x1\x0\x12\xFFFF}>";
		private static readonly string[] DFA9_transitionS =
			{
				"\x2\x2\xB\xFFFF\x1\x2\x6\xFFFF\x1\x2\x4\xFFFF\x1\x2\x8\xFFFF\x1\x2\x5"+
				"\xFFFF\x1\x2\x11\xFFFF\x1\x2\x1\xFFFF\x1\x2\xB\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2\x1\xFFFF\x6\x2\x1\x1",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
		private static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
		private static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
		private static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
		private static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
		private static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
		private static readonly short[][] DFA9_transition;

		static DFA9()
		{
			int numStates = DFA9_transitionS.Length;
			DFA9_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
			}
		}

		public DFA9( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 9;
			this.eot = DFA9_eot;
			this.eof = DFA9_eof;
			this.min = DFA9_min;
			this.max = DFA9_max;
			this.accept = DFA9_accept;
			this.special = DFA9_special;
			this.transition = DFA9_transition;
		}

		public override string Description { get { return "133:1: statement : ( funcBlock | funcBlockContent );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition9(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA9_1 = input.LA(1);


				int index9_1 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred15_LSL_fragment))) {s = 19;}

				else if ((true)) {s = 2;}


				input.Seek(index9_1);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 9, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA23 : DFA
	{
		private const string DFA23_eotS =
			"\x18\xFFFF";
		private const string DFA23_eofS =
			"\x18\xFFFF";
		private const string DFA23_minS =
			"\x1\x6\x2\xFFFF\x1\x4\x10\xFFFF\x1\x13\x2\xFFFF\x1\x4";
		private const string DFA23_maxS =
			"\x1\x5B\x2\xFFFF\x1\x4D\x10\xFFFF\x1\x13\x2\xFFFF\x1\x4D";
		private const string DFA23_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x9\x1"+
			"\xA\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1\x13\x1\x14\x1\x8\x1\xFFFF"+
			"\x1\xB\x1\xC\x1\xFFFF";
		private const string DFA23_specialS =
			"\x18\xFFFF}>";
		private static readonly string[] DFA23_transitionS =
			{
				"\x1\x12\x1\x11\xB\xFFFF\x1\x3\x6\xFFFF\x1\x2\x4\xFFFF\x1\x10\x8\xFFFF"+
				"\x1\x1\x5\xFFFF\x1\x8\x11\xFFFF\x1\x9\x1\xFFFF\x1\xA\xB\xFFFF\x1\xD"+
				"\x4\xFFFF\x1\x7\x1\xFFFF\x1\x6\x1\x4\x1\xE\x1\xB\x1\xC\x1\x5\x1\xF",
				"",
				"",
				"\x1\x2\x15\xFFFF\x1\x13\x1F\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x15"+
				"\x1\x2\x1\x16\x1\x2\x1\x14\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x1"+
				"\x2",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x17",
				"",
				"",
				"\x1\x2\x35\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x15\x1\x2\x1\x16\x1"+
				"\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x4\xFFFF\x1\x2"
			};

		private static readonly short[] DFA23_eot = DFA.UnpackEncodedString(DFA23_eotS);
		private static readonly short[] DFA23_eof = DFA.UnpackEncodedString(DFA23_eofS);
		private static readonly char[] DFA23_min = DFA.UnpackEncodedStringToUnsignedChars(DFA23_minS);
		private static readonly char[] DFA23_max = DFA.UnpackEncodedStringToUnsignedChars(DFA23_maxS);
		private static readonly short[] DFA23_accept = DFA.UnpackEncodedString(DFA23_acceptS);
		private static readonly short[] DFA23_special = DFA.UnpackEncodedString(DFA23_specialS);
		private static readonly short[][] DFA23_transition;

		static DFA23()
		{
			int numStates = DFA23_transitionS.Length;
			DFA23_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA23_transition[i] = DFA.UnpackEncodedString(DFA23_transitionS[i]);
			}
		}

		public DFA23( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 23;
			this.eot = DFA23_eot;
			this.eof = DFA23_eof;
			this.min = DFA23_min;
			this.max = DFA23_max;
			this.accept = DFA23_accept;
			this.special = DFA23_special;
			this.transition = DFA23_transition;
		}

		public override string Description { get { return "147:1: funcBlockContent : ( SEMI | ( LPAREN )? lhs ( '.' subscript= ID )? (t= '=' |t= '+=' |t= '-=' |t= '*=' |t= '/=' |t= '%=' |t= '<<=' |t= '>>=' ) expression ( RPAREN )? SEMI -> {$subscript!=null}? ^( $t ^( SUBSCRIPT lhs $subscript) expression ) -> ^( $t lhs expression ) |i= 'if' '(' expression ')' s= statement ( 'else' e= statement )? -> ^( IF_STMT[$i] expression $s ^( ELSE_PART ( $e)? ) ) |w= 'while' '(' expression ')' statement -> ^( WHILE_STMT[$w] expression statement ) |f= 'for' '(' init= exprStatement cond= exprStatement (loop= expression )? ')' statement -> ^( FOR_STMT[$f] statement $init $cond ( $loop)? ) |d= 'do' statement 'while' '(' expression ')' SEMI -> ^( DO_WHILE_STMT[$d] expression statement ) | varDecl | funcCall -> ^( EXPR funcCall ) | '++' ID ( '.' subscript= ID )? SEMI -> {$subscript == null}? ^( EXPR ^( PRE_INCREMENT ID ) ) -> ^( EXPR ^( PRE_INCREMENT ^( SUBSCRIPT ID $subscript) ) ) | '--' ID ( '.' subscript= ID )? SEMI -> {$subscript == null}? ^( EXPR ^( PRE_DECREMENT ID ) ) -> ^( EXPR ^( PRE_DECREMENT ^( SUBSCRIPT ID $subscript) ) ) | ID ( '.' subscript= ID )? '++' SEMI -> {$subscript == null}? ^( EXPR ^( POST_INCREMENT ID ) ) -> ^( EXPR ^( POST_INCREMENT ^( SUBSCRIPT ID $subscript) ) ) | ID ( '.' subscript= ID )? '--' SEMI -> {$subscript == null}? ^( EXPR ^( POST_DECREMENT ID ) ) -> ^( EXPR ^( POST_DECREMENT ^( SUBSCRIPT ID $subscript) ) ) |r= 'return' ( expression )? SEMI -> ^( RETURN_STMT[$r] ( expression )? ) |stateNode= 'state' ( ID | 'default' ) SEMI -> ^( STATE_CHG[$stateNode] ( ID )? ) | label SEMI | 'jump' ID SEMI -> ^( JUMP_STMT ID ) | funcBlock | NEWLINE | COMMENT_SINGLE | COMMENT_BLOCK );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA30 : DFA
	{
		private const string DFA30_eotS =
			"\xB\xFFFF";
		private const string DFA30_eofS =
			"\x1\x1\xA\xFFFF";
		private const string DFA30_minS =
			"\x1\x4\x1\xFFFF\x8\x0\x1\xFFFF";
		private const string DFA30_maxS =
			"\x1\x50\x1\xFFFF\x8\x0\x1\xFFFF";
		private const string DFA30_acceptS =
			"\x1\xFFFF\x1\x2\x8\xFFFF\x1\x1";
		private const string DFA30_specialS =
			"\x2\xFFFF\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\xFFFF}>";
		private static readonly string[] DFA30_transitionS =
			{
				"\x1\x2\x1\x1\xC\xFFFF\x1\x1\x14\xFFFF\x2\x1\x11\xFFFF\x1\x7\x3\xFFFF"+
				"\x1\x5\x2\xFFFF\x1\x3\x1\xFFFF\x1\x4\x2\xFFFF\x1\x6\x1\xFFFF\x1\x8\x4"+
				"\xFFFF\x1\x9\x2\xFFFF\x1\x1",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				""
			};

		private static readonly short[] DFA30_eot = DFA.UnpackEncodedString(DFA30_eotS);
		private static readonly short[] DFA30_eof = DFA.UnpackEncodedString(DFA30_eofS);
		private static readonly char[] DFA30_min = DFA.UnpackEncodedStringToUnsignedChars(DFA30_minS);
		private static readonly char[] DFA30_max = DFA.UnpackEncodedStringToUnsignedChars(DFA30_maxS);
		private static readonly short[] DFA30_accept = DFA.UnpackEncodedString(DFA30_acceptS);
		private static readonly short[] DFA30_special = DFA.UnpackEncodedString(DFA30_specialS);
		private static readonly short[][] DFA30_transition;

		static DFA30()
		{
			int numStates = DFA30_transitionS.Length;
			DFA30_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA30_transition[i] = DFA.UnpackEncodedString(DFA30_transitionS[i]);
			}
		}

		public DFA30( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 30;
			this.eot = DFA30_eot;
			this.eof = DFA30_eof;
			this.min = DFA30_min;
			this.max = DFA30_max;
			this.accept = DFA30_accept;
			this.special = DFA30_special;
			this.transition = DFA30_transition;
		}

		public override string Description { get { return "()* loopback of 228:22: ( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' ) assignmentExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition30(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA30_2 = input.LA(1);


				int index30_2 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_2);
				if (s >= 0) return s;
				break;
			case 1:
				int LA30_3 = input.LA(1);


				int index30_3 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_3);
				if (s >= 0) return s;
				break;
			case 2:
				int LA30_4 = input.LA(1);


				int index30_4 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_4);
				if (s >= 0) return s;
				break;
			case 3:
				int LA30_5 = input.LA(1);


				int index30_5 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_5);
				if (s >= 0) return s;
				break;
			case 4:
				int LA30_6 = input.LA(1);


				int index30_6 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_6);
				if (s >= 0) return s;
				break;
			case 5:
				int LA30_7 = input.LA(1);


				int index30_7 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_7);
				if (s >= 0) return s;
				break;
			case 6:
				int LA30_8 = input.LA(1);


				int index30_8 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_8);
				if (s >= 0) return s;
				break;
			case 7:
				int LA30_9 = input.LA(1);


				int index30_9 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred66_LSL_fragment))) {s = 10;}

				else if ((true)) {s = 1;}


				input.Seek(index30_9);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 30, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA38 : DFA
	{
		private const string DFA38_eotS =
			"\x19\xFFFF";
		private const string DFA38_eofS =
			"\x1\x1\x18\xFFFF";
		private const string DFA38_minS =
			"\x1\x4\x13\xFFFF\x1\x0\x4\xFFFF";
		private const string DFA38_maxS =
			"\x1\x5D\x13\xFFFF\x1\x0\x4\xFFFF";
		private const string DFA38_acceptS =
			"\x1\xFFFF\x1\x2\x14\xFFFF\x1\x1\x2\xFFFF";
		private const string DFA38_specialS =
			"\x14\xFFFF\x1\x0\x4\xFFFF}>";
		private static readonly string[] DFA38_transitionS =
			{
				"\x2\x1\xC\xFFFF\x1\x14\x8\xFFFF\x1\x16\xB\xFFFF\x2\x1\xF\xFFFF\x1\x1"+
				"\x1\xFFFF\x3\x1\x1\xFFFF\x1\x1\x2\xFFFF\x1\x1\x1\xFFFF\x1\x1\x2\xFFFF"+
				"\x1\x1\x1\xFFFF\x1\x1\x1\x16\x1\x1\x1\x16\x1\xFFFF\x1\x1\x2\xFFFF\x2"+
				"\x1\xA\xFFFF\x2\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA38_eot = DFA.UnpackEncodedString(DFA38_eotS);
		private static readonly short[] DFA38_eof = DFA.UnpackEncodedString(DFA38_eofS);
		private static readonly char[] DFA38_min = DFA.UnpackEncodedStringToUnsignedChars(DFA38_minS);
		private static readonly char[] DFA38_max = DFA.UnpackEncodedStringToUnsignedChars(DFA38_maxS);
		private static readonly short[] DFA38_accept = DFA.UnpackEncodedString(DFA38_acceptS);
		private static readonly short[] DFA38_special = DFA.UnpackEncodedString(DFA38_specialS);
		private static readonly short[][] DFA38_transition;

		static DFA38()
		{
			int numStates = DFA38_transitionS.Length;
			DFA38_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA38_transition[i] = DFA.UnpackEncodedString(DFA38_transitionS[i]);
			}
		}

		public DFA38( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 38;
			this.eot = DFA38_eot;
			this.eof = DFA38_eof;
			this.min = DFA38_min;
			this.max = DFA38_max;
			this.accept = DFA38_accept;
			this.special = DFA38_special;
			this.transition = DFA38_transition;
		}

		public override string Description { get { return "()* loopback of 244:28: ( ( '<' |{...}? => '>' | '<=' |{...}? => '>=' ) {...}? binaryBitwiseExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition38(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA38_20 = input.LA(1);


				int index38_20 = input.Index;
				input.Rewind();
				s = -1;
				if (((EvaluatePredicate(synpred77_LSL_fragment)&&(GTNotDisabled())))) {s = 22;}

				else if ((true)) {s = 1;}


				input.Seek(index38_20);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 38, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA49 : DFA
	{
		private const string DFA49_eotS =
			"\xA\xFFFF";
		private const string DFA49_eofS =
			"\xA\xFFFF";
		private const string DFA49_minS =
			"\x1\xF\x3\xFFFF\x1\x0\x5\xFFFF";
		private const string DFA49_maxS =
			"\x1\x4F\x3\xFFFF\x1\x0\x5\xFFFF";
		private const string DFA49_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\xFFFF\x1\x5\x1\x7\x1\x8\x1\x4\x1\x6";
		private const string DFA49_specialS =
			"\x4\xFFFF\x1\x0\x5\xFFFF}>";
		private static readonly string[] DFA49_transitionS =
			{
				"\x1\x3\x3\xFFFF\x1\x6\x2\xFFFF\x1\x2\x3\xFFFF\x1\x7\x1\x4\x10\xFFFF"+
				"\x1\x1\x22\xFFFF\x1\x5",
				"",
				"",
				"",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA49_eot = DFA.UnpackEncodedString(DFA49_eotS);
		private static readonly short[] DFA49_eof = DFA.UnpackEncodedString(DFA49_eofS);
		private static readonly char[] DFA49_min = DFA.UnpackEncodedStringToUnsignedChars(DFA49_minS);
		private static readonly char[] DFA49_max = DFA.UnpackEncodedStringToUnsignedChars(DFA49_maxS);
		private static readonly short[] DFA49_accept = DFA.UnpackEncodedString(DFA49_acceptS);
		private static readonly short[] DFA49_special = DFA.UnpackEncodedString(DFA49_specialS);
		private static readonly short[][] DFA49_transition;

		static DFA49()
		{
			int numStates = DFA49_transitionS.Length;
			DFA49_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA49_transition[i] = DFA.UnpackEncodedString(DFA49_transitionS[i]);
			}
		}

		public DFA49( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 49;
			this.eot = DFA49_eot;
			this.eof = DFA49_eof;
			this.min = DFA49_min;
			this.max = DFA49_max;
			this.accept = DFA49_accept;
			this.special = DFA49_special;
			this.transition = DFA49_transition;
		}

		public override string Description { get { return "292:1: primary : ( STRING_LITERAL | INTEGER_LITERAL | FLOAT_LITERAL | vecLiteral | listLiteral | rotLiteral | ID | '(' expression ')' -> expression );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition49(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA49_4 = input.LA(1);


				int index49_4 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred98_LSL_fragment))) {s = 8;}

				else if ((EvaluatePredicate(synpred100_LSL_fragment))) {s = 9;}


				input.Seek(index49_4);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 49, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _globalStmt_in_prog283 = new BitSet(new ulong[]{0x4000800800C0UL,0x2040000UL});
		public static readonly BitSet _EOF_in_prog286 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varDecl_in_globalStmt299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_globalStmt304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMENT_SINGLE_in_globalStmt310 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMENT_BLOCK_in_globalStmt317 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcDef_in_globalStmt323 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stateDef_in_globalStmt328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _89_in_stateDef339 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_stateDef341 = new BitSet(new ulong[]{0x0UL,0x8000000UL});
		public static readonly BitSet _stateBlock_in_stateDef343 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _82_in_stateDef361 = new BitSet(new ulong[]{0x0UL,0x8000000UL});
		public static readonly BitSet _stateBlock_in_stateDef363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _91_in_stateBlock389 = new BitSet(new ulong[]{0x800800C0UL,0x40000000UL});
		public static readonly BitSet _stateBlockContent_in_stateBlock391 = new BitSet(new ulong[]{0x800800C0UL,0x40000000UL});
		public static readonly BitSet _94_in_stateBlock394 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_stateBlockContent418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMENT_SINGLE_in_stateBlockContent424 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMENT_BLOCK_in_stateBlockContent431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _eventDef_in_stateBlockContent437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_funcDef447 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcDef451 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LPAREN_in_funcDef453 = new BitSet(new ulong[]{0x408000000000UL});
		public static readonly BitSet _paramList_in_funcDef456 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_funcDef460 = new BitSet(new ulong[]{0x0UL,0x8000000UL});
		public static readonly BitSet _funcBlock_in_funcDef462 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _91_in_funcBlock491 = new BitSet(new ulong[]{0x4100840800C0UL,0x4FE84005UL});
		public static readonly BitSet _funcBlockContent_in_funcBlock493 = new BitSet(new ulong[]{0x4100840800C0UL,0x4FE84005UL});
		public static readonly BitSet _94_in_funcBlock496 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcBlock_in_statement516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcBlockContent_in_statement521 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMI_in_exprStatement532 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_exprStatement537 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_exprStatement539 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _78_in_label553 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_label555 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMI_in_funcBlockContent578 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_funcBlockContent585 = new BitSet(new ulong[]{0x4080000UL});
		public static readonly BitSet _lhs_in_funcBlockContent588 = new BitSet(new ulong[]{0x4400000000000010UL,0x215AUL});
		public static readonly BitSet _68_in_funcBlockContent591 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent595 = new BitSet(new ulong[]{0x4400000000000010UL,0x214AUL});
		public static readonly BitSet _ASSIGN_EQ_in_funcBlockContent602 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _65_in_funcBlockContent608 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _67_in_funcBlockContent614 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _62_in_funcBlockContent620 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _70_in_funcBlockContent626 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _58_in_funcBlockContent632 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _72_in_funcBlockContent638 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _77_in_funcBlockContent644 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_funcBlockContent647 = new BitSet(new ulong[]{0x18000000000UL});
		public static readonly BitSet _RPAREN_in_funcBlockContent649 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _86_in_funcBlockContent701 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LPAREN_in_funcBlockContent703 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_funcBlockContent705 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_funcBlockContent707 = new BitSet(new ulong[]{0x4100840800C0UL,0xFE84005UL});
		public static readonly BitSet _statement_in_funcBlockContent711 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _84_in_funcBlockContent714 = new BitSet(new ulong[]{0x4100840800C0UL,0xFE84005UL});
		public static readonly BitSet _statement_in_funcBlockContent718 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _90_in_funcBlockContent753 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LPAREN_in_funcBlockContent755 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_funcBlockContent757 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_funcBlockContent759 = new BitSet(new ulong[]{0x4100840800C0UL,0xFE84005UL});
		public static readonly BitSet _statement_in_funcBlockContent761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _85_in_funcBlockContent781 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LPAREN_in_funcBlockContent783 = new BitSet(new ulong[]{0x8011004C488000UL,0x80008005UL});
		public static readonly BitSet _exprStatement_in_funcBlockContent787 = new BitSet(new ulong[]{0x8011004C488000UL,0x80008005UL});
		public static readonly BitSet _exprStatement_in_funcBlockContent791 = new BitSet(new ulong[]{0x8010804C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_funcBlockContent795 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_funcBlockContent798 = new BitSet(new ulong[]{0x4100840800C0UL,0xFE84005UL});
		public static readonly BitSet _statement_in_funcBlockContent800 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _83_in_funcBlockContent831 = new BitSet(new ulong[]{0x4100840800C0UL,0xFE84005UL});
		public static readonly BitSet _statement_in_funcBlockContent833 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _90_in_funcBlockContent835 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LPAREN_in_funcBlockContent837 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_funcBlockContent839 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_funcBlockContent841 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent843 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varDecl_in_funcBlockContent864 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcCall_in_funcBlockContent869 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _64_in_funcBlockContent884 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent886 = new BitSet(new ulong[]{0x10000000000UL,0x10UL});
		public static readonly BitSet _68_in_funcBlockContent889 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent893 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent897 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_funcBlockContent946 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent948 = new BitSet(new ulong[]{0x10000000000UL,0x10UL});
		public static readonly BitSet _68_in_funcBlockContent951 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent955 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent959 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_funcBlockContent1006 = new BitSet(new ulong[]{0x0UL,0x11UL});
		public static readonly BitSet _68_in_funcBlockContent1009 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent1013 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_funcBlockContent1017 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent1019 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_funcBlockContent1068 = new BitSet(new ulong[]{0x0UL,0x14UL});
		public static readonly BitSet _68_in_funcBlockContent1071 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent1075 = new BitSet(new ulong[]{0x0UL,0x4UL});
		public static readonly BitSet _66_in_funcBlockContent1079 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent1081 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _88_in_funcBlockContent1132 = new BitSet(new ulong[]{0x8011004C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_funcBlockContent1134 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent1137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _89_in_funcBlockContent1154 = new BitSet(new ulong[]{0x80000UL,0x40000UL});
		public static readonly BitSet _ID_in_funcBlockContent1157 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _82_in_funcBlockContent1161 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent1164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _label_in_funcBlockContent1179 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent1181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _87_in_funcBlockContent1187 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_funcBlockContent1189 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcBlockContent1191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcBlock_in_funcBlockContent1204 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_funcBlockContent1210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMENT_SINGLE_in_funcBlockContent1216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMENT_BLOCK_in_funcBlockContent1223 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_lhs1235 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_funcCall1252 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LPAREN_in_funcCall1254 = new BitSet(new ulong[]{0x8010804C488000UL,0x80008005UL});
		public static readonly BitSet _callParamList_in_funcCall1256 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_funcCall1258 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_funcCall1260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_eventDef1280 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _LPAREN_in_eventDef1282 = new BitSet(new ulong[]{0x408000000000UL});
		public static readonly BitSet _paramList_in_eventDef1285 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_eventDef1289 = new BitSet(new ulong[]{0x0UL,0x8000000UL});
		public static readonly BitSet _funcBlock_in_eventDef1291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _paramDecl_in_paramList1318 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _COMMA_in_paramList1321 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _paramDecl_in_paramList1323 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _TYPE_in_paramDecl1342 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_paramDecl1344 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_varDecl1365 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_varDecl1367 = new BitSet(new ulong[]{0x10000000010UL});
		public static readonly BitSet _ASSIGN_EQ_in_varDecl1370 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_varDecl1372 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _SEMI_in_varDecl1376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_callParamList1402 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _COMMA_in_callParamList1405 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_callParamList1407 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _expr_in_expression1440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expr1463 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanExpression_in_assignmentExpression1475 = new BitSet(new ulong[]{0x4400000000000012UL,0x214AUL});
		public static readonly BitSet _ASSIGN_EQ_in_assignmentExpression1479 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _65_in_assignmentExpression1484 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _67_in_assignmentExpression1489 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _62_in_assignmentExpression1494 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _70_in_assignmentExpression1499 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _58_in_assignmentExpression1504 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _72_in_assignmentExpression1509 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _77_in_assignmentExpression1514 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression1518 = new BitSet(new ulong[]{0x4400000000000012UL,0x214AUL});
		public static readonly BitSet _bitwiseExpression_in_booleanExpression1532 = new BitSet(new ulong[]{0x800000000000002UL,0x20000000UL});
		public static readonly BitSet _93_in_booleanExpression1536 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _59_in_booleanExpression1541 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _bitwiseExpression_in_booleanExpression1545 = new BitSet(new ulong[]{0x800000000000002UL,0x20000000UL});
		public static readonly BitSet _equalityExpression_in_bitwiseExpression1558 = new BitSet(new ulong[]{0x1000000000000002UL,0x10020000UL});
		public static readonly BitSet _92_in_bitwiseExpression1562 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _60_in_bitwiseExpression1567 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _81_in_bitwiseExpression1572 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _equalityExpression_in_bitwiseExpression1576 = new BitSet(new ulong[]{0x1000000000000002UL,0x10020000UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression1591 = new BitSet(new ulong[]{0x100000000000002UL,0x400UL});
		public static readonly BitSet _56_in_equalityExpression1595 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _74_in_equalityExpression1600 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression1604 = new BitSet(new ulong[]{0x100000000000002UL,0x400UL});
		public static readonly BitSet _binaryBitwiseExpression_in_relationalExpression1617 = new BitSet(new ulong[]{0x8040002UL,0xA00UL});
		public static readonly BitSet _LT_in_relationalExpression1621 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _GT_in_relationalExpression1630 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _73_in_relationalExpression1635 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _75_in_relationalExpression1644 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _binaryBitwiseExpression_in_relationalExpression1650 = new BitSet(new ulong[]{0x8040002UL,0xA00UL});
		public static readonly BitSet _additiveExpression_in_binaryBitwiseExpression1663 = new BitSet(new ulong[]{0x2UL,0x1080UL});
		public static readonly BitSet _71_in_binaryBitwiseExpression1667 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _76_in_binaryBitwiseExpression1672 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _additiveExpression_in_binaryBitwiseExpression1676 = new BitSet(new ulong[]{0x2UL,0x1080UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression1689 = new BitSet(new ulong[]{0x8000000040000002UL});
		public static readonly BitSet _63_in_additiveExpression1693 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _MINUS_in_additiveExpression1698 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression1702 = new BitSet(new ulong[]{0x8000000040000002UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression1716 = new BitSet(new ulong[]{0x2200000000000002UL,0x20UL});
		public static readonly BitSet _61_in_multiplicativeExpression1720 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression1723 = new BitSet(new ulong[]{0x2200000000000002UL,0x20UL});
		public static readonly BitSet _69_in_multiplicativeExpression1727 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression1730 = new BitSet(new ulong[]{0x2200000000000002UL,0x20UL});
		public static readonly BitSet _57_in_multiplicativeExpression1734 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression1737 = new BitSet(new ulong[]{0x2200000000000002UL,0x20UL});
		public static readonly BitSet _MINUS_in_unaryExpression1755 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression1757 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _55_in_unaryExpression1773 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression1775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _95_in_unaryExpression1791 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression1793 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeCastExpression_in_unaryExpression1807 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_typeCastExpression1818 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _TYPE_in_typeCastExpression1820 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_typeCastExpression1822 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _unaryExpression_in_typeCastExpression1824 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preIncDecExpression_in_typeCastExpression1839 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _64_in_preIncDecExpression1852 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _postfixExpression_in_preIncDecExpression1854 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_preIncDecExpression1871 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _postfixExpression_in_preIncDecExpression1873 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_preIncDecExpression1887 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primary_in_postfixExpression1904 = new BitSet(new ulong[]{0x4000002UL,0x15UL});
		public static readonly BitSet _LPAREN_in_postfixExpression1923 = new BitSet(new ulong[]{0x8010804C488000UL,0x80008005UL});
		public static readonly BitSet _callParamList_in_postfixExpression1926 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_postfixExpression1928 = new BitSet(new ulong[]{0x4000002UL,0x15UL});
		public static readonly BitSet _64_in_postfixExpression1943 = new BitSet(new ulong[]{0x4000002UL,0x15UL});
		public static readonly BitSet _66_in_postfixExpression1958 = new BitSet(new ulong[]{0x4000002UL,0x15UL});
		public static readonly BitSet _68_in_postfixExpression1973 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_postfixExpression1976 = new BitSet(new ulong[]{0x4000002UL,0x15UL});
		public static readonly BitSet _STRING_LITERAL_in_primary2011 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_LITERAL_in_primary2016 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_LITERAL_in_primary2022 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vecLiteral_in_primary2027 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _listLiteral_in_primary2032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rotLiteral_in_primary2037 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary2042 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_primary2047 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expression_in_primary2049 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _RPAREN_in_primary2051 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_vecLiteral2071 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_vecLiteral2073 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_vecLiteral2075 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_vecLiteral2077 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_vecLiteral2079 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_vecLiteral2081 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _GT_in_vecLiteral2083 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_rotLiteral2117 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_rotLiteral2119 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_rotLiteral2121 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_rotLiteral2123 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_rotLiteral2125 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_rotLiteral2127 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_rotLiteral2129 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_rotLiteral2131 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _GT_in_rotLiteral2133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _79_in_listLiteral2165 = new BitSet(new ulong[]{0x8010004C488000UL,0x80018005UL});
		public static readonly BitSet _listContents_in_listLiteral2167 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _80_in_listLiteral2169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_listContents2189 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _COMMA_in_listContents2192 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _expr_in_listContents2194 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _funcBlock_in_synpred15_LSL516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _84_in_synpred29_LSL714 = new BitSet(new ulong[]{0x4100840800C0UL,0xFE84005UL});
		public static readonly BitSet _statement_in_synpred29_LSL718 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_synpred66_LSL1478 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _assignmentExpression_in_synpred66_LSL1518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_synpred75_LSL1630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred77_LSL1621 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _GT_in_synpred77_LSL1630 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _73_in_synpred77_LSL1635 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _75_in_synpred77_LSL1644 = new BitSet(new ulong[]{0x8010004C488000UL,0x80008005UL});
		public static readonly BitSet _binaryBitwiseExpression_in_synpred77_LSL1650 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vecLiteral_in_synpred98_LSL2027 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rotLiteral_in_synpred100_LSL2037 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  Halcyon.Phlox.Compiler 
