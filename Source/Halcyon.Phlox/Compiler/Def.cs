//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 Def.g 2012-05-22 12:14:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
namespace  Halcyon.Phlox.Compiler 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class Def : Antlr.Runtime.Tree.TreeFilter
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN_EQ", "COMMA", "COMMENT_BLOCK", "COMMENT_SINGLE", "DO_WHILE_STMT", "ELIST", "ELSE_PART", "ESC_SEQ", "EVENT_DEF", "EXPONENT", "EXPR", "FLOAT_LITERAL", "FOR_STMT", "FUNC_BLOCK", "GT", "ID", "IF_STMT", "INDEX", "INTEGER_LITERAL", "JUMP_STMT", "LABEL", "LIST_LITERAL", "LPAREN", "LT", "METHOD_CALL", "METHOD_DEF", "MINUS", "NEWLINE", "PARAM_DECL", "POST_DECREMENT", "POST_INCREMENT", "PRE_DECREMENT", "PRE_INCREMENT", "RETURN_STMT", "ROTATION_LITERAL", "RPAREN", "SEMI", "STATE_BLOCK", "STATE_CHG", "STATE_DEF", "STRING_LITERAL", "SUBSCRIPT", "TYPE", "TYPE_CAST", "UNARY_BIT_NOT", "UNARY_BOOL_NOT", "UNARY_MINUS", "VAR_DECL", "VECTOR_LITERAL", "WHILE_STMT", "WS", "'!'", "'!='", "'%'", "'%='", "'&&'", "'&'", "'*'", "'*='", "'+'", "'++'", "'+='", "'--'", "'-='", "'.'", "'/'", "'/='", "'<<'", "'<<='", "'<='", "'=='", "'>='", "'>>'", "'>>='", "'@'", "'['", "']'", "'^'", "'default'", "'do'", "'else'", "'for'", "'if'", "'jump'", "'return'", "'state'", "'while'", "'{'", "'|'", "'||'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int ASSIGN_EQ=4;
	public const int COMMA=5;
	public const int COMMENT_BLOCK=6;
	public const int COMMENT_SINGLE=7;
	public const int DO_WHILE_STMT=8;
	public const int ELIST=9;
	public const int ELSE_PART=10;
	public const int ESC_SEQ=11;
	public const int EVENT_DEF=12;
	public const int EXPONENT=13;
	public const int EXPR=14;
	public const int FLOAT_LITERAL=15;
	public const int FOR_STMT=16;
	public const int FUNC_BLOCK=17;
	public const int GT=18;
	public const int ID=19;
	public const int IF_STMT=20;
	public const int INDEX=21;
	public const int INTEGER_LITERAL=22;
	public const int JUMP_STMT=23;
	public const int LABEL=24;
	public const int LIST_LITERAL=25;
	public const int LPAREN=26;
	public const int LT=27;
	public const int METHOD_CALL=28;
	public const int METHOD_DEF=29;
	public const int MINUS=30;
	public const int NEWLINE=31;
	public const int PARAM_DECL=32;
	public const int POST_DECREMENT=33;
	public const int POST_INCREMENT=34;
	public const int PRE_DECREMENT=35;
	public const int PRE_INCREMENT=36;
	public const int RETURN_STMT=37;
	public const int ROTATION_LITERAL=38;
	public const int RPAREN=39;
	public const int SEMI=40;
	public const int STATE_BLOCK=41;
	public const int STATE_CHG=42;
	public const int STATE_DEF=43;
	public const int STRING_LITERAL=44;
	public const int SUBSCRIPT=45;
	public const int TYPE=46;
	public const int TYPE_CAST=47;
	public const int UNARY_BIT_NOT=48;
	public const int UNARY_BOOL_NOT=49;
	public const int UNARY_MINUS=50;
	public const int VAR_DECL=51;
	public const int VECTOR_LITERAL=52;
	public const int WHILE_STMT=53;
	public const int WS=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;

	// delegates
	// delegators

	public Def( ITreeNodeStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public Def(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return Def.tokenNames; } }
	public override string GrammarFileName { get { return "Def.g"; } }


		SymbolTable symtab;
		IScope currentScope;
		MethodSymbol currentMethod;
		EventSymbol currentEvent;

		int currentLabel = 0;
		
		public Def(ITreeNodeStream input, SymbolTable symtab) : this(input) {
			this.symtab = symtab;
			currentScope = symtab.Globals;
		}
		
		protected override void Topdown() { topdown(); }
		protected override void Bottomup() { bottomup(); }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_topdown();
	partial void LeaveRule_topdown();

	// $ANTLR start "topdown"
	// Def.g:30:1: topdown : ( enterFuncBlock | methodDef | atoms | varDeclaration | methodDefParam | eventDef | stateBlockDef | returnStmt | labelDef | jumpStmt );
	[GrammarRule("topdown")]
	private void topdown()
	{
		EnterRule_topdown();
		EnterRule("topdown", 1);
		TraceIn("topdown", 1);
		try { DebugEnterRule(GrammarFileName, "topdown");
		DebugLocation(30, 1);
		try
		{
			// Def.g:30:8: ( enterFuncBlock | methodDef | atoms | varDeclaration | methodDefParam | eventDef | stateBlockDef | returnStmt | labelDef | jumpStmt )
			int alt1=10;
			try { DebugEnterDecision(1, false);
			try
			{
				alt1 = dfa1.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Def.g:31:3: enterFuncBlock
				{
				DebugLocation(31, 3);
				PushFollow(Follow._enterFuncBlock_in_topdown64);
				enterFuncBlock();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Def.g:32:4: methodDef
				{
				DebugLocation(32, 4);
				PushFollow(Follow._methodDef_in_topdown70);
				methodDef();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Def.g:33:4: atoms
				{
				DebugLocation(33, 4);
				PushFollow(Follow._atoms_in_topdown75);
				atoms();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Def.g:34:4: varDeclaration
				{
				DebugLocation(34, 4);
				PushFollow(Follow._varDeclaration_in_topdown80);
				varDeclaration();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Def.g:35:4: methodDefParam
				{
				DebugLocation(35, 4);
				PushFollow(Follow._methodDefParam_in_topdown85);
				methodDefParam();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Def.g:36:4: eventDef
				{
				DebugLocation(36, 4);
				PushFollow(Follow._eventDef_in_topdown90);
				eventDef();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Def.g:37:4: stateBlockDef
				{
				DebugLocation(37, 4);
				PushFollow(Follow._stateBlockDef_in_topdown95);
				stateBlockDef();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Def.g:38:4: returnStmt
				{
				DebugLocation(38, 4);
				PushFollow(Follow._returnStmt_in_topdown100);
				returnStmt();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Def.g:39:4: labelDef
				{
				DebugLocation(39, 4);
				PushFollow(Follow._labelDef_in_topdown105);
				labelDef();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Def.g:40:4: jumpStmt
				{
				DebugLocation(40, 4);
				PushFollow(Follow._jumpStmt_in_topdown110);
				jumpStmt();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("topdown", 1);
			LeaveRule("topdown", 1);
			LeaveRule_topdown();
		}
		DebugLocation(41, 1);
		} finally { DebugExitRule(GrammarFileName, "topdown"); }
		return;

	}
	// $ANTLR end "topdown"


	partial void EnterRule_bottomup();
	partial void LeaveRule_bottomup();

	// $ANTLR start "bottomup"
	// Def.g:43:1: bottomup : ( exitMethodDef | exitEventDef | exitStateDef | exitFuncBlock );
	[GrammarRule("bottomup")]
	private void bottomup()
	{
		EnterRule_bottomup();
		EnterRule("bottomup", 2);
		TraceIn("bottomup", 2);
		try { DebugEnterRule(GrammarFileName, "bottomup");
		DebugLocation(43, 1);
		try
		{
			// Def.g:43:9: ( exitMethodDef | exitEventDef | exitStateDef | exitFuncBlock )
			int alt2=4;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case METHOD_DEF:
				{
				alt2 = 1;
				}
				break;
			case EVENT_DEF:
				{
				alt2 = 2;
				}
				break;
			case STATE_DEF:
				{
				alt2 = 3;
				}
				break;
			case FUNC_BLOCK:
				{
				alt2 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Def.g:44:3: exitMethodDef
				{
				DebugLocation(44, 3);
				PushFollow(Follow._exitMethodDef_in_bottomup123);
				exitMethodDef();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Def.g:45:4: exitEventDef
				{
				DebugLocation(45, 4);
				PushFollow(Follow._exitEventDef_in_bottomup128);
				exitEventDef();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Def.g:46:4: exitStateDef
				{
				DebugLocation(46, 4);
				PushFollow(Follow._exitStateDef_in_bottomup133);
				exitStateDef();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Def.g:47:4: exitFuncBlock
				{
				DebugLocation(47, 4);
				PushFollow(Follow._exitFuncBlock_in_bottomup138);
				exitFuncBlock();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bottomup", 2);
			LeaveRule("bottomup", 2);
			LeaveRule_bottomup();
		}
		DebugLocation(48, 1);
		} finally { DebugExitRule(GrammarFileName, "bottomup"); }
		return;

	}
	// $ANTLR end "bottomup"


	partial void EnterRule_jumpStmt();
	partial void LeaveRule_jumpStmt();

	// $ANTLR start "jumpStmt"
	// Def.g:50:1: jumpStmt : ^( JUMP_STMT ID ) ;
	[GrammarRule("jumpStmt")]
	private void jumpStmt()
	{
		EnterRule_jumpStmt();
		EnterRule("jumpStmt", 3);
		TraceIn("jumpStmt", 3);
		LSLAst JUMP_STMT1 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "jumpStmt");
		DebugLocation(50, 1);
		try
		{
			// Def.g:50:9: ( ^( JUMP_STMT ID ) )
			DebugEnterAlt(1);
			// Def.g:50:11: ^( JUMP_STMT ID )
			{
			DebugLocation(50, 11);
			DebugLocation(50, 13);
			JUMP_STMT1=(LSLAst)Match(input,JUMP_STMT,Follow._JUMP_STMT_in_jumpStmt148); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(50, 23);
			Match(input,ID,Follow._ID_in_jumpStmt150); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(51, 3);
			if (state.backtracking == 1)
			{

							JUMP_STMT1.scope = currentScope;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("jumpStmt", 3);
			LeaveRule("jumpStmt", 3);
			LeaveRule_jumpStmt();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "jumpStmt"); }
		return;

	}
	// $ANTLR end "jumpStmt"


	partial void EnterRule_labelDef();
	partial void LeaveRule_labelDef();

	// $ANTLR start "labelDef"
	// Def.g:56:1: labelDef : ^( LABEL ID ) ;
	[GrammarRule("labelDef")]
	private void labelDef()
	{
		EnterRule_labelDef();
		EnterRule("labelDef", 4);
		TraceIn("labelDef", 4);
		LSLAst ID2 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "labelDef");
		DebugLocation(56, 1);
		try
		{
			// Def.g:56:9: ( ^( LABEL ID ) )
			DebugEnterAlt(1);
			// Def.g:56:11: ^( LABEL ID )
			{
			DebugLocation(56, 11);
			DebugLocation(56, 13);
			Match(input,LABEL,Follow._LABEL_in_labelDef165); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(56, 19);
			ID2=(LSLAst)Match(input,ID,Follow._ID_in_labelDef167); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(57, 3);
			if (state.backtracking == 1)
			{

							LabelSymbol label = new LabelSymbol((ID2!=null?ID2.Text:null), currentLabel++);
							label.Def = ID2;            // track AST location of def's ID
							ID2.symbol = label;
							symtab.Define(label, currentScope);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("labelDef", 4);
			LeaveRule("labelDef", 4);
			LeaveRule_labelDef();
		}
		DebugLocation(63, 1);
		} finally { DebugExitRule(GrammarFileName, "labelDef"); }
		return;

	}
	// $ANTLR end "labelDef"


	partial void EnterRule_returnStmt();
	partial void LeaveRule_returnStmt();

	// $ANTLR start "returnStmt"
	// Def.g:65:1: returnStmt : RETURN_STMT ;
	[GrammarRule("returnStmt")]
	private void returnStmt()
	{
		EnterRule_returnStmt();
		EnterRule("returnStmt", 5);
		TraceIn("returnStmt", 5);
		LSLAst RETURN_STMT3 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "returnStmt");
		DebugLocation(65, 1);
		try
		{
			// Def.g:66:2: ( RETURN_STMT )
			DebugEnterAlt(1);
			// Def.g:66:4: RETURN_STMT
			{
			DebugLocation(66, 4);
			RETURN_STMT3=(LSLAst)Match(input,RETURN_STMT,Follow._RETURN_STMT_in_returnStmt183); if (state.failed) return;
			DebugLocation(67, 3);
			if (state.backtracking == 1)
			{

							if (currentMethod != null)
							{
								RETURN_STMT3.symbol = currentMethod;
							}
							else if (currentEvent != null)
							{
								RETURN_STMT3.symbol = currentEvent;
							}
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("returnStmt", 5);
			LeaveRule("returnStmt", 5);
			LeaveRule_returnStmt();
		}
		DebugLocation(77, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStmt"); }
		return;

	}
	// $ANTLR end "returnStmt"


	partial void EnterRule_methodDef();
	partial void LeaveRule_methodDef();

	// $ANTLR start "methodDef"
	// Def.g:79:1: methodDef : ^( METHOD_DEF ( type )? ID ( . )* ) ;
	[GrammarRule("methodDef")]
	private void methodDef()
	{
		EnterRule_methodDef();
		EnterRule("methodDef", 6);
		TraceIn("methodDef", 6);
		LSLAst ID5 = default(LSLAst);
		ISymbolType type4 = default(ISymbolType);

		try { DebugEnterRule(GrammarFileName, "methodDef");
		DebugLocation(79, 1);
		try
		{
			// Def.g:80:2: ( ^( METHOD_DEF ( type )? ID ( . )* ) )
			DebugEnterAlt(1);
			// Def.g:80:4: ^( METHOD_DEF ( type )? ID ( . )* )
			{
			DebugLocation(80, 4);
			DebugLocation(80, 6);
			Match(input,METHOD_DEF,Follow._METHOD_DEF_in_methodDef199); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(80, 17);
			// Def.g:80:17: ( type )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==TYPE))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Def.g:80:17: type
				{
				DebugLocation(80, 17);
				PushFollow(Follow._type_in_methodDef201);
				type4=type();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(80, 23);
			ID5=(LSLAst)Match(input,ID,Follow._ID_in_methodDef204); if (state.failed) return;
			DebugLocation(80, 26);
			// Def.g:80:26: ( . )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if (((LA4_0>=ASSIGN_EQ && LA4_0<=95)))
				{
					alt4 = 1;
				}
				else if ((LA4_0==UP))
				{
					alt4 = 2;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// Def.g:80:26: .
					{
					DebugLocation(80, 26);
					MatchAny(input); if (state.failed) return;

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(81, 3);
			if (state.backtracking == 1)
			{

							MethodSymbol methSym;
							if (type4 == null)
							{
								methSym = new MethodSymbol((ID5!=null?ID5.Text:null), SymbolTable.VOID, currentScope);
							}
							else
							{
								methSym = new MethodSymbol((ID5!=null?ID5.Text:null), type4, currentScope);
							}
							
							symtab.Define(methSym, currentScope);

							methSym.Def = ID5;            // track AST location of def's ID
							ID5.symbol = methSym;         // track in AST

							currentMethod = methSym;
							currentEvent = null;
							currentScope = methSym;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodDef", 6);
			LeaveRule("methodDef", 6);
			LeaveRule_methodDef();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "methodDef"); }
		return;

	}
	// $ANTLR end "methodDef"


	partial void EnterRule_eventDef();
	partial void LeaveRule_eventDef();

	// $ANTLR start "eventDef"
	// Def.g:103:1: eventDef : ^( EVENT_DEF ID ( . )* ) ;
	[GrammarRule("eventDef")]
	private void eventDef()
	{
		EnterRule_eventDef();
		EnterRule("eventDef", 7);
		TraceIn("eventDef", 7);
		LSLAst ID6 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "eventDef");
		DebugLocation(103, 1);
		try
		{
			// Def.g:104:2: ( ^( EVENT_DEF ID ( . )* ) )
			DebugEnterAlt(1);
			// Def.g:104:4: ^( EVENT_DEF ID ( . )* )
			{
			DebugLocation(104, 4);
			DebugLocation(104, 6);
			Match(input,EVENT_DEF,Follow._EVENT_DEF_in_eventDef224); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(104, 16);
			ID6=(LSLAst)Match(input,ID,Follow._ID_in_eventDef226); if (state.failed) return;
			DebugLocation(104, 19);
			// Def.g:104:19: ( . )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if (((LA5_0>=ASSIGN_EQ && LA5_0<=95)))
				{
					alt5 = 1;
				}
				else if ((LA5_0==UP))
				{
					alt5 = 2;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Def.g:104:19: .
					{
					DebugLocation(104, 19);
					MatchAny(input); if (state.failed) return;

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(105, 3);
			if (state.backtracking == 1)
			{

							EventSymbol evtSym = new EventSymbol((ID6!=null?ID6.Text:null), currentScope);
							evtSym.Def = ID6;            // track AST location of def's ID
				        		ID6.symbol = evtSym;         // track in AST
							symtab.Define(evtSym, currentScope);
							currentEvent = evtSym;
							currentMethod = null;
							currentScope = evtSym;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("eventDef", 7);
			LeaveRule("eventDef", 7);
			LeaveRule_eventDef();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "eventDef"); }
		return;

	}
	// $ANTLR end "eventDef"


	partial void EnterRule_exitMethodDef();
	partial void LeaveRule_exitMethodDef();

	// $ANTLR start "exitMethodDef"
	// Def.g:116:1: exitMethodDef : METHOD_DEF ;
	[GrammarRule("exitMethodDef")]
	private void exitMethodDef()
	{
		EnterRule_exitMethodDef();
		EnterRule("exitMethodDef", 8);
		TraceIn("exitMethodDef", 8);
		try { DebugEnterRule(GrammarFileName, "exitMethodDef");
		DebugLocation(116, 1);
		try
		{
			// Def.g:117:2: ( METHOD_DEF )
			DebugEnterAlt(1);
			// Def.g:117:4: METHOD_DEF
			{
			DebugLocation(117, 4);
			Match(input,METHOD_DEF,Follow._METHOD_DEF_in_exitMethodDef246); if (state.failed) return;
			DebugLocation(118, 3);
			if (state.backtracking == 1)
			{

							currentScope = currentScope.EnclosingScope;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exitMethodDef", 8);
			LeaveRule("exitMethodDef", 8);
			LeaveRule_exitMethodDef();
		}
		DebugLocation(121, 1);
		} finally { DebugExitRule(GrammarFileName, "exitMethodDef"); }
		return;

	}
	// $ANTLR end "exitMethodDef"


	partial void EnterRule_exitEventDef();
	partial void LeaveRule_exitEventDef();

	// $ANTLR start "exitEventDef"
	// Def.g:123:1: exitEventDef : ^( EVENT_DEF ID ( . )* ) ;
	[GrammarRule("exitEventDef")]
	private void exitEventDef()
	{
		EnterRule_exitEventDef();
		EnterRule("exitEventDef", 9);
		TraceIn("exitEventDef", 9);
		LSLAst ID7 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "exitEventDef");
		DebugLocation(123, 1);
		try
		{
			// Def.g:124:2: ( ^( EVENT_DEF ID ( . )* ) )
			DebugEnterAlt(1);
			// Def.g:124:4: ^( EVENT_DEF ID ( . )* )
			{
			DebugLocation(124, 4);
			DebugLocation(124, 6);
			Match(input,EVENT_DEF,Follow._EVENT_DEF_in_exitEventDef262); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(124, 16);
			ID7=(LSLAst)Match(input,ID,Follow._ID_in_exitEventDef264); if (state.failed) return;
			DebugLocation(124, 19);
			// Def.g:124:19: ( . )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if (((LA6_0>=ASSIGN_EQ && LA6_0<=95)))
				{
					alt6 = 1;
				}
				else if ((LA6_0==UP))
				{
					alt6 = 2;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Def.g:124:19: .
					{
					DebugLocation(124, 19);
					MatchAny(input); if (state.failed) return;

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(125, 3);
			if (state.backtracking == 1)
			{

							symtab.CheckEvt(currentScope, ID7);
							currentScope = currentScope.EnclosingScope;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exitEventDef", 9);
			LeaveRule("exitEventDef", 9);
			LeaveRule_exitEventDef();
		}
		DebugLocation(129, 1);
		} finally { DebugExitRule(GrammarFileName, "exitEventDef"); }
		return;

	}
	// $ANTLR end "exitEventDef"


	partial void EnterRule_methodDefParam();
	partial void LeaveRule_methodDefParam();

	// $ANTLR start "methodDefParam"
	// Def.g:131:1: methodDefParam : ^( PARAM_DECL type ID ) ;
	[GrammarRule("methodDefParam")]
	private void methodDefParam()
	{
		EnterRule_methodDefParam();
		EnterRule("methodDefParam", 10);
		TraceIn("methodDefParam", 10);
		LSLAst ID8 = default(LSLAst);
		ISymbolType type9 = default(ISymbolType);

		try { DebugEnterRule(GrammarFileName, "methodDefParam");
		DebugLocation(131, 1);
		try
		{
			// Def.g:132:2: ( ^( PARAM_DECL type ID ) )
			DebugEnterAlt(1);
			// Def.g:132:4: ^( PARAM_DECL type ID )
			{
			DebugLocation(132, 4);
			DebugLocation(132, 6);
			Match(input,PARAM_DECL,Follow._PARAM_DECL_in_methodDefParam284); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(132, 17);
			PushFollow(Follow._type_in_methodDefParam286);
			type9=type();
			PopFollow();
			if (state.failed) return;
			DebugLocation(132, 22);
			ID8=(LSLAst)Match(input,ID,Follow._ID_in_methodDefParam288); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(133, 3);
			if (state.backtracking == 1)
			{

							VariableSymbol varSym = new VariableSymbol((ID8!=null?ID8.Text:null), type9);
							symtab.Define(varSym, currentScope);
							varSym.Def = ID8;            // track AST location of def's ID
							ID8.symbol = varSym;         // track in AST
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodDefParam", 10);
			LeaveRule("methodDefParam", 10);
			LeaveRule_methodDefParam();
		}
		DebugLocation(139, 1);
		} finally { DebugExitRule(GrammarFileName, "methodDefParam"); }
		return;

	}
	// $ANTLR end "methodDefParam"


	partial void EnterRule_stateBlockDef();
	partial void LeaveRule_stateBlockDef();

	// $ANTLR start "stateBlockDef"
	// Def.g:141:1: stateBlockDef : ^( STATE_DEF ident= . ( . )* ) ;
	[GrammarRule("stateBlockDef")]
	private void stateBlockDef()
	{
		EnterRule_stateBlockDef();
		EnterRule("stateBlockDef", 11);
		TraceIn("stateBlockDef", 11);
		LSLAst ident = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "stateBlockDef");
		DebugLocation(141, 1);
		try
		{
			// Def.g:142:2: ( ^( STATE_DEF ident= . ( . )* ) )
			DebugEnterAlt(1);
			// Def.g:142:4: ^( STATE_DEF ident= . ( . )* )
			{
			DebugLocation(142, 4);
			DebugLocation(142, 6);
			Match(input,STATE_DEF,Follow._STATE_DEF_in_stateBlockDef307); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(142, 21);
			ident=(LSLAst)input.LT(1);
			MatchAny(input); if (state.failed) return;
			DebugLocation(142, 24);
			// Def.g:142:24: ( . )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if (((LA7_0>=ASSIGN_EQ && LA7_0<=95)))
				{
					alt7 = 1;
				}
				else if ((LA7_0==UP))
				{
					alt7 = 2;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// Def.g:142:24: .
					{
					DebugLocation(142, 24);
					MatchAny(input); if (state.failed) return;

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(143, 3);
			if (state.backtracking == 1)
			{

							StateSymbol stateSym = new StateSymbol(ident.Text, currentScope);
							stateSym.Def = ident;            // track AST location of def's ID
						        ident.symbol = stateSym;         // track in AST
						        symtab.Define(stateSym, currentScope);
						        
						        currentScope = stateSym;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stateBlockDef", 11);
			LeaveRule("stateBlockDef", 11);
			LeaveRule_stateBlockDef();
		}
		DebugLocation(151, 1);
		} finally { DebugExitRule(GrammarFileName, "stateBlockDef"); }
		return;

	}
	// $ANTLR end "stateBlockDef"


	partial void EnterRule_exitStateDef();
	partial void LeaveRule_exitStateDef();

	// $ANTLR start "exitStateDef"
	// Def.g:154:1: exitStateDef : STATE_DEF ;
	[GrammarRule("exitStateDef")]
	private void exitStateDef()
	{
		EnterRule_exitStateDef();
		EnterRule("exitStateDef", 12);
		TraceIn("exitStateDef", 12);
		try { DebugEnterRule(GrammarFileName, "exitStateDef");
		DebugLocation(154, 1);
		try
		{
			// Def.g:155:2: ( STATE_DEF )
			DebugEnterAlt(1);
			// Def.g:155:4: STATE_DEF
			{
			DebugLocation(155, 4);
			Match(input,STATE_DEF,Follow._STATE_DEF_in_exitStateDef333); if (state.failed) return;
			DebugLocation(156, 3);
			if (state.backtracking == 1)
			{

						        currentScope = currentScope.EnclosingScope;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exitStateDef", 12);
			LeaveRule("exitStateDef", 12);
			LeaveRule_exitStateDef();
		}
		DebugLocation(159, 1);
		} finally { DebugExitRule(GrammarFileName, "exitStateDef"); }
		return;

	}
	// $ANTLR end "exitStateDef"


	partial void EnterRule_enterFuncBlock();
	partial void LeaveRule_enterFuncBlock();

	// $ANTLR start "enterFuncBlock"
	// Def.g:162:1: enterFuncBlock : FUNC_BLOCK ;
	[GrammarRule("enterFuncBlock")]
	private void enterFuncBlock()
	{
		EnterRule_enterFuncBlock();
		EnterRule("enterFuncBlock", 13);
		TraceIn("enterFuncBlock", 13);
		try { DebugEnterRule(GrammarFileName, "enterFuncBlock");
		DebugLocation(162, 1);
		try
		{
			// Def.g:163:2: ( FUNC_BLOCK )
			DebugEnterAlt(1);
			// Def.g:163:4: FUNC_BLOCK
			{
			DebugLocation(163, 4);
			Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_enterFuncBlock351); if (state.failed) return;
			DebugLocation(164, 3);
			if (state.backtracking == 1)
			{

							currentScope = new LocalScope(currentScope);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("enterFuncBlock", 13);
			LeaveRule("enterFuncBlock", 13);
			LeaveRule_enterFuncBlock();
		}
		DebugLocation(167, 1);
		} finally { DebugExitRule(GrammarFileName, "enterFuncBlock"); }
		return;

	}
	// $ANTLR end "enterFuncBlock"


	partial void EnterRule_exitFuncBlock();
	partial void LeaveRule_exitFuncBlock();

	// $ANTLR start "exitFuncBlock"
	// Def.g:169:1: exitFuncBlock : FUNC_BLOCK ;
	[GrammarRule("exitFuncBlock")]
	private void exitFuncBlock()
	{
		EnterRule_exitFuncBlock();
		EnterRule("exitFuncBlock", 14);
		TraceIn("exitFuncBlock", 14);
		try { DebugEnterRule(GrammarFileName, "exitFuncBlock");
		DebugLocation(169, 1);
		try
		{
			// Def.g:170:2: ( FUNC_BLOCK )
			DebugEnterAlt(1);
			// Def.g:170:4: FUNC_BLOCK
			{
			DebugLocation(170, 4);
			Match(input,FUNC_BLOCK,Follow._FUNC_BLOCK_in_exitFuncBlock367); if (state.failed) return;
			DebugLocation(171, 3);
			if (state.backtracking == 1)
			{

							currentScope = currentScope.EnclosingScope;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exitFuncBlock", 14);
			LeaveRule("exitFuncBlock", 14);
			LeaveRule_exitFuncBlock();
		}
		DebugLocation(174, 1);
		} finally { DebugExitRule(GrammarFileName, "exitFuncBlock"); }
		return;

	}
	// $ANTLR end "exitFuncBlock"


	partial void EnterRule_atoms();
	partial void LeaveRule_atoms();

	// $ANTLR start "atoms"
	// Def.g:178:1: atoms :{...}? ID ;
	[GrammarRule("atoms")]
	private void atoms()
	{
		EnterRule_atoms();
		EnterRule("atoms", 15);
		TraceIn("atoms", 15);
		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "atoms");
		DebugLocation(178, 4);
		try
		{
			// Def.g:180:5: ({...}? ID )
			DebugEnterAlt(1);
			// Def.g:180:8: {...}? ID
			{
			DebugLocation(180, 8);
			if (!((t.HasAncestor(EXPR)||t.HasAncestor(ASSIGN_EQ)||t.HasAncestor(METHOD_CALL))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "atoms", "t.HasAncestor(EXPR)||t.HasAncestor(ASSIGN_EQ)||t.HasAncestor(METHOD_CALL)");
			}
			DebugLocation(180, 85);
			Match(input,ID,Follow._ID_in_atoms396); if (state.failed) return;
			DebugLocation(181, 8);
			if (state.backtracking == 1)
			{
				t.scope = currentScope;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atoms", 15);
			LeaveRule("atoms", 15);
			LeaveRule_atoms();
		}
		DebugLocation(182, 4);
		} finally { DebugExitRule(GrammarFileName, "atoms"); }
		return;

	}
	// $ANTLR end "atoms"


	partial void EnterRule_varDeclaration();
	partial void LeaveRule_varDeclaration();

	// $ANTLR start "varDeclaration"
	// Def.g:185:1: varDeclaration : ^( VAR_DECL type ID ( . )* ) ;
	[GrammarRule("varDeclaration")]
	private void varDeclaration()
	{
		EnterRule_varDeclaration();
		EnterRule("varDeclaration", 16);
		TraceIn("varDeclaration", 16);
		LSLAst ID10 = default(LSLAst);
		ISymbolType type11 = default(ISymbolType);

		try { DebugEnterRule(GrammarFileName, "varDeclaration");
		DebugLocation(185, 4);
		try
		{
			// Def.g:186:5: ( ^( VAR_DECL type ID ( . )* ) )
			DebugEnterAlt(1);
			// Def.g:186:9: ^( VAR_DECL type ID ( . )* )
			{
			DebugLocation(186, 9);
			DebugLocation(186, 11);
			Match(input,VAR_DECL,Follow._VAR_DECL_in_varDeclaration427); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(186, 20);
			PushFollow(Follow._type_in_varDeclaration429);
			type11=type();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 25);
			ID10=(LSLAst)Match(input,ID,Follow._ID_in_varDeclaration431); if (state.failed) return;
			DebugLocation(186, 28);
			// Def.g:186:28: ( . )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if (((LA8_0>=ASSIGN_EQ && LA8_0<=95)))
				{
					alt8 = 1;
				}
				else if ((LA8_0==UP))
				{
					alt8 = 2;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Def.g:186:28: .
					{
					DebugLocation(186, 28);
					MatchAny(input); if (state.failed) return;

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(187, 9);
			if (state.backtracking == 1)
			{

				        //System.out.println("line "+ID10.getLine()+": def "+(ID10!=null?ID10.Text:null));
				        VariableSymbol vs = new VariableSymbol((ID10!=null?ID10.Text:null),type11);
				        vs.Def = ID10;            // track AST location of def's ID
				        ID10.symbol = vs;         // track in AST
				        
				        symtab.Define(vs, currentScope);
				        
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("varDeclaration", 16);
			LeaveRule("varDeclaration", 16);
			LeaveRule_varDeclaration();
		}
		DebugLocation(195, 4);
		} finally { DebugExitRule(GrammarFileName, "varDeclaration"); }
		return;

	}
	// $ANTLR end "varDeclaration"


	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// Def.g:198:1: type returns [ISymbolType type] : TYPE ;
	[GrammarRule("type")]
	private ISymbolType type()
	{
		EnterRule_type();
		EnterRule("type", 17);
		TraceIn("type", 17);
		ISymbolType type = default(ISymbolType);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(198, 1);
		try
		{
			// Def.g:205:2: ( TYPE )
			DebugEnterAlt(1);
			// Def.g:205:6: TYPE
			{
			DebugLocation(205, 6);
			Match(input,TYPE,Follow._TYPE_in_type482); if (state.failed) return type;

			}

			if (state.backtracking == 1)
			{

					t.symbol = currentScope.Resolve(t.Text); // return Type
					t.scope = currentScope;
					type = (ISymbolType)t.symbol;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("type", 17);
			LeaveRule("type", 17);
			LeaveRule_type();
		}
		DebugLocation(206, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return type;

	}
	// $ANTLR end "type"
	#endregion Rules


	#region DFA
	private DFA1 dfa1;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa1 = new DFA1( this );
	}

	private class DFA1 : DFA
	{
		private const string DFA1_eotS =
			"\xB\xFFFF";
		private const string DFA1_eofS =
			"\xB\xFFFF";
		private const string DFA1_minS =
			"\x1\xC\xA\xFFFF";
		private const string DFA1_maxS =
			"\x1\x33\xA\xFFFF";
		private const string DFA1_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA";
		private const string DFA1_specialS =
			"\xB\xFFFF}>";
		private static readonly string[] DFA1_transitionS =
			{
				"\x1\x6\x4\xFFFF\x1\x1\x1\xFFFF\x1\x3\x3\xFFFF\x1\xA\x1\x9\x4\xFFFF\x1"+
				"\x2\x2\xFFFF\x1\x5\x4\xFFFF\x1\x8\x5\xFFFF\x1\x7\x7\xFFFF\x1\x4",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA1_eot = DFA.UnpackEncodedString(DFA1_eotS);
		private static readonly short[] DFA1_eof = DFA.UnpackEncodedString(DFA1_eofS);
		private static readonly char[] DFA1_min = DFA.UnpackEncodedStringToUnsignedChars(DFA1_minS);
		private static readonly char[] DFA1_max = DFA.UnpackEncodedStringToUnsignedChars(DFA1_maxS);
		private static readonly short[] DFA1_accept = DFA.UnpackEncodedString(DFA1_acceptS);
		private static readonly short[] DFA1_special = DFA.UnpackEncodedString(DFA1_specialS);
		private static readonly short[][] DFA1_transition;

		static DFA1()
		{
			int numStates = DFA1_transitionS.Length;
			DFA1_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA1_transition[i] = DFA.UnpackEncodedString(DFA1_transitionS[i]);
			}
		}

		public DFA1( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}

		public override string Description { get { return "30:1: topdown : ( enterFuncBlock | methodDef | atoms | varDeclaration | methodDefParam | eventDef | stateBlockDef | returnStmt | labelDef | jumpStmt );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _enterFuncBlock_in_topdown64 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDef_in_topdown70 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atoms_in_topdown75 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varDeclaration_in_topdown80 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDefParam_in_topdown85 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _eventDef_in_topdown90 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stateBlockDef_in_topdown95 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStmt_in_topdown100 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelDef_in_topdown105 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _jumpStmt_in_topdown110 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exitMethodDef_in_bottomup123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exitEventDef_in_bottomup128 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exitStateDef_in_bottomup133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exitFuncBlock_in_bottomup138 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JUMP_STMT_in_jumpStmt148 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_jumpStmt150 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LABEL_in_labelDef165 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_labelDef167 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RETURN_STMT_in_returnStmt183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _METHOD_DEF_in_methodDef199 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _type_in_methodDef201 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_methodDef204 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0xFFFFFFFFUL});
		public static readonly BitSet _EVENT_DEF_in_eventDef224 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_eventDef226 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0xFFFFFFFFUL});
		public static readonly BitSet _METHOD_DEF_in_exitMethodDef246 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EVENT_DEF_in_exitEventDef262 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_exitEventDef264 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0xFFFFFFFFUL});
		public static readonly BitSet _PARAM_DECL_in_methodDefParam284 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _type_in_methodDefParam286 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_methodDefParam288 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STATE_DEF_in_stateBlockDef307 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _STATE_DEF_in_exitStateDef333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNC_BLOCK_in_enterFuncBlock351 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNC_BLOCK_in_exitFuncBlock367 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atoms396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_DECL_in_varDeclaration427 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _type_in_varDeclaration429 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_varDeclaration431 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0xFFFFFFFFUL});
		public static readonly BitSet _TYPE_in_type482 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  Halcyon.Phlox.Compiler 
