//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 Types.g 2012-05-22 12:14:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
namespace  Halcyon.Phlox.Compiler 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class Types : Antlr.Runtime.Tree.TreeFilter
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN_EQ", "COMMA", "COMMENT_BLOCK", "COMMENT_SINGLE", "DO_WHILE_STMT", "ELIST", "ELSE_PART", "ESC_SEQ", "EVENT_DEF", "EXPONENT", "EXPR", "FLOAT_LITERAL", "FOR_STMT", "FUNC_BLOCK", "GT", "ID", "IF_STMT", "INDEX", "INTEGER_LITERAL", "JUMP_STMT", "LABEL", "LIST_LITERAL", "LPAREN", "LT", "METHOD_CALL", "METHOD_DEF", "MINUS", "NEWLINE", "PARAM_DECL", "POST_DECREMENT", "POST_INCREMENT", "PRE_DECREMENT", "PRE_INCREMENT", "RETURN_STMT", "ROTATION_LITERAL", "RPAREN", "SEMI", "STATE_BLOCK", "STATE_CHG", "STATE_DEF", "STRING_LITERAL", "SUBSCRIPT", "TYPE", "TYPE_CAST", "UNARY_BIT_NOT", "UNARY_BOOL_NOT", "UNARY_MINUS", "VAR_DECL", "VECTOR_LITERAL", "WHILE_STMT", "WS", "'!'", "'!='", "'%'", "'%='", "'&&'", "'&'", "'*'", "'*='", "'+'", "'++'", "'+='", "'--'", "'-='", "'.'", "'/'", "'/='", "'<<'", "'<<='", "'<='", "'=='", "'>='", "'>>'", "'>>='", "'@'", "'['", "']'", "'^'", "'default'", "'do'", "'else'", "'for'", "'if'", "'jump'", "'return'", "'state'", "'while'", "'{'", "'|'", "'||'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int ASSIGN_EQ=4;
	public const int COMMA=5;
	public const int COMMENT_BLOCK=6;
	public const int COMMENT_SINGLE=7;
	public const int DO_WHILE_STMT=8;
	public const int ELIST=9;
	public const int ELSE_PART=10;
	public const int ESC_SEQ=11;
	public const int EVENT_DEF=12;
	public const int EXPONENT=13;
	public const int EXPR=14;
	public const int FLOAT_LITERAL=15;
	public const int FOR_STMT=16;
	public const int FUNC_BLOCK=17;
	public const int GT=18;
	public const int ID=19;
	public const int IF_STMT=20;
	public const int INDEX=21;
	public const int INTEGER_LITERAL=22;
	public const int JUMP_STMT=23;
	public const int LABEL=24;
	public const int LIST_LITERAL=25;
	public const int LPAREN=26;
	public const int LT=27;
	public const int METHOD_CALL=28;
	public const int METHOD_DEF=29;
	public const int MINUS=30;
	public const int NEWLINE=31;
	public const int PARAM_DECL=32;
	public const int POST_DECREMENT=33;
	public const int POST_INCREMENT=34;
	public const int PRE_DECREMENT=35;
	public const int PRE_INCREMENT=36;
	public const int RETURN_STMT=37;
	public const int ROTATION_LITERAL=38;
	public const int RPAREN=39;
	public const int SEMI=40;
	public const int STATE_BLOCK=41;
	public const int STATE_CHG=42;
	public const int STATE_DEF=43;
	public const int STRING_LITERAL=44;
	public const int SUBSCRIPT=45;
	public const int TYPE=46;
	public const int TYPE_CAST=47;
	public const int UNARY_BIT_NOT=48;
	public const int UNARY_BOOL_NOT=49;
	public const int UNARY_MINUS=50;
	public const int VAR_DECL=51;
	public const int VECTOR_LITERAL=52;
	public const int WHILE_STMT=53;
	public const int WS=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;

	// delegates
	// delegators

	public Types( ITreeNodeStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public Types(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return Types.tokenNames; } }
	public override string GrammarFileName { get { return "Types.g"; } }


		SymbolTable symtab;
		public Types(ITreeNodeStream input, SymbolTable symtab) : this(input) {
		    this.symtab = symtab;
		}
	    
		//protected override void Topdown() { topdown(); }
		protected override void Bottomup() { bottomup(); }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_bottomup();
	partial void LeaveRule_bottomup();

	// $ANTLR start "bottomup"
	// Types.g:22:1: bottomup : ( exprRoot | varDecl | rootAssign | rootSubAssign | returnStmt | stateChg | logicalStmts | jumpStmt );
	[GrammarRule("bottomup")]
	private void bottomup()
	{
		EnterRule_bottomup();
		EnterRule("bottomup", 1);
		TraceIn("bottomup", 1);
		try { DebugEnterRule(GrammarFileName, "bottomup");
		DebugLocation(22, 1);
		try
		{
			// Types.g:23:2: ( exprRoot | varDecl | rootAssign | rootSubAssign | returnStmt | stateChg | logicalStmts | jumpStmt )
			int alt1=8;
			try { DebugEnterDecision(1, false);
			try
			{
				alt1 = dfa1.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Types.g:23:4: exprRoot
				{
				DebugLocation(23, 4);
				PushFollow(Follow._exprRoot_in_bottomup63);
				exprRoot();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Types.g:24:4: varDecl
				{
				DebugLocation(24, 4);
				PushFollow(Follow._varDecl_in_bottomup68);
				varDecl();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Types.g:25:4: rootAssign
				{
				DebugLocation(25, 4);
				PushFollow(Follow._rootAssign_in_bottomup73);
				rootAssign();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Types.g:26:4: rootSubAssign
				{
				DebugLocation(26, 4);
				PushFollow(Follow._rootSubAssign_in_bottomup78);
				rootSubAssign();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Types.g:27:4: returnStmt
				{
				DebugLocation(27, 4);
				PushFollow(Follow._returnStmt_in_bottomup83);
				returnStmt();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Types.g:28:4: stateChg
				{
				DebugLocation(28, 4);
				PushFollow(Follow._stateChg_in_bottomup88);
				stateChg();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Types.g:29:4: logicalStmts
				{
				DebugLocation(29, 4);
				PushFollow(Follow._logicalStmts_in_bottomup93);
				logicalStmts();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Types.g:30:4: jumpStmt
				{
				DebugLocation(30, 4);
				PushFollow(Follow._jumpStmt_in_bottomup98);
				jumpStmt();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bottomup", 1);
			LeaveRule("bottomup", 1);
			LeaveRule_bottomup();
		}
		DebugLocation(31, 1);
		} finally { DebugExitRule(GrammarFileName, "bottomup"); }
		return;

	}
	// $ANTLR end "bottomup"


	partial void EnterRule_jumpStmt();
	partial void LeaveRule_jumpStmt();

	// $ANTLR start "jumpStmt"
	// Types.g:33:1: jumpStmt : ^( JUMP_STMT ID ) ;
	[GrammarRule("jumpStmt")]
	private void jumpStmt()
	{
		EnterRule_jumpStmt();
		EnterRule("jumpStmt", 2);
		TraceIn("jumpStmt", 2);
		LSLAst JUMP_STMT1 = default(LSLAst);
		LSLAst ID2 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "jumpStmt");
		DebugLocation(33, 1);
		try
		{
			// Types.g:34:2: ( ^( JUMP_STMT ID ) )
			DebugEnterAlt(1);
			// Types.g:35:3: ^( JUMP_STMT ID )
			{
			DebugLocation(35, 3);
			DebugLocation(35, 5);
			JUMP_STMT1=(LSLAst)Match(input,JUMP_STMT,Follow._JUMP_STMT_in_jumpStmt112); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(35, 15);
			ID2=(LSLAst)Match(input,ID,Follow._ID_in_jumpStmt114); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(36, 3);
			if (state.backtracking == 1)
			{

							symtab.CheckJump(JUMP_STMT1, ID2);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("jumpStmt", 2);
			LeaveRule("jumpStmt", 2);
			LeaveRule_jumpStmt();
		}
		DebugLocation(39, 1);
		} finally { DebugExitRule(GrammarFileName, "jumpStmt"); }
		return;

	}
	// $ANTLR end "jumpStmt"


	partial void EnterRule_logicalStmts();
	partial void LeaveRule_logicalStmts();

	// $ANTLR start "logicalStmts"
	// Types.g:41:1: logicalStmts : ( ^( IF_STMT boolExpr= . ( . )* ) | ^( WHILE_STMT boolExpr= . ( . )* ) | ^( DO_WHILE_STMT boolExpr= . ( . )* ) | ^( FOR_STMT stmt= . init= . cond= . ( . )* ) );
	[GrammarRule("logicalStmts")]
	private void logicalStmts()
	{
		EnterRule_logicalStmts();
		EnterRule("logicalStmts", 3);
		TraceIn("logicalStmts", 3);
		LSLAst boolExpr = default(LSLAst);
		LSLAst stmt = default(LSLAst);
		LSLAst init = default(LSLAst);
		LSLAst cond = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "logicalStmts");
		DebugLocation(41, 1);
		try
		{
			// Types.g:42:2: ( ^( IF_STMT boolExpr= . ( . )* ) | ^( WHILE_STMT boolExpr= . ( . )* ) | ^( DO_WHILE_STMT boolExpr= . ( . )* ) | ^( FOR_STMT stmt= . init= . cond= . ( . )* ) )
			int alt6=4;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case IF_STMT:
				{
				alt6 = 1;
				}
				break;
			case WHILE_STMT:
				{
				alt6 = 2;
				}
				break;
			case DO_WHILE_STMT:
				{
				alt6 = 3;
				}
				break;
			case FOR_STMT:
				{
				alt6 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Types.g:42:4: ^( IF_STMT boolExpr= . ( . )* )
				{
				DebugLocation(42, 4);
				DebugLocation(42, 6);
				Match(input,IF_STMT,Follow._IF_STMT_in_logicalStmts131); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(42, 22);
				boolExpr=(LSLAst)input.LT(1);
				MatchAny(input); if (state.failed) return;
				DebugLocation(42, 25);
				// Types.g:42:25: ( . )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_0 = input.LA(1);

					if (((LA2_0>=ASSIGN_EQ && LA2_0<=95)))
					{
						alt2 = 1;
					}
					else if ((LA2_0==UP))
					{
						alt2 = 2;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// Types.g:42:25: .
						{
						DebugLocation(42, 25);
						MatchAny(input); if (state.failed) return;

						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
				DebugLocation(43, 3);
				if (state.backtracking == 1)
				{

								//symtab.CheckLogicalExpr(boolExpr);
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Types.g:47:3: ^( WHILE_STMT boolExpr= . ( . )* )
				{
				DebugLocation(47, 3);
				DebugLocation(47, 5);
				Match(input,WHILE_STMT,Follow._WHILE_STMT_in_logicalStmts151); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(47, 24);
				boolExpr=(LSLAst)input.LT(1);
				MatchAny(input); if (state.failed) return;
				DebugLocation(47, 27);
				// Types.g:47:27: ( . )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if (((LA3_0>=ASSIGN_EQ && LA3_0<=95)))
					{
						alt3 = 1;
					}
					else if ((LA3_0==UP))
					{
						alt3 = 2;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// Types.g:47:27: .
						{
						DebugLocation(47, 27);
						MatchAny(input); if (state.failed) return;

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
				DebugLocation(48, 3);
				if (state.backtracking == 1)
				{

								//symtab.CheckLogicalExpr(boolExpr);
							
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Types.g:53:3: ^( DO_WHILE_STMT boolExpr= . ( . )* )
				{
				DebugLocation(53, 3);
				DebugLocation(53, 5);
				Match(input,DO_WHILE_STMT,Follow._DO_WHILE_STMT_in_logicalStmts173); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(53, 27);
				boolExpr=(LSLAst)input.LT(1);
				MatchAny(input); if (state.failed) return;
				DebugLocation(53, 30);
				// Types.g:53:30: ( . )*
				try { DebugEnterSubRule(4);
				while (true)
				{
					int alt4=2;
					try { DebugEnterDecision(4, false);
					int LA4_0 = input.LA(1);

					if (((LA4_0>=ASSIGN_EQ && LA4_0<=95)))
					{
						alt4 = 1;
					}
					else if ((LA4_0==UP))
					{
						alt4 = 2;
					}


					} finally { DebugExitDecision(4); }
					switch ( alt4 )
					{
					case 1:
						DebugEnterAlt(1);
						// Types.g:53:30: .
						{
						DebugLocation(53, 30);
						MatchAny(input); if (state.failed) return;

						}
						break;

					default:
						goto loop4;
					}
				}

				loop4:
					;

				} finally { DebugExitSubRule(4); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
				DebugLocation(54, 3);
				if (state.backtracking == 1)
				{

								//symtab.CheckLogicalExpr(boolExpr);
							
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Types.g:59:3: ^( FOR_STMT stmt= . init= . cond= . ( . )* )
				{
				DebugLocation(59, 3);
				DebugLocation(59, 5);
				Match(input,FOR_STMT,Follow._FOR_STMT_in_logicalStmts195); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(59, 18);
				stmt=(LSLAst)input.LT(1);
				MatchAny(input); if (state.failed) return;
				DebugLocation(59, 25);
				init=(LSLAst)input.LT(1);
				MatchAny(input); if (state.failed) return;
				DebugLocation(59, 32);
				cond=(LSLAst)input.LT(1);
				MatchAny(input); if (state.failed) return;
				DebugLocation(59, 35);
				// Types.g:59:35: ( . )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if (((LA5_0>=ASSIGN_EQ && LA5_0<=95)))
					{
						alt5 = 1;
					}
					else if ((LA5_0==UP))
					{
						alt5 = 2;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// Types.g:59:35: .
						{
						DebugLocation(59, 35);
						MatchAny(input); if (state.failed) return;

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
				DebugLocation(60, 3);
				if (state.backtracking == 1)
				{

								if (cond.Type != LSLParser.SEMI)
								{
									//symtab.CheckLogicalExpr(cond);
								}
							
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logicalStmts", 3);
			LeaveRule("logicalStmts", 3);
			LeaveRule_logicalStmts();
		}
		DebugLocation(66, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalStmts"); }
		return;

	}
	// $ANTLR end "logicalStmts"


	partial void EnterRule_stateChg();
	partial void LeaveRule_stateChg();

	// $ANTLR start "stateChg"
	// Types.g:70:1: stateChg : ^( STATE_CHG ( ID )? ) ;
	[GrammarRule("stateChg")]
	private void stateChg()
	{
		EnterRule_stateChg();
		EnterRule("stateChg", 4);
		TraceIn("stateChg", 4);
		LSLAst STATE_CHG3 = default(LSLAst);
		LSLAst ID4 = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "stateChg");
		DebugLocation(70, 1);
		try
		{
			// Types.g:70:9: ( ^( STATE_CHG ( ID )? ) )
			DebugEnterAlt(1);
			// Types.g:70:11: ^( STATE_CHG ( ID )? )
			{
			DebugLocation(70, 11);
			DebugLocation(70, 13);
			STATE_CHG3=(LSLAst)Match(input,STATE_CHG,Follow._STATE_CHG_in_stateChg228); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(70, 23);
				// Types.g:70:23: ( ID )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==ID))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// Types.g:70:23: ID
					{
					DebugLocation(70, 23);
					ID4=(LSLAst)Match(input,ID,Follow._ID_in_stateChg230); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}
			DebugLocation(71, 3);
			if (state.backtracking == 1)
			{

							symtab.CheckStateChange(STATE_CHG3, ID4);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stateChg", 4);
			LeaveRule("stateChg", 4);
			LeaveRule_stateChg();
		}
		DebugLocation(74, 1);
		} finally { DebugExitRule(GrammarFileName, "stateChg"); }
		return;

	}
	// $ANTLR end "stateChg"


	partial void EnterRule_returnStmt();
	partial void LeaveRule_returnStmt();

	// $ANTLR start "returnStmt"
	// Types.g:76:1: returnStmt : ^( RETURN_STMT ( expr )? ) ;
	[GrammarRule("returnStmt")]
	private void returnStmt()
	{
		EnterRule_returnStmt();
		EnterRule("returnStmt", 5);
		TraceIn("returnStmt", 5);
		LSLAst RETURN_STMT5 = default(LSLAst);
		Types.expr_return expr6 = default(Types.expr_return);

		try { DebugEnterRule(GrammarFileName, "returnStmt");
		DebugLocation(76, 1);
		try
		{
			// Types.g:77:2: ( ^( RETURN_STMT ( expr )? ) )
			DebugEnterAlt(1);
			// Types.g:77:4: ^( RETURN_STMT ( expr )? )
			{
			DebugLocation(77, 4);
			DebugLocation(77, 6);
			RETURN_STMT5=(LSLAst)Match(input,RETURN_STMT,Follow._RETURN_STMT_in_returnStmt248); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(77, 18);
				// Types.g:77:18: ( expr )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==ASSIGN_EQ||(LA8_0>=EXPR && LA8_0<=FLOAT_LITERAL)||(LA8_0>=GT && LA8_0<=ID)||LA8_0==INTEGER_LITERAL||LA8_0==LIST_LITERAL||(LA8_0>=LT && LA8_0<=METHOD_CALL)||LA8_0==MINUS||(LA8_0>=POST_DECREMENT && LA8_0<=PRE_INCREMENT)||LA8_0==ROTATION_LITERAL||(LA8_0>=STRING_LITERAL && LA8_0<=SUBSCRIPT)||(LA8_0>=TYPE_CAST && LA8_0<=UNARY_MINUS)||LA8_0==VECTOR_LITERAL||(LA8_0>=56 && LA8_0<=63)||LA8_0==65||LA8_0==67||(LA8_0>=69 && LA8_0<=77)||LA8_0==81||(LA8_0>=92 && LA8_0<=93)))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// Types.g:77:18: expr
					{
					DebugLocation(77, 18);
					PushFollow(Follow._expr_in_returnStmt250);
					expr6=expr();
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(8); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}
			DebugLocation(78, 3);
			if (state.backtracking == 1)
			{

							symtab.CheckReturn(RETURN_STMT5, (expr6!=null?((LSLAst)expr6.Start):default(LSLAst)));
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("returnStmt", 5);
			LeaveRule("returnStmt", 5);
			LeaveRule_returnStmt();
		}
		DebugLocation(81, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStmt"); }
		return;

	}
	// $ANTLR end "returnStmt"


	partial void EnterRule_rootAssign();
	partial void LeaveRule_rootAssign();

	// $ANTLR start "rootAssign"
	// Types.g:83:1: rootAssign :{...}? ^( assignOp lhs= exprRoot rhs= exprRoot ) ;
	[GrammarRule("rootAssign")]
	private void rootAssign()
	{
		EnterRule_rootAssign();
		EnterRule("rootAssign", 6);
		TraceIn("rootAssign", 6);
		Types.exprRoot_return lhs = default(Types.exprRoot_return);
		Types.exprRoot_return rhs = default(Types.exprRoot_return);
		Types.assignOp_return assignOp7 = default(Types.assignOp_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "rootAssign");
		DebugLocation(83, 1);
		try
		{
			// Types.g:85:2: ({...}? ^( assignOp lhs= exprRoot rhs= exprRoot ) )
			DebugEnterAlt(1);
			// Types.g:86:3: {...}? ^( assignOp lhs= exprRoot rhs= exprRoot )
			{
			DebugLocation(86, 3);
			if (!((!t.HasAncestor(EXPR))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "rootAssign", "!t.HasAncestor(EXPR)");
			}
			DebugLocation(87, 3);
			DebugLocation(87, 5);
			PushFollow(Follow._assignOp_in_rootAssign281);
			assignOp7=assignOp();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(87, 17);
			PushFollow(Follow._exprRoot_in_rootAssign285);
			lhs=exprRoot();
			PopFollow();
			if (state.failed) return;
			DebugLocation(87, 30);
			PushFollow(Follow._exprRoot_in_rootAssign289);
			rhs=exprRoot();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(88, 3);
			if (state.backtracking == 1)
			{

							(assignOp7!=null?((LSLAst)assignOp7.Start):default(LSLAst)).evalType = symtab.Assign((assignOp7!=null?((LSLAst)assignOp7.Start):default(LSLAst)).Token.Text, (lhs!=null?((LSLAst)lhs.Start):default(LSLAst)), (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rootAssign", 6);
			LeaveRule("rootAssign", 6);
			LeaveRule_rootAssign();
		}
		DebugLocation(91, 1);
		} finally { DebugExitRule(GrammarFileName, "rootAssign"); }
		return;

	}
	// $ANTLR end "rootAssign"


	partial void EnterRule_rootSubAssign();
	partial void LeaveRule_rootSubAssign();

	// $ANTLR start "rootSubAssign"
	// Types.g:93:1: rootSubAssign :{...}? ^( assignOp ^(lhs= SUBSCRIPT ( . )* ) rhs= exprRoot ) ;
	[GrammarRule("rootSubAssign")]
	private void rootSubAssign()
	{
		EnterRule_rootSubAssign();
		EnterRule("rootSubAssign", 7);
		TraceIn("rootSubAssign", 7);
		LSLAst lhs = default(LSLAst);
		Types.exprRoot_return rhs = default(Types.exprRoot_return);
		Types.assignOp_return assignOp8 = default(Types.assignOp_return);

		LSLAst t = (LSLAst)input.LT(1);
		try { DebugEnterRule(GrammarFileName, "rootSubAssign");
		DebugLocation(93, 1);
		try
		{
			// Types.g:95:2: ({...}? ^( assignOp ^(lhs= SUBSCRIPT ( . )* ) rhs= exprRoot ) )
			DebugEnterAlt(1);
			// Types.g:96:3: {...}? ^( assignOp ^(lhs= SUBSCRIPT ( . )* ) rhs= exprRoot )
			{
			DebugLocation(96, 3);
			if (!((!t.HasAncestor(EXPR))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "rootSubAssign", "!t.HasAncestor(EXPR)");
			}
			DebugLocation(97, 3);
			DebugLocation(97, 5);
			PushFollow(Follow._assignOp_in_rootSubAssign317);
			assignOp8=assignOp();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(97, 14);
			DebugLocation(97, 19);
			lhs=(LSLAst)Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_rootSubAssign322); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(97, 30);
				// Types.g:97:30: ( . )*
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=2;
					try { DebugEnterDecision(9, false);
					int LA9_0 = input.LA(1);

					if (((LA9_0>=ASSIGN_EQ && LA9_0<=95)))
					{
						alt9 = 1;
					}
					else if ((LA9_0==UP))
					{
						alt9 = 2;
					}


					} finally { DebugExitDecision(9); }
					switch ( alt9 )
					{
					case 1:
						DebugEnterAlt(1);
						// Types.g:97:30: .
						{
						DebugLocation(97, 30);
						MatchAny(input); if (state.failed) return;

						}
						break;

					default:
						goto loop9;
					}
				}

				loop9:
					;

				} finally { DebugExitSubRule(9); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}
			DebugLocation(97, 37);
			PushFollow(Follow._exprRoot_in_rootSubAssign330);
			rhs=exprRoot();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(98, 3);
			if (state.backtracking == 1)
			{

							lhs.evalType = SymbolTable.FLOAT;
							(assignOp8!=null?((LSLAst)assignOp8.Start):default(LSLAst)).evalType = symtab.Assign((assignOp8!=null?((LSLAst)assignOp8.Start):default(LSLAst)).Token.Text, lhs, (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rootSubAssign", 7);
			LeaveRule("rootSubAssign", 7);
			LeaveRule_rootSubAssign();
		}
		DebugLocation(102, 1);
		} finally { DebugExitRule(GrammarFileName, "rootSubAssign"); }
		return;

	}
	// $ANTLR end "rootSubAssign"


	partial void EnterRule_varDecl();
	partial void LeaveRule_varDecl();

	// $ANTLR start "varDecl"
	// Types.g:104:1: varDecl : ^( VAR_DECL . ID (init= . )? ) ;
	[GrammarRule("varDecl")]
	private void varDecl()
	{
		EnterRule_varDecl();
		EnterRule("varDecl", 8);
		TraceIn("varDecl", 8);
		LSLAst ID9 = default(LSLAst);
		LSLAst init = default(LSLAst);

		try { DebugEnterRule(GrammarFileName, "varDecl");
		DebugLocation(104, 1);
		try
		{
			// Types.g:105:2: ( ^( VAR_DECL . ID (init= . )? ) )
			DebugEnterAlt(1);
			// Types.g:105:6: ^( VAR_DECL . ID (init= . )? )
			{
			DebugLocation(105, 6);
			DebugLocation(105, 8);
			Match(input,VAR_DECL,Follow._VAR_DECL_in_varDecl349); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(105, 17);
			MatchAny(input); if (state.failed) return;
			DebugLocation(105, 19);
			ID9=(LSLAst)Match(input,ID,Follow._ID_in_varDecl353); if (state.failed) return;
			DebugLocation(105, 22);
			// Types.g:105:22: (init= . )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if (((LA10_0>=ASSIGN_EQ && LA10_0<=95)))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Types.g:105:23: init= .
				{
				DebugLocation(105, 27);
				init=(LSLAst)input.LT(1);
				MatchAny(input); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(10); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;
			DebugLocation(106, 3);
			if (state.backtracking == 1)
			{

							if ( init!=null && init.evalType!=null )
				             		symtab.DeclInit(ID9, init);
				             	
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("varDecl", 8);
			LeaveRule("varDecl", 8);
			LeaveRule_varDecl();
		}
		DebugLocation(110, 1);
		} finally { DebugExitRule(GrammarFileName, "varDecl"); }
		return;

	}
	// $ANTLR end "varDecl"

	private sealed partial class exprRoot_return : TreeRuleReturnScope<LSLAst>
	{
		public exprRoot_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_exprRoot();
	partial void LeaveRule_exprRoot();

	// $ANTLR start "exprRoot"
	// Types.g:112:1: exprRoot : ^( EXPR expr ) ;
	[GrammarRule("exprRoot")]
	private Types.exprRoot_return exprRoot()
	{
		EnterRule_exprRoot();
		EnterRule("exprRoot", 9);
		TraceIn("exprRoot", 9);
		Types.exprRoot_return retval = new Types.exprRoot_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst EXPR10 = default(LSLAst);
		Types.expr_return expr11 = default(Types.expr_return);

		try { DebugEnterRule(GrammarFileName, "exprRoot");
		DebugLocation(112, 1);
		try
		{
			// Types.g:113:2: ( ^( EXPR expr ) )
			DebugEnterAlt(1);
			// Types.g:113:4: ^( EXPR expr )
			{
			DebugLocation(113, 4);
			DebugLocation(113, 6);
			EXPR10=(LSLAst)Match(input,EXPR,Follow._EXPR_in_exprRoot386); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(113, 11);
			PushFollow(Follow._expr_in_exprRoot388);
			expr11=expr();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			DebugLocation(113, 17);
			if (state.backtracking == 1)
			{
				EXPR10.evalType = (expr11!=null?expr11.type:default(ISymbolType));
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exprRoot", 9);
			LeaveRule("exprRoot", 9);
			LeaveRule_exprRoot();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "exprRoot"); }
		return retval;

	}
	// $ANTLR end "exprRoot"

	private sealed partial class expr_return : TreeRuleReturnScope<LSLAst>
	{
		public ISymbolType type;
		public expr_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// Types.g:116:1: expr returns [ISymbolType type] : ( INTEGER_LITERAL |fl= FLOAT_LITERAL | ^( VECTOR_LITERAL e1= expr e2= expr e3= expr ) | ^( ROTATION_LITERAL e1= expr e2= expr e3= expr e4= expr ) | listLiteral | STRING_LITERAL | ID | typeCast | binaryOps | methodCall | unaryOps | subScript | ^( EXPR e= expr ) );
	[GrammarRule("expr")]
	private Types.expr_return expr()
	{
		EnterRule_expr();
		EnterRule("expr", 10);
		TraceIn("expr", 10);
		Types.expr_return retval = new Types.expr_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst fl = default(LSLAst);
		LSLAst ID13 = default(LSLAst);
		Types.expr_return e1 = default(Types.expr_return);
		Types.expr_return e2 = default(Types.expr_return);
		Types.expr_return e3 = default(Types.expr_return);
		Types.expr_return e4 = default(Types.expr_return);
		Types.expr_return e = default(Types.expr_return);
		Types.listLiteral_return listLiteral12 = default(Types.listLiteral_return);
		Types.typeCast_return typeCast14 = default(Types.typeCast_return);
		Types.binaryOps_return binaryOps15 = default(Types.binaryOps_return);
		Types.methodCall_return methodCall16 = default(Types.methodCall_return);
		Types.unaryOps_return unaryOps17 = default(Types.unaryOps_return);
		Types.subScript_return subScript18 = default(Types.subScript_return);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(116, 1);
		try
		{
			// Types.g:118:2: ( INTEGER_LITERAL |fl= FLOAT_LITERAL | ^( VECTOR_LITERAL e1= expr e2= expr e3= expr ) | ^( ROTATION_LITERAL e1= expr e2= expr e3= expr e4= expr ) | listLiteral | STRING_LITERAL | ID | typeCast | binaryOps | methodCall | unaryOps | subScript | ^( EXPR e= expr ) )
			int alt11=13;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case INTEGER_LITERAL:
				{
				alt11 = 1;
				}
				break;
			case FLOAT_LITERAL:
				{
				alt11 = 2;
				}
				break;
			case VECTOR_LITERAL:
				{
				alt11 = 3;
				}
				break;
			case ROTATION_LITERAL:
				{
				alt11 = 4;
				}
				break;
			case LIST_LITERAL:
				{
				alt11 = 5;
				}
				break;
			case STRING_LITERAL:
				{
				alt11 = 6;
				}
				break;
			case ID:
				{
				alt11 = 7;
				}
				break;
			case TYPE_CAST:
				{
				alt11 = 8;
				}
				break;
			case ASSIGN_EQ:
			case GT:
			case LT:
			case MINUS:
			case 56:
			case 57:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 65:
			case 67:
			case 69:
			case 70:
			case 71:
			case 72:
			case 73:
			case 74:
			case 75:
			case 76:
			case 77:
			case 81:
			case 92:
			case 93:
				{
				alt11 = 9;
				}
				break;
			case METHOD_CALL:
				{
				alt11 = 10;
				}
				break;
			case POST_DECREMENT:
			case POST_INCREMENT:
			case PRE_DECREMENT:
			case PRE_INCREMENT:
			case UNARY_BIT_NOT:
			case UNARY_BOOL_NOT:
			case UNARY_MINUS:
				{
				alt11 = 11;
				}
				break;
			case SUBSCRIPT:
				{
				alt11 = 12;
				}
				break;
			case EXPR:
				{
				alt11 = 13;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Types.g:118:4: INTEGER_LITERAL
				{
				DebugLocation(118, 4);
				Match(input,INTEGER_LITERAL,Follow._INTEGER_LITERAL_in_expr411); if (state.failed) return retval;
				DebugLocation(118, 24);
				if (state.backtracking == 1)
				{
					retval.type = SymbolTable.INT; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Types.g:119:4: fl= FLOAT_LITERAL
				{
				DebugLocation(119, 6);
				fl=(LSLAst)Match(input,FLOAT_LITERAL,Follow._FLOAT_LITERAL_in_expr424); if (state.failed) return retval;
				DebugLocation(119, 25);
				if (state.backtracking == 1)
				{
					retval.type = SymbolTable.FLOAT;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Types.g:121:4: ^( VECTOR_LITERAL e1= expr e2= expr e3= expr )
				{
				DebugLocation(121, 4);
				DebugLocation(121, 6);
				Match(input,VECTOR_LITERAL,Follow._VECTOR_LITERAL_in_expr438); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(121, 23);
				PushFollow(Follow._expr_in_expr442);
				e1=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(121, 31);
				PushFollow(Follow._expr_in_expr446);
				e2=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(121, 39);
				PushFollow(Follow._expr_in_expr450);
				e3=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(122, 3);
				if (state.backtracking == 1)
				{

								//vector expressions must evaluate to float
								symtab.CheckVectorLiteral((e1!=null?((LSLAst)e1.Start):default(LSLAst)), (e2!=null?((LSLAst)e2.Start):default(LSLAst)), (e3!=null?((LSLAst)e3.Start):default(LSLAst)));
								retval.type = SymbolTable.VECTOR; 
							
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Types.g:128:4: ^( ROTATION_LITERAL e1= expr e2= expr e3= expr e4= expr )
				{
				DebugLocation(128, 4);
				DebugLocation(128, 6);
				Match(input,ROTATION_LITERAL,Follow._ROTATION_LITERAL_in_expr471); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(128, 25);
				PushFollow(Follow._expr_in_expr475);
				e1=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(128, 33);
				PushFollow(Follow._expr_in_expr479);
				e2=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(128, 41);
				PushFollow(Follow._expr_in_expr483);
				e3=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(128, 49);
				PushFollow(Follow._expr_in_expr487);
				e4=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(129, 3);
				if (state.backtracking == 1)
				{

								//vector expressions must evaluate to float
								symtab.CheckRotationLiteral((e1!=null?((LSLAst)e1.Start):default(LSLAst)), (e2!=null?((LSLAst)e2.Start):default(LSLAst)), (e3!=null?((LSLAst)e3.Start):default(LSLAst)), (e4!=null?((LSLAst)e4.Start):default(LSLAst)));
								retval.type = SymbolTable.ROTATION; 
							
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Types.g:135:4: listLiteral
				{
				DebugLocation(135, 4);
				PushFollow(Follow._listLiteral_in_expr507);
				listLiteral12=listLiteral();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(135, 20);
				if (state.backtracking == 1)
				{
					retval.type = (listLiteral12!=null?listLiteral12.type:default(ISymbolType)); 
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Types.g:137:4: STRING_LITERAL
				{
				DebugLocation(137, 4);
				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_expr521); if (state.failed) return retval;
				DebugLocation(137, 23);
				if (state.backtracking == 1)
				{
					retval.type = SymbolTable.STRING; 
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Types.g:139:7: ID
				{
				DebugLocation(139, 7);
				ID13=(LSLAst)Match(input,ID,Follow._ID_in_expr537); if (state.failed) return retval;
				DebugLocation(139, 16);
				if (state.backtracking == 1)
				{

														VariableSymbol s=(VariableSymbol)symtab.EnsureResolve(ID13, ID13.scope, (ID13!=null?ID13.Text:null));
								            					if (s != null) 
								            					{
									            					ID13.symbol = s; 
									            					retval.type = s.Type;
								            					}
								            				
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Types.g:148:8: typeCast
				{
				DebugLocation(148, 8);
				PushFollow(Follow._typeCast_in_expr574);
				typeCast14=typeCast();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(148, 18);
				if (state.backtracking == 1)
				{
					retval.type = (typeCast14!=null?typeCast14.type:default(ISymbolType)); 
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Types.g:150:5: binaryOps
				{
				DebugLocation(150, 5);
				PushFollow(Follow._binaryOps_in_expr590);
				binaryOps15=binaryOps();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(150, 16);
				if (state.backtracking == 1)
				{
					retval.type = (binaryOps15!=null?binaryOps15.type:default(ISymbolType)); 
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Types.g:151:8: methodCall
				{
				DebugLocation(151, 8);
				PushFollow(Follow._methodCall_in_expr602);
				methodCall16=methodCall();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(151, 20);
				if (state.backtracking == 1)
				{
					retval.type = (methodCall16!=null?methodCall16.type:default(ISymbolType)); 
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Types.g:152:8: unaryOps
				{
				DebugLocation(152, 8);
				PushFollow(Follow._unaryOps_in_expr614);
				unaryOps17=unaryOps();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(152, 18);
				if (state.backtracking == 1)
				{
					retval.type = (unaryOps17!=null?unaryOps17.type:default(ISymbolType)); 
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Types.g:153:8: subScript
				{
				DebugLocation(153, 8);
				PushFollow(Follow._subScript_in_expr626);
				subScript18=subScript();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(153, 19);
				if (state.backtracking == 1)
				{
					retval.type = (subScript18!=null?subScript18.type:default(ISymbolType)); 
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Types.g:154:8: ^( EXPR e= expr )
				{
				DebugLocation(154, 8);
				DebugLocation(154, 10);
				Match(input,EXPR,Follow._EXPR_in_expr639); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(154, 16);
				PushFollow(Follow._expr_in_expr643);
				e=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(154, 24);
				if (state.backtracking == 1)
				{
					retval.type = (e!=null?e.type:default(ISymbolType)); 
				}

				}
				break;

			}
			if (state.backtracking == 1)
			{
				 retval.Start.evalType = retval.type; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 10);
			LeaveRule("expr", 10);
			LeaveRule_expr();
		}
		DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	private sealed partial class listLiteral_return : TreeRuleReturnScope<LSLAst>
	{
		public ISymbolType type;
		public listLiteral_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_listLiteral();
	partial void LeaveRule_listLiteral();

	// $ANTLR start "listLiteral"
	// Types.g:157:1: listLiteral returns [ISymbolType type] : ^( LIST_LITERAL ^( ELIST ( expr )* ) ) ;
	[GrammarRule("listLiteral")]
	private Types.listLiteral_return listLiteral()
	{
		EnterRule_listLiteral();
		EnterRule("listLiteral", 11);
		TraceIn("listLiteral", 11);
		Types.listLiteral_return retval = new Types.listLiteral_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst LIST_LITERAL20 = default(LSLAst);
		Types.expr_return expr19 = default(Types.expr_return);

		List<LSLAst> args = new List<LSLAst>();
		try { DebugEnterRule(GrammarFileName, "listLiteral");
		DebugLocation(157, 1);
		try
		{
			// Types.g:160:2: ( ^( LIST_LITERAL ^( ELIST ( expr )* ) ) )
			DebugEnterAlt(1);
			// Types.g:161:3: ^( LIST_LITERAL ^( ELIST ( expr )* ) )
			{
			DebugLocation(161, 3);
			DebugLocation(161, 5);
			LIST_LITERAL20=(LSLAst)Match(input,LIST_LITERAL,Follow._LIST_LITERAL_in_listLiteral678); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(161, 18);
			DebugLocation(161, 20);
			Match(input,ELIST,Follow._ELIST_in_listLiteral681); if (state.failed) return retval;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(161, 26);
				// Types.g:161:26: ( expr )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_0 = input.LA(1);

					if ((LA12_0==ASSIGN_EQ||(LA12_0>=EXPR && LA12_0<=FLOAT_LITERAL)||(LA12_0>=GT && LA12_0<=ID)||LA12_0==INTEGER_LITERAL||LA12_0==LIST_LITERAL||(LA12_0>=LT && LA12_0<=METHOD_CALL)||LA12_0==MINUS||(LA12_0>=POST_DECREMENT && LA12_0<=PRE_INCREMENT)||LA12_0==ROTATION_LITERAL||(LA12_0>=STRING_LITERAL && LA12_0<=SUBSCRIPT)||(LA12_0>=TYPE_CAST && LA12_0<=UNARY_MINUS)||LA12_0==VECTOR_LITERAL||(LA12_0>=56 && LA12_0<=63)||LA12_0==65||LA12_0==67||(LA12_0>=69 && LA12_0<=77)||LA12_0==81||(LA12_0>=92 && LA12_0<=93)))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// Types.g:161:27: expr
						{
						DebugLocation(161, 27);
						PushFollow(Follow._expr_in_listLiteral684);
						expr19=expr();
						PopFollow();
						if (state.failed) return retval;
						DebugLocation(161, 32);
						if (state.backtracking == 1)
						{
							args.Add((expr19!=null?((LSLAst)expr19.Start):default(LSLAst)));
						}

						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			DebugLocation(162, 3);
			if (state.backtracking == 1)
			{

							retval.type = symtab.CheckListLiteral(LIST_LITERAL20, args);
						
			}

			}

			if (state.backtracking == 1)
			{
				 retval.Start.evalType = retval.type; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("listLiteral", 11);
			LeaveRule("listLiteral", 11);
			LeaveRule_listLiteral();
		}
		DebugLocation(165, 1);
		} finally { DebugExitRule(GrammarFileName, "listLiteral"); }
		return retval;

	}
	// $ANTLR end "listLiteral"

	private sealed partial class subScript_return : TreeRuleReturnScope<LSLAst>
	{
		public ISymbolType type;
		public subScript_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_subScript();
	partial void LeaveRule_subScript();

	// $ANTLR start "subScript"
	// Types.g:167:1: subScript returns [ISymbolType type] : ^( SUBSCRIPT id= expr subs= ID ) ;
	[GrammarRule("subScript")]
	private Types.subScript_return subScript()
	{
		EnterRule_subScript();
		EnterRule("subScript", 12);
		TraceIn("subScript", 12);
		Types.subScript_return retval = new Types.subScript_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst subs = default(LSLAst);
		Types.expr_return id = default(Types.expr_return);

		try { DebugEnterRule(GrammarFileName, "subScript");
		DebugLocation(167, 2);
		try
		{
			// Types.g:169:2: ( ^( SUBSCRIPT id= expr subs= ID ) )
			DebugEnterAlt(1);
			// Types.g:170:3: ^( SUBSCRIPT id= expr subs= ID )
			{
			DebugLocation(170, 3);
			DebugLocation(170, 5);
			Match(input,SUBSCRIPT,Follow._SUBSCRIPT_in_subScript722); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(170, 17);
			PushFollow(Follow._expr_in_subScript726);
			id=expr();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(170, 27);
			subs=(LSLAst)Match(input,ID,Follow._ID_in_subScript730); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			DebugLocation(171, 3);
			if (state.backtracking == 1)
			{

							retval.type = symtab.SubScript((id!=null?((LSLAst)id.Start):default(LSLAst)), subs);
						
			}

			}

			if (state.backtracking == 1)
			{
				 retval.Start.evalType = retval.type; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("subScript", 12);
			LeaveRule("subScript", 12);
			LeaveRule_subScript();
		}
		DebugLocation(174, 2);
		} finally { DebugExitRule(GrammarFileName, "subScript"); }
		return retval;

	}
	// $ANTLR end "subScript"

	private sealed partial class methodCall_return : TreeRuleReturnScope<LSLAst>
	{
		public ISymbolType type;
		public methodCall_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_methodCall();
	partial void LeaveRule_methodCall();

	// $ANTLR start "methodCall"
	// Types.g:176:1: methodCall returns [ISymbolType type] : ^( METHOD_CALL ID ^( ELIST ( expr )* ) ) ;
	[GrammarRule("methodCall")]
	private Types.methodCall_return methodCall()
	{
		EnterRule_methodCall();
		EnterRule("methodCall", 13);
		TraceIn("methodCall", 13);
		Types.methodCall_return retval = new Types.methodCall_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst ID22 = default(LSLAst);
		Types.expr_return expr21 = default(Types.expr_return);

		List<LSLAst> args = new List<LSLAst>();
		try { DebugEnterRule(GrammarFileName, "methodCall");
		DebugLocation(176, 1);
		try
		{
			// Types.g:178:2: ( ^( METHOD_CALL ID ^( ELIST ( expr )* ) ) )
			DebugEnterAlt(1);
			// Types.g:178:4: ^( METHOD_CALL ID ^( ELIST ( expr )* ) )
			{
			DebugLocation(178, 4);
			DebugLocation(178, 6);
			Match(input,METHOD_CALL,Follow._METHOD_CALL_in_methodCall757); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(178, 18);
			ID22=(LSLAst)Match(input,ID,Follow._ID_in_methodCall759); if (state.failed) return retval;
			DebugLocation(178, 21);
			DebugLocation(178, 23);
			Match(input,ELIST,Follow._ELIST_in_methodCall762); if (state.failed) return retval;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(178, 29);
				// Types.g:178:29: ( expr )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_0 = input.LA(1);

					if ((LA13_0==ASSIGN_EQ||(LA13_0>=EXPR && LA13_0<=FLOAT_LITERAL)||(LA13_0>=GT && LA13_0<=ID)||LA13_0==INTEGER_LITERAL||LA13_0==LIST_LITERAL||(LA13_0>=LT && LA13_0<=METHOD_CALL)||LA13_0==MINUS||(LA13_0>=POST_DECREMENT && LA13_0<=PRE_INCREMENT)||LA13_0==ROTATION_LITERAL||(LA13_0>=STRING_LITERAL && LA13_0<=SUBSCRIPT)||(LA13_0>=TYPE_CAST && LA13_0<=UNARY_MINUS)||LA13_0==VECTOR_LITERAL||(LA13_0>=56 && LA13_0<=63)||LA13_0==65||LA13_0==67||(LA13_0>=69 && LA13_0<=77)||LA13_0==81||(LA13_0>=92 && LA13_0<=93)))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// Types.g:178:30: expr
						{
						DebugLocation(178, 30);
						PushFollow(Follow._expr_in_methodCall765);
						expr21=expr();
						PopFollow();
						if (state.failed) return retval;
						DebugLocation(178, 35);
						if (state.backtracking == 1)
						{
							args.Add((expr21!=null?((LSLAst)expr21.Start):default(LSLAst)));
						}

						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			DebugLocation(179, 3);
			if (state.backtracking == 1)
			{

							retval.type = symtab.MethodCall(ID22, args);
							retval.Start.evalType = retval.type;
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodCall", 13);
			LeaveRule("methodCall", 13);
			LeaveRule_methodCall();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "methodCall"); }
		return retval;

	}
	// $ANTLR end "methodCall"

	private sealed partial class typeCast_return : TreeRuleReturnScope<LSLAst>
	{
		public ISymbolType type;
		public typeCast_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_typeCast();
	partial void LeaveRule_typeCast();

	// $ANTLR start "typeCast"
	// Types.g:185:1: typeCast returns [ISymbolType type] : ^( TYPE_CAST TYPE expr ) ;
	[GrammarRule("typeCast")]
	private Types.typeCast_return typeCast()
	{
		EnterRule_typeCast();
		EnterRule("typeCast", 14);
		TraceIn("typeCast", 14);
		Types.typeCast_return retval = new Types.typeCast_return(this);
		retval.Start = (LSLAst)input.LT(1);

		LSLAst TYPE24 = default(LSLAst);
		Types.expr_return expr23 = default(Types.expr_return);

		try { DebugEnterRule(GrammarFileName, "typeCast");
		DebugLocation(185, 1);
		try
		{
			// Types.g:187:2: ( ^( TYPE_CAST TYPE expr ) )
			DebugEnterAlt(1);
			// Types.g:187:4: ^( TYPE_CAST TYPE expr )
			{
			DebugLocation(187, 4);
			DebugLocation(187, 6);
			Match(input,TYPE_CAST,Follow._TYPE_CAST_in_typeCast796); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(187, 16);
			TYPE24=(LSLAst)Match(input,TYPE,Follow._TYPE_in_typeCast798); if (state.failed) return retval;
			DebugLocation(187, 21);
			PushFollow(Follow._expr_in_typeCast800);
			expr23=expr();
			PopFollow();
			if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			DebugLocation(188, 3);
			if (state.backtracking == 1)
			{

							retval.type = symtab.TypeCast((expr23!=null?((LSLAst)expr23.Start):default(LSLAst)), TYPE24);
						
			}

			}

			if (state.backtracking == 1)
			{
				 retval.Start.evalType = retval.type; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeCast", 14);
			LeaveRule("typeCast", 14);
			LeaveRule_typeCast();
		}
		DebugLocation(191, 1);
		} finally { DebugExitRule(GrammarFileName, "typeCast"); }
		return retval;

	}
	// $ANTLR end "typeCast"

	private sealed partial class binaryOps_return : TreeRuleReturnScope<LSLAst>
	{
		public ISymbolType type;
		public binaryOps_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_binaryOps();
	partial void LeaveRule_binaryOps();

	// $ANTLR start "binaryOps"
	// Types.g:193:1: binaryOps returns [ISymbolType type] : ( ^( bop lhs= expr rhs= expr ) | ^( logBop lhs= expr rhs= expr ) | ^( relOp lhs= expr rhs= expr ) | ^( bitOp lhs= expr rhs= expr ) | ^( eqOp lhs= expr rhs= expr ) | ^( assignOp lhs= expr rhs= expr ) ) ;
	[GrammarRule("binaryOps")]
	private Types.binaryOps_return binaryOps()
	{
		EnterRule_binaryOps();
		EnterRule("binaryOps", 15);
		TraceIn("binaryOps", 15);
		Types.binaryOps_return retval = new Types.binaryOps_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Types.expr_return lhs = default(Types.expr_return);
		Types.expr_return rhs = default(Types.expr_return);
		Types.bop_return bop25 = default(Types.bop_return);
		Types.assignOp_return assignOp26 = default(Types.assignOp_return);

		try { DebugEnterRule(GrammarFileName, "binaryOps");
		DebugLocation(193, 1);
		try
		{
			// Types.g:195:2: ( ( ^( bop lhs= expr rhs= expr ) | ^( logBop lhs= expr rhs= expr ) | ^( relOp lhs= expr rhs= expr ) | ^( bitOp lhs= expr rhs= expr ) | ^( eqOp lhs= expr rhs= expr ) | ^( assignOp lhs= expr rhs= expr ) ) )
			DebugEnterAlt(1);
			// Types.g:196:2: ( ^( bop lhs= expr rhs= expr ) | ^( logBop lhs= expr rhs= expr ) | ^( relOp lhs= expr rhs= expr ) | ^( bitOp lhs= expr rhs= expr ) | ^( eqOp lhs= expr rhs= expr ) | ^( assignOp lhs= expr rhs= expr ) )
			{
			DebugLocation(196, 2);
			// Types.g:196:2: ( ^( bop lhs= expr rhs= expr ) | ^( logBop lhs= expr rhs= expr ) | ^( relOp lhs= expr rhs= expr ) | ^( bitOp lhs= expr rhs= expr ) | ^( eqOp lhs= expr rhs= expr ) | ^( assignOp lhs= expr rhs= expr ) )
			int alt14=6;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case MINUS:
			case 57:
			case 61:
			case 63:
			case 69:
			case 71:
			case 76:
				{
				alt14 = 1;
				}
				break;
			case 59:
			case 93:
				{
				alt14 = 2;
				}
				break;
			case GT:
			case LT:
			case 73:
			case 75:
				{
				alt14 = 3;
				}
				break;
			case 60:
			case 81:
			case 92:
				{
				alt14 = 4;
				}
				break;
			case 56:
			case 74:
				{
				alt14 = 5;
				}
				break;
			case ASSIGN_EQ:
			case 58:
			case 62:
			case 65:
			case 67:
			case 70:
			case 72:
			case 77:
				{
				alt14 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Types.g:197:3: ^( bop lhs= expr rhs= expr )
				{
				DebugLocation(197, 3);
				DebugLocation(197, 5);
				PushFollow(Follow._bop_in_binaryOps833);
				bop25=bop();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(197, 12);
				PushFollow(Follow._expr_in_binaryOps837);
				lhs=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(197, 21);
				PushFollow(Follow._expr_in_binaryOps841);
				rhs=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(198, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.Bop((bop25!=null?((LSLAst)bop25.Start):default(LSLAst)), (lhs!=null?((LSLAst)lhs.Start):default(LSLAst)), (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Types.g:204:3: ^( logBop lhs= expr rhs= expr )
				{
				DebugLocation(204, 3);
				DebugLocation(204, 5);
				PushFollow(Follow._logBop_in_binaryOps860);
				logBop();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(204, 15);
				PushFollow(Follow._expr_in_binaryOps864);
				lhs=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(204, 24);
				PushFollow(Follow._expr_in_binaryOps868);
				rhs=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(205, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.LogBop((lhs!=null?((LSLAst)lhs.Start):default(LSLAst)), (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
							
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Types.g:211:3: ^( relOp lhs= expr rhs= expr )
				{
				DebugLocation(211, 3);
				DebugLocation(211, 5);
				PushFollow(Follow._relOp_in_binaryOps887);
				relOp();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(211, 14);
				PushFollow(Follow._expr_in_binaryOps891);
				lhs=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(211, 23);
				PushFollow(Follow._expr_in_binaryOps895);
				rhs=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(212, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.RelOp((lhs!=null?((LSLAst)lhs.Start):default(LSLAst)), (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
							
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Types.g:218:3: ^( bitOp lhs= expr rhs= expr )
				{
				DebugLocation(218, 3);
				DebugLocation(218, 5);
				PushFollow(Follow._bitOp_in_binaryOps914);
				bitOp();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(218, 14);
				PushFollow(Follow._expr_in_binaryOps918);
				lhs=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(218, 23);
				PushFollow(Follow._expr_in_binaryOps922);
				rhs=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(219, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.BitOp((lhs!=null?((LSLAst)lhs.Start):default(LSLAst)), (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
							
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Types.g:225:3: ^( eqOp lhs= expr rhs= expr )
				{
				DebugLocation(225, 3);
				DebugLocation(225, 5);
				PushFollow(Follow._eqOp_in_binaryOps941);
				eqOp();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(225, 13);
				PushFollow(Follow._expr_in_binaryOps945);
				lhs=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(225, 22);
				PushFollow(Follow._expr_in_binaryOps949);
				rhs=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(226, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.EqOp((lhs!=null?((LSLAst)lhs.Start):default(LSLAst)), (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
							
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Types.g:232:3: ^( assignOp lhs= expr rhs= expr )
				{
				DebugLocation(232, 3);
				DebugLocation(232, 5);
				PushFollow(Follow._assignOp_in_binaryOps968);
				assignOp26=assignOp();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(232, 17);
				PushFollow(Follow._expr_in_binaryOps972);
				lhs=expr();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(232, 26);
				PushFollow(Follow._expr_in_binaryOps976);
				rhs=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(233, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.Assign((assignOp26!=null?((LSLAst)assignOp26.Start):default(LSLAst)).Token.Text, (lhs!=null?((LSLAst)lhs.Start):default(LSLAst)), (rhs!=null?((LSLAst)rhs.Start):default(LSLAst)));
							
				}

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			if (state.backtracking == 1)
			{
				 retval.Start.evalType = retval.type; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("binaryOps", 15);
			LeaveRule("binaryOps", 15);
			LeaveRule_binaryOps();
		}
		DebugLocation(238, 1);
		} finally { DebugExitRule(GrammarFileName, "binaryOps"); }
		return retval;

	}
	// $ANTLR end "binaryOps"

	private sealed partial class unaryOps_return : TreeRuleReturnScope<LSLAst>
	{
		public ISymbolType type;
		public unaryOps_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_unaryOps();
	partial void LeaveRule_unaryOps();

	// $ANTLR start "unaryOps"
	// Types.g:240:1: unaryOps returns [ISymbolType type] : ( ^( UNARY_MINUS a= expr ) | ^( UNARY_BOOL_NOT a= expr ) | ^( PRE_INCREMENT a= expr ) | ^( PRE_DECREMENT a= expr ) | ^( UNARY_BIT_NOT a= expr ) | ^( POST_INCREMENT a= expr ) | ^( POST_DECREMENT a= expr ) ) ;
	[GrammarRule("unaryOps")]
	private Types.unaryOps_return unaryOps()
	{
		EnterRule_unaryOps();
		EnterRule("unaryOps", 16);
		TraceIn("unaryOps", 16);
		Types.unaryOps_return retval = new Types.unaryOps_return(this);
		retval.Start = (LSLAst)input.LT(1);

		Types.expr_return a = default(Types.expr_return);

		try { DebugEnterRule(GrammarFileName, "unaryOps");
		DebugLocation(240, 1);
		try
		{
			// Types.g:242:2: ( ( ^( UNARY_MINUS a= expr ) | ^( UNARY_BOOL_NOT a= expr ) | ^( PRE_INCREMENT a= expr ) | ^( PRE_DECREMENT a= expr ) | ^( UNARY_BIT_NOT a= expr ) | ^( POST_INCREMENT a= expr ) | ^( POST_DECREMENT a= expr ) ) )
			DebugEnterAlt(1);
			// Types.g:243:2: ( ^( UNARY_MINUS a= expr ) | ^( UNARY_BOOL_NOT a= expr ) | ^( PRE_INCREMENT a= expr ) | ^( PRE_DECREMENT a= expr ) | ^( UNARY_BIT_NOT a= expr ) | ^( POST_INCREMENT a= expr ) | ^( POST_DECREMENT a= expr ) )
			{
			DebugLocation(243, 2);
			// Types.g:243:2: ( ^( UNARY_MINUS a= expr ) | ^( UNARY_BOOL_NOT a= expr ) | ^( PRE_INCREMENT a= expr ) | ^( PRE_DECREMENT a= expr ) | ^( UNARY_BIT_NOT a= expr ) | ^( POST_INCREMENT a= expr ) | ^( POST_DECREMENT a= expr ) )
			int alt15=7;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case UNARY_MINUS:
				{
				alt15 = 1;
				}
				break;
			case UNARY_BOOL_NOT:
				{
				alt15 = 2;
				}
				break;
			case PRE_INCREMENT:
				{
				alt15 = 3;
				}
				break;
			case PRE_DECREMENT:
				{
				alt15 = 4;
				}
				break;
			case UNARY_BIT_NOT:
				{
				alt15 = 5;
				}
				break;
			case POST_INCREMENT:
				{
				alt15 = 6;
				}
				break;
			case POST_DECREMENT:
				{
				alt15 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Types.g:244:3: ^( UNARY_MINUS a= expr )
				{
				DebugLocation(244, 3);
				DebugLocation(244, 5);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_unaryOps1014); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(244, 18);
				PushFollow(Follow._expr_in_unaryOps1018);
				a=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(245, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.Uminus((a!=null?((LSLAst)a.Start):default(LSLAst)));
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Types.g:249:3: ^( UNARY_BOOL_NOT a= expr )
				{
				DebugLocation(249, 3);
				DebugLocation(249, 5);
				Match(input,UNARY_BOOL_NOT,Follow._UNARY_BOOL_NOT_in_unaryOps1032); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(249, 21);
				PushFollow(Follow._expr_in_unaryOps1036);
				a=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(250, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.UBoolNot((a!=null?((LSLAst)a.Start):default(LSLAst)));
							
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Types.g:255:3: ^( PRE_INCREMENT a= expr )
				{
				DebugLocation(255, 3);
				DebugLocation(255, 5);
				Match(input,PRE_INCREMENT,Follow._PRE_INCREMENT_in_unaryOps1052); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(255, 20);
				PushFollow(Follow._expr_in_unaryOps1056);
				a=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(256, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.PreInc((a!=null?((LSLAst)a.Start):default(LSLAst)));
							
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Types.g:261:3: ^( PRE_DECREMENT a= expr )
				{
				DebugLocation(261, 3);
				DebugLocation(261, 5);
				Match(input,PRE_DECREMENT,Follow._PRE_DECREMENT_in_unaryOps1072); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(261, 20);
				PushFollow(Follow._expr_in_unaryOps1076);
				a=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(262, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.PreDec((a!=null?((LSLAst)a.Start):default(LSLAst)));
							
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Types.g:267:3: ^( UNARY_BIT_NOT a= expr )
				{
				DebugLocation(267, 3);
				DebugLocation(267, 5);
				Match(input,UNARY_BIT_NOT,Follow._UNARY_BIT_NOT_in_unaryOps1093); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(267, 20);
				PushFollow(Follow._expr_in_unaryOps1097);
				a=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(268, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.UBitNot((a!=null?((LSLAst)a.Start):default(LSLAst)));
							
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Types.g:273:3: ^( POST_INCREMENT a= expr )
				{
				DebugLocation(273, 3);
				DebugLocation(273, 5);
				Match(input,POST_INCREMENT,Follow._POST_INCREMENT_in_unaryOps1113); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(273, 21);
				PushFollow(Follow._expr_in_unaryOps1117);
				a=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(274, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.PostInc((a!=null?((LSLAst)a.Start):default(LSLAst)));
							
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Types.g:279:3: ^( POST_DECREMENT a= expr )
				{
				DebugLocation(279, 3);
				DebugLocation(279, 5);
				Match(input,POST_DECREMENT,Follow._POST_DECREMENT_in_unaryOps1133); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(279, 21);
				PushFollow(Follow._expr_in_unaryOps1137);
				a=expr();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				DebugLocation(280, 3);
				if (state.backtracking == 1)
				{

								retval.type = symtab.PostDec((a!=null?((LSLAst)a.Start):default(LSLAst)));
							
				}

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

			if (state.backtracking == 1)
			{
				 retval.Start.evalType = retval.type; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryOps", 16);
			LeaveRule("unaryOps", 16);
			LeaveRule_unaryOps();
		}
		DebugLocation(284, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryOps"); }
		return retval;

	}
	// $ANTLR end "unaryOps"

	private sealed partial class bop_return : TreeRuleReturnScope<LSLAst>
	{
		public bop_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_bop();
	partial void LeaveRule_bop();

	// $ANTLR start "bop"
	// Types.g:286:1: bop : ( '+' | '-' | '*' | '/' | '%' | '<<' | '>>' );
	[GrammarRule("bop")]
	private Types.bop_return bop()
	{
		EnterRule_bop();
		EnterRule("bop", 17);
		TraceIn("bop", 17);
		Types.bop_return retval = new Types.bop_return(this);
		retval.Start = (LSLAst)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "bop");
		DebugLocation(286, 47);
		try
		{
			// Types.g:286:5: ( '+' | '-' | '*' | '/' | '%' | '<<' | '>>' )
			DebugEnterAlt(1);
			// Types.g:
			{
			DebugLocation(286, 5);
			if (input.LA(1)==MINUS||input.LA(1)==57||input.LA(1)==61||input.LA(1)==63||input.LA(1)==69||input.LA(1)==71||input.LA(1)==76)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bop", 17);
			LeaveRule("bop", 17);
			LeaveRule_bop();
		}
		DebugLocation(286, 47);
		} finally { DebugExitRule(GrammarFileName, "bop"); }
		return retval;

	}
	// $ANTLR end "bop"


	partial void EnterRule_logBop();
	partial void LeaveRule_logBop();

	// $ANTLR start "logBop"
	// Types.g:288:1: logBop : ( '&&' | '||' );
	[GrammarRule("logBop")]
	private void logBop()
	{
		EnterRule_logBop();
		EnterRule("logBop", 18);
		TraceIn("logBop", 18);
		try { DebugEnterRule(GrammarFileName, "logBop");
		DebugLocation(288, 20);
		try
		{
			// Types.g:288:8: ( '&&' | '||' )
			DebugEnterAlt(1);
			// Types.g:
			{
			DebugLocation(288, 8);
			if (input.LA(1)==59||input.LA(1)==93)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logBop", 18);
			LeaveRule("logBop", 18);
			LeaveRule_logBop();
		}
		DebugLocation(288, 20);
		} finally { DebugExitRule(GrammarFileName, "logBop"); }
		return;

	}
	// $ANTLR end "logBop"


	partial void EnterRule_relOp();
	partial void LeaveRule_relOp();

	// $ANTLR start "relOp"
	// Types.g:290:1: relOp : ( '<' | '>' | '<=' | '>=' );
	[GrammarRule("relOp")]
	private void relOp()
	{
		EnterRule_relOp();
		EnterRule("relOp", 19);
		TraceIn("relOp", 19);
		try { DebugEnterRule(GrammarFileName, "relOp");
		DebugLocation(290, 31);
		try
		{
			// Types.g:290:7: ( '<' | '>' | '<=' | '>=' )
			DebugEnterAlt(1);
			// Types.g:
			{
			DebugLocation(290, 7);
			if (input.LA(1)==GT||input.LA(1)==LT||input.LA(1)==73||input.LA(1)==75)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("relOp", 19);
			LeaveRule("relOp", 19);
			LeaveRule_relOp();
		}
		DebugLocation(290, 31);
		} finally { DebugExitRule(GrammarFileName, "relOp"); }
		return;

	}
	// $ANTLR end "relOp"


	partial void EnterRule_bitOp();
	partial void LeaveRule_bitOp();

	// $ANTLR start "bitOp"
	// Types.g:292:1: bitOp : ( '|' | '&' | '^' );
	[GrammarRule("bitOp")]
	private void bitOp()
	{
		EnterRule_bitOp();
		EnterRule("bitOp", 20);
		TraceIn("bitOp", 20);
		try { DebugEnterRule(GrammarFileName, "bitOp");
		DebugLocation(292, 23);
		try
		{
			// Types.g:292:7: ( '|' | '&' | '^' )
			DebugEnterAlt(1);
			// Types.g:
			{
			DebugLocation(292, 7);
			if (input.LA(1)==60||input.LA(1)==81||input.LA(1)==92)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitOp", 20);
			LeaveRule("bitOp", 20);
			LeaveRule_bitOp();
		}
		DebugLocation(292, 23);
		} finally { DebugExitRule(GrammarFileName, "bitOp"); }
		return;

	}
	// $ANTLR end "bitOp"


	partial void EnterRule_eqOp();
	partial void LeaveRule_eqOp();

	// $ANTLR start "eqOp"
	// Types.g:294:1: eqOp : ( '==' | '!=' );
	[GrammarRule("eqOp")]
	private void eqOp()
	{
		EnterRule_eqOp();
		EnterRule("eqOp", 21);
		TraceIn("eqOp", 21);
		try { DebugEnterRule(GrammarFileName, "eqOp");
		DebugLocation(294, 18);
		try
		{
			// Types.g:294:6: ( '==' | '!=' )
			DebugEnterAlt(1);
			// Types.g:
			{
			DebugLocation(294, 6);
			if (input.LA(1)==56||input.LA(1)==74)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("eqOp", 21);
			LeaveRule("eqOp", 21);
			LeaveRule_eqOp();
		}
		DebugLocation(294, 18);
		} finally { DebugExitRule(GrammarFileName, "eqOp"); }
		return;

	}
	// $ANTLR end "eqOp"

	private sealed partial class assignOp_return : TreeRuleReturnScope<LSLAst>
	{
		public assignOp_return(Types grammar) {OnCreated(grammar);}
		partial void OnCreated(Types grammar);
	}

	partial void EnterRule_assignOp();
	partial void LeaveRule_assignOp();

	// $ANTLR start "assignOp"
	// Types.g:296:1: assignOp : ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' );
	[GrammarRule("assignOp")]
	private Types.assignOp_return assignOp()
	{
		EnterRule_assignOp();
		EnterRule("assignOp", 22);
		TraceIn("assignOp", 22);
		Types.assignOp_return retval = new Types.assignOp_return(this);
		retval.Start = (LSLAst)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "assignOp");
		DebugLocation(296, 64);
		try
		{
			// Types.g:296:9: ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' )
			DebugEnterAlt(1);
			// Types.g:
			{
			DebugLocation(296, 9);
			if (input.LA(1)==ASSIGN_EQ||input.LA(1)==58||input.LA(1)==62||input.LA(1)==65||input.LA(1)==67||input.LA(1)==70||input.LA(1)==72||input.LA(1)==77)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignOp", 22);
			LeaveRule("assignOp", 22);
			LeaveRule_assignOp();
		}
		DebugLocation(296, 64);
		} finally { DebugExitRule(GrammarFileName, "assignOp"); }
		return retval;

	}
	// $ANTLR end "assignOp"
	#endregion Rules


	#region DFA
	private DFA1 dfa1;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa1 = new DFA1( this );
	}

	private class DFA1 : DFA
	{
		private const string DFA1_eotS =
			"\xB\xFFFF";
		private const string DFA1_eofS =
			"\xB\xFFFF";
		private const string DFA1_minS =
			"\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\xE\x2\xFFFF";
		private const string DFA1_maxS =
			"\x1\x4D\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2D\x2\xFFFF";
		private const string DFA1_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\xFFFF\x1\x4"+
			"\x1\x3";
		private const string DFA1_specialS =
			"\xB\xFFFF}>";
		private static readonly string[] DFA1_transitionS =
			{
				"\x1\x3\x3\xFFFF\x1\x6\x5\xFFFF\x1\x1\x1\xFFFF\x1\x6\x3\xFFFF\x1\x6\x2"+
				"\xFFFF\x1\x7\xD\xFFFF\x1\x4\x4\xFFFF\x1\x5\x8\xFFFF\x1\x2\x1\xFFFF\x1"+
				"\x6\x4\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x1\x3\x2\xFFFF"+
				"\x1\x3\x1\xFFFF\x1\x3\x4\xFFFF\x1\x3",
				"",
				"",
				"\x1\x8",
				"",
				"",
				"",
				"",
				"\x1\xA\x1E\xFFFF\x1\x9",
				"",
				""
			};

		private static readonly short[] DFA1_eot = DFA.UnpackEncodedString(DFA1_eotS);
		private static readonly short[] DFA1_eof = DFA.UnpackEncodedString(DFA1_eofS);
		private static readonly char[] DFA1_min = DFA.UnpackEncodedStringToUnsignedChars(DFA1_minS);
		private static readonly char[] DFA1_max = DFA.UnpackEncodedStringToUnsignedChars(DFA1_maxS);
		private static readonly short[] DFA1_accept = DFA.UnpackEncodedString(DFA1_acceptS);
		private static readonly short[] DFA1_special = DFA.UnpackEncodedString(DFA1_specialS);
		private static readonly short[][] DFA1_transition;

		static DFA1()
		{
			int numStates = DFA1_transitionS.Length;
			DFA1_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA1_transition[i] = DFA.UnpackEncodedString(DFA1_transitionS[i]);
			}
		}

		public DFA1( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}

		public override string Description { get { return "22:1: bottomup : ( exprRoot | varDecl | rootAssign | rootSubAssign | returnStmt | stateChg | logicalStmts | jumpStmt );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _exprRoot_in_bottomup63 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varDecl_in_bottomup68 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rootAssign_in_bottomup73 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rootSubAssign_in_bottomup78 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStmt_in_bottomup83 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stateChg_in_bottomup88 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalStmts_in_bottomup93 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _jumpStmt_in_bottomup98 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JUMP_STMT_in_jumpStmt112 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_jumpStmt114 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IF_STMT_in_logicalStmts131 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _WHILE_STMT_in_logicalStmts151 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _DO_WHILE_STMT_in_logicalStmts173 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FOR_STMT_in_logicalStmts195 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _STATE_CHG_in_stateChg228 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_stateChg230 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RETURN_STMT_in_returnStmt248 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_returnStmt250 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignOp_in_rootAssign281 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _exprRoot_in_rootAssign285 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _exprRoot_in_rootAssign289 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignOp_in_rootSubAssign317 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SUBSCRIPT_in_rootSubAssign322 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _exprRoot_in_rootSubAssign330 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VAR_DECL_in_varDecl349 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_varDecl353 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0xFFFFFFFFUL});
		public static readonly BitSet _EXPR_in_exprRoot386 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exprRoot388 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INTEGER_LITERAL_in_expr411 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_LITERAL_in_expr424 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VECTOR_LITERAL_in_expr438 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr442 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_expr446 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_expr450 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ROTATION_LITERAL_in_expr471 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr475 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_expr479 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_expr483 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_expr487 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _listLiteral_in_expr507 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_expr521 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expr537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typeCast_in_expr574 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _binaryOps_in_expr590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodCall_in_expr602 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryOps_in_expr614 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subScript_in_expr626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXPR_in_expr639 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr643 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LIST_LITERAL_in_listLiteral678 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ELIST_in_listLiteral681 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_listLiteral684 = new BitSet(new ulong[]{0xFF17B05E5A4CC018UL,0x30023FEAUL});
		public static readonly BitSet _SUBSCRIPT_in_subScript722 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_subScript726 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_subScript730 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _METHOD_CALL_in_methodCall757 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_methodCall759 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ELIST_in_methodCall762 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_methodCall765 = new BitSet(new ulong[]{0xFF17B05E5A4CC018UL,0x30023FEAUL});
		public static readonly BitSet _TYPE_CAST_in_typeCast796 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TYPE_in_typeCast798 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_typeCast800 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _bop_in_binaryOps833 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryOps837 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_binaryOps841 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _logBop_in_binaryOps860 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryOps864 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_binaryOps868 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _relOp_in_binaryOps887 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryOps891 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_binaryOps895 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _bitOp_in_binaryOps914 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryOps918 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_binaryOps922 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _eqOp_in_binaryOps941 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryOps945 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_binaryOps949 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _assignOp_in_binaryOps968 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryOps972 = new BitSet(new ulong[]{0xFF17B05E5A4CC010UL,0x30023FEAUL});
		public static readonly BitSet _expr_in_binaryOps976 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_MINUS_in_unaryOps1014 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_unaryOps1018 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_BOOL_NOT_in_unaryOps1032 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_unaryOps1036 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_INCREMENT_in_unaryOps1052 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_unaryOps1056 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PRE_DECREMENT_in_unaryOps1072 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_unaryOps1076 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UNARY_BIT_NOT_in_unaryOps1093 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_unaryOps1097 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_INCREMENT_in_unaryOps1113 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_unaryOps1117 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POST_DECREMENT_in_unaryOps1133 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_unaryOps1137 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _set_in_bop1154 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_logBop1186 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_relOp1198 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_bitOp1218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_eqOp1234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_assignOp1245 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  Halcyon.Phlox.Compiler 
