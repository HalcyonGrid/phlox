//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 Assembler.g 2012-05-22 12:15:01

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;

namespace  Halcyon.Phlox.ByteCompiler 
{
/** 
 *  A generic bytecode assembler whose instructions take 0..3 operands.
 *  Instruction set is dictated externally with a String[].  Implement
 *  specifics by subclassing and defining gen() methods. Comments start
 *  with ';' and all instructions end with '\n'.  Handles both register (rN)
 *  and stack-based assembly instructions.  Labels are "ID:".  "main:" label
 *  is where we start execution.  Use .globals and .def for global data
 *  and function definitions, respectively.
 */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class AssemblerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ESC_SEQ", "FLOAT", "FUNC", "ID", "INT", "LETTER", "NEWLINE", "REG", "ROTATION", "ROT_FLOATS", "STATE_ID", "STRING", "STR_INTERNALS", "VECTOR", "VEC_FLOATS", "WS", "','", "'.def'", "'.evt'", "'.globals'", "'.statedef'", "'/'", "':'", "'='", "'args'", "'locals'"
	};
	public const int EOF=-1;
	public const int ESC_SEQ=4;
	public const int FLOAT=5;
	public const int FUNC=6;
	public const int ID=7;
	public const int INT=8;
	public const int LETTER=9;
	public const int NEWLINE=10;
	public const int REG=11;
	public const int ROTATION=12;
	public const int ROT_FLOATS=13;
	public const int STATE_ID=14;
	public const int STRING=15;
	public const int STR_INTERNALS=16;
	public const int VECTOR=17;
	public const int VEC_FLOATS=18;
	public const int WS=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int T__25=25;
	public const int T__26=26;
	public const int T__27=27;
	public const int T__28=28;
	public const int T__29=29;

	// delegates
	// delegators

	public AssemblerParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public AssemblerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return AssemblerParser.tokenNames; } }
	public override string GrammarFileName { get { return "Assembler.g"; } }


		private BytecodeGenerator _bytecodeGen;
		public void SetGenerator(BytecodeGenerator bcg) { _bytecodeGen = bcg; }

		// Define the functionality required by the parser for code generation
		protected void Gen(IToken instrToken) {_bytecodeGen.Gen(instrToken);}
		protected void Gen(IToken instrToken, IToken operandToken) {_bytecodeGen.Gen(instrToken, operandToken);}
		protected void Gen(IToken instrToken, IToken oToken1, IToken oToken2) {_bytecodeGen.Gen(instrToken, oToken1, oToken2);}
		protected void Gen(IToken instrToken, IToken oToken1, IToken oToken2, IToken oToken3) {_bytecodeGen.Gen(instrToken, oToken1, oToken2, oToken3);}
		protected void CheckForUnresolvedReferences() {_bytecodeGen.CheckForUnresolvedReferences();}
		protected void DefineFunction(IToken idToken, int nargs, int nlocals) {_bytecodeGen.DefineFunction(idToken, nargs, nlocals);}
		protected void DefineEventHandler(IToken stateIdToken, IToken idToken, int nargs, int nlocals) {_bytecodeGen.DefineEventHandler(stateIdToken, idToken, nargs, nlocals);}
		protected void DefineDataSize(int n) {_bytecodeGen.DefineDataSize(n);}
		protected void DefineLabel(IToken idToken) {_bytecodeGen.DefineLabel(idToken);}
		protected void DefineState(IToken stateId) {_bytecodeGen.DefineState(stateId);}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// Assembler.g:37:8: public program : ( globals )? ( functionDeclaration | eventHandlerDecl | stateDecl | instr | label | NEWLINE )+ ;
	[GrammarRule("program")]
	public void program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(37, 4);
		try
		{
			// Assembler.g:38:5: ( ( globals )? ( functionDeclaration | eventHandlerDecl | stateDecl | instr | label | NEWLINE )+ )
			DebugEnterAlt(1);
			// Assembler.g:38:9: ( globals )? ( functionDeclaration | eventHandlerDecl | stateDecl | instr | label | NEWLINE )+
			{
			DebugLocation(38, 9);
			// Assembler.g:38:9: ( globals )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			try
			{
				alt1 = dfa1.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Assembler.g:38:9: globals
				{
				DebugLocation(38, 9);
				PushFollow(Follow._globals_in_program47);
				globals();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(39, 9);
			// Assembler.g:39:9: ( functionDeclaration | eventHandlerDecl | stateDecl | instr | label | NEWLINE )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=7;
				try { DebugEnterDecision(2, false);
				switch (input.LA(1))
				{
				case 21:
					{
					alt2 = 1;
					}
					break;
				case 22:
					{
					alt2 = 2;
					}
					break;
				case 24:
					{
					alt2 = 3;
					}
					break;
				case ID:
					{
					int LA2_5 = input.LA(2);

					if (((LA2_5>=FLOAT && LA2_5<=INT)||(LA2_5>=NEWLINE && LA2_5<=ROTATION)||(LA2_5>=STATE_ID && LA2_5<=STRING)||LA2_5==VECTOR))
					{
						alt2 = 4;
					}
					else if ((LA2_5==26))
					{
						alt2 = 5;
					}


					}
					break;
				case NEWLINE:
					{
					alt2 = 6;
					}
					break;

				}

				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// Assembler.g:39:11: functionDeclaration
					{
					DebugLocation(39, 11);
					PushFollow(Follow._functionDeclaration_in_program60);
					functionDeclaration();
					PopFollow();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Assembler.g:39:33: eventHandlerDecl
					{
					DebugLocation(39, 33);
					PushFollow(Follow._eventHandlerDecl_in_program64);
					eventHandlerDecl();
					PopFollow();


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Assembler.g:39:52: stateDecl
					{
					DebugLocation(39, 52);
					PushFollow(Follow._stateDecl_in_program68);
					stateDecl();
					PopFollow();


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Assembler.g:39:64: instr
					{
					DebugLocation(39, 64);
					PushFollow(Follow._instr_in_program72);
					instr();
					PopFollow();


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Assembler.g:39:72: label
					{
					DebugLocation(39, 72);
					PushFollow(Follow._label_in_program76);
					label();
					PopFollow();


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Assembler.g:39:80: NEWLINE
					{
					DebugLocation(39, 80);
					Match(input,NEWLINE,Follow._NEWLINE_in_program80); 

					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(40, 9);
			CheckForUnresolvedReferences();

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(41, 4);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return;

	}
	// $ANTLR end "program"


	partial void EnterRule_globals();
	partial void LeaveRule_globals();

	// $ANTLR start "globals"
	// Assembler.g:45:1: globals : ( NEWLINE )* '.globals' INT NEWLINE ;
	[GrammarRule("globals")]
	private void globals()
	{
		EnterRule_globals();
		EnterRule("globals", 2);
		TraceIn("globals", 2);
		IToken INT1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "globals");
		DebugLocation(45, 70);
		try
		{
			// Assembler.g:45:9: ( ( NEWLINE )* '.globals' INT NEWLINE )
			DebugEnterAlt(1);
			// Assembler.g:45:11: ( NEWLINE )* '.globals' INT NEWLINE
			{
			DebugLocation(45, 11);
			// Assembler.g:45:11: ( NEWLINE )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==NEWLINE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Assembler.g:45:11: NEWLINE
					{
					DebugLocation(45, 11);
					Match(input,NEWLINE,Follow._NEWLINE_in_globals111); 

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(45, 20);
			Match(input,23,Follow._23_in_globals114); 
			DebugLocation(45, 31);
			INT1=(IToken)Match(input,INT,Follow._INT_in_globals116); 
			DebugLocation(45, 35);
			Match(input,NEWLINE,Follow._NEWLINE_in_globals118); 
			DebugLocation(45, 43);
			DefineDataSize((INT1!=null?int.Parse(INT1.Text):0));

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("globals", 2);
			LeaveRule("globals", 2);
			LeaveRule_globals();
		}
		DebugLocation(45, 70);
		} finally { DebugExitRule(GrammarFileName, "globals"); }
		return;

	}
	// $ANTLR end "globals"


	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();

	// $ANTLR start "functionDeclaration"
	// Assembler.g:50:1: functionDeclaration : '.def' name= ID ':' 'args' '=' a= INT ',' 'locals' '=' lo= INT NEWLINE ;
	[GrammarRule("functionDeclaration")]
	private void functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 3);
		TraceIn("functionDeclaration", 3);
		IToken name = default(IToken);
		IToken a = default(IToken);
		IToken lo = default(IToken);

		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(50, 4);
		try
		{
			// Assembler.g:51:5: ( '.def' name= ID ':' 'args' '=' a= INT ',' 'locals' '=' lo= INT NEWLINE )
			DebugEnterAlt(1);
			// Assembler.g:51:9: '.def' name= ID ':' 'args' '=' a= INT ',' 'locals' '=' lo= INT NEWLINE
			{
			DebugLocation(51, 9);
			Match(input,21,Follow._21_in_functionDeclaration138); 
			DebugLocation(51, 20);
			name=(IToken)Match(input,ID,Follow._ID_in_functionDeclaration142); 
			DebugLocation(51, 24);
			Match(input,26,Follow._26_in_functionDeclaration144); 
			DebugLocation(51, 28);
			Match(input,28,Follow._28_in_functionDeclaration146); 
			DebugLocation(51, 35);
			Match(input,27,Follow._27_in_functionDeclaration148); 
			DebugLocation(51, 40);
			a=(IToken)Match(input,INT,Follow._INT_in_functionDeclaration152); 
			DebugLocation(51, 45);
			Match(input,20,Follow._20_in_functionDeclaration154); 
			DebugLocation(51, 49);
			Match(input,29,Follow._29_in_functionDeclaration156); 
			DebugLocation(51, 58);
			Match(input,27,Follow._27_in_functionDeclaration158); 
			DebugLocation(51, 64);
			lo=(IToken)Match(input,INT,Follow._INT_in_functionDeclaration162); 
			DebugLocation(51, 69);
			Match(input,NEWLINE,Follow._NEWLINE_in_functionDeclaration164); 
			DebugLocation(52, 9);
			DefineFunction(name, (a!=null?int.Parse(a.Text):0), (lo!=null?int.Parse(lo.Text):0));

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionDeclaration", 3);
			LeaveRule("functionDeclaration", 3);
			LeaveRule_functionDeclaration();
		}
		DebugLocation(53, 4);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return;

	}
	// $ANTLR end "functionDeclaration"


	partial void EnterRule_eventHandlerDecl();
	partial void LeaveRule_eventHandlerDecl();

	// $ANTLR start "eventHandlerDecl"
	// Assembler.g:55:1: eventHandlerDecl : '.evt' state= ID '/' name= ID ':' 'args' '=' a= INT ',' 'locals' '=' lo= INT NEWLINE ;
	[GrammarRule("eventHandlerDecl")]
	private void eventHandlerDecl()
	{
		EnterRule_eventHandlerDecl();
		EnterRule("eventHandlerDecl", 4);
		TraceIn("eventHandlerDecl", 4);
		IToken state = default(IToken);
		IToken name = default(IToken);
		IToken a = default(IToken);
		IToken lo = default(IToken);

		try { DebugEnterRule(GrammarFileName, "eventHandlerDecl");
		DebugLocation(55, 4);
		try
		{
			// Assembler.g:56:5: ( '.evt' state= ID '/' name= ID ':' 'args' '=' a= INT ',' 'locals' '=' lo= INT NEWLINE )
			DebugEnterAlt(1);
			// Assembler.g:56:9: '.evt' state= ID '/' name= ID ':' 'args' '=' a= INT ',' 'locals' '=' lo= INT NEWLINE
			{
			DebugLocation(56, 9);
			Match(input,22,Follow._22_in_eventHandlerDecl197); 
			DebugLocation(56, 21);
			state=(IToken)Match(input,ID,Follow._ID_in_eventHandlerDecl201); 
			DebugLocation(56, 25);
			Match(input,25,Follow._25_in_eventHandlerDecl203); 
			DebugLocation(56, 33);
			name=(IToken)Match(input,ID,Follow._ID_in_eventHandlerDecl207); 
			DebugLocation(56, 37);
			Match(input,26,Follow._26_in_eventHandlerDecl209); 
			DebugLocation(56, 41);
			Match(input,28,Follow._28_in_eventHandlerDecl211); 
			DebugLocation(56, 48);
			Match(input,27,Follow._27_in_eventHandlerDecl213); 
			DebugLocation(56, 53);
			a=(IToken)Match(input,INT,Follow._INT_in_eventHandlerDecl217); 
			DebugLocation(56, 58);
			Match(input,20,Follow._20_in_eventHandlerDecl219); 
			DebugLocation(56, 62);
			Match(input,29,Follow._29_in_eventHandlerDecl221); 
			DebugLocation(56, 71);
			Match(input,27,Follow._27_in_eventHandlerDecl223); 
			DebugLocation(56, 77);
			lo=(IToken)Match(input,INT,Follow._INT_in_eventHandlerDecl227); 
			DebugLocation(56, 82);
			Match(input,NEWLINE,Follow._NEWLINE_in_eventHandlerDecl229); 
			DebugLocation(57, 9);
			DefineEventHandler(state, name, (a!=null?int.Parse(a.Text):0), (lo!=null?int.Parse(lo.Text):0));

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("eventHandlerDecl", 4);
			LeaveRule("eventHandlerDecl", 4);
			LeaveRule_eventHandlerDecl();
		}
		DebugLocation(58, 4);
		} finally { DebugExitRule(GrammarFileName, "eventHandlerDecl"); }
		return;

	}
	// $ANTLR end "eventHandlerDecl"


	partial void EnterRule_stateDecl();
	partial void LeaveRule_stateDecl();

	// $ANTLR start "stateDecl"
	// Assembler.g:61:1: stateDecl : '.statedef' name= ID NEWLINE ;
	[GrammarRule("stateDecl")]
	private void stateDecl()
	{
		EnterRule_stateDecl();
		EnterRule("stateDecl", 5);
		TraceIn("stateDecl", 5);
		IToken name = default(IToken);

		try { DebugEnterRule(GrammarFileName, "stateDecl");
		DebugLocation(61, 4);
		try
		{
			// Assembler.g:62:5: ( '.statedef' name= ID NEWLINE )
			DebugEnterAlt(1);
			// Assembler.g:62:9: '.statedef' name= ID NEWLINE
			{
			DebugLocation(62, 9);
			Match(input,24,Follow._24_in_stateDecl259); 
			DebugLocation(62, 25);
			name=(IToken)Match(input,ID,Follow._ID_in_stateDecl263); 
			DebugLocation(62, 29);
			Match(input,NEWLINE,Follow._NEWLINE_in_stateDecl265); 
			DebugLocation(63, 9);
			DefineState(name);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stateDecl", 5);
			LeaveRule("stateDecl", 5);
			LeaveRule_stateDecl();
		}
		DebugLocation(64, 4);
		} finally { DebugExitRule(GrammarFileName, "stateDecl"); }
		return;

	}
	// $ANTLR end "stateDecl"


	partial void EnterRule_instr();
	partial void LeaveRule_instr();

	// $ANTLR start "instr"
	// Assembler.g:68:1: instr : ( ID NEWLINE | ID operand NEWLINE | ID a= operand ',' b= operand NEWLINE | ID a= operand ',' b= operand ',' c= operand NEWLINE );
	[GrammarRule("instr")]
	private void instr()
	{
		EnterRule_instr();
		EnterRule("instr", 6);
		TraceIn("instr", 6);
		IToken ID2 = default(IToken);
		IToken ID3 = default(IToken);
		IToken ID5 = default(IToken);
		IToken ID6 = default(IToken);
		AssemblerParser.operand_return a = default(AssemblerParser.operand_return);
		AssemblerParser.operand_return b = default(AssemblerParser.operand_return);
		AssemblerParser.operand_return c = default(AssemblerParser.operand_return);
		AssemblerParser.operand_return operand4 = default(AssemblerParser.operand_return);

		try { DebugEnterRule(GrammarFileName, "instr");
		DebugLocation(68, 4);
		try
		{
			// Assembler.g:69:5: ( ID NEWLINE | ID operand NEWLINE | ID a= operand ',' b= operand NEWLINE | ID a= operand ',' b= operand ',' c= operand NEWLINE )
			int alt4=4;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==ID))
			{
				int LA4_1 = input.LA(2);

				if ((LA4_1==NEWLINE))
				{
					alt4 = 1;
				}
				else if (((LA4_1>=FLOAT && LA4_1<=INT)||(LA4_1>=REG && LA4_1<=ROTATION)||(LA4_1>=STATE_ID && LA4_1<=STRING)||LA4_1==VECTOR))
				{
					int LA4_3 = input.LA(3);

					if ((LA4_3==NEWLINE))
					{
						alt4 = 2;
					}
					else if ((LA4_3==20))
					{
						int LA4_5 = input.LA(4);

						if (((LA4_5>=FLOAT && LA4_5<=INT)||(LA4_5>=REG && LA4_5<=ROTATION)||(LA4_5>=STATE_ID && LA4_5<=STRING)||LA4_5==VECTOR))
						{
							int LA4_6 = input.LA(5);

							if ((LA4_6==NEWLINE))
							{
								alt4 = 3;
							}
							else if ((LA4_6==20))
							{
								alt4 = 4;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 4, 6, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 4, 5, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 4, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 4, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Assembler.g:69:9: ID NEWLINE
				{
				DebugLocation(69, 9);
				ID2=(IToken)Match(input,ID,Follow._ID_in_instr298); 
				DebugLocation(69, 12);
				Match(input,NEWLINE,Follow._NEWLINE_in_instr300); 
				DebugLocation(69, 44);
				Gen(ID2);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Assembler.g:70:9: ID operand NEWLINE
				{
				DebugLocation(70, 9);
				ID3=(IToken)Match(input,ID,Follow._ID_in_instr336); 
				DebugLocation(70, 12);
				PushFollow(Follow._operand_in_instr338);
				operand4=operand();
				PopFollow();

				DebugLocation(70, 20);
				Match(input,NEWLINE,Follow._NEWLINE_in_instr340); 
				DebugLocation(70, 44);
				Gen(ID3,(operand4!=null?((IToken)operand4.Start):default(IToken)));

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Assembler.g:71:9: ID a= operand ',' b= operand NEWLINE
				{
				DebugLocation(71, 9);
				ID5=(IToken)Match(input,ID,Follow._ID_in_instr368); 
				DebugLocation(71, 13);
				PushFollow(Follow._operand_in_instr372);
				a=operand();
				PopFollow();

				DebugLocation(71, 22);
				Match(input,20,Follow._20_in_instr374); 
				DebugLocation(71, 27);
				PushFollow(Follow._operand_in_instr378);
				b=operand();
				PopFollow();

				DebugLocation(71, 36);
				Match(input,NEWLINE,Follow._NEWLINE_in_instr380); 
				DebugLocation(71, 44);
				Gen(ID5,(a!=null?((IToken)a.Start):default(IToken)),(b!=null?((IToken)b.Start):default(IToken)));

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Assembler.g:72:9: ID a= operand ',' b= operand ',' c= operand NEWLINE
				{
				DebugLocation(72, 9);
				ID6=(IToken)Match(input,ID,Follow._ID_in_instr392); 
				DebugLocation(72, 13);
				PushFollow(Follow._operand_in_instr396);
				a=operand();
				PopFollow();

				DebugLocation(72, 22);
				Match(input,20,Follow._20_in_instr398); 
				DebugLocation(72, 27);
				PushFollow(Follow._operand_in_instr402);
				b=operand();
				PopFollow();

				DebugLocation(72, 36);
				Match(input,20,Follow._20_in_instr404); 
				DebugLocation(72, 41);
				PushFollow(Follow._operand_in_instr408);
				c=operand();
				PopFollow();

				DebugLocation(72, 50);
				Match(input,NEWLINE,Follow._NEWLINE_in_instr410); 
				DebugLocation(73, 9);
				Gen(ID6,(a!=null?((IToken)a.Start):default(IToken)),(b!=null?((IToken)b.Start):default(IToken)),(c!=null?((IToken)c.Start):default(IToken)));

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("instr", 6);
			LeaveRule("instr", 6);
			LeaveRule_instr();
		}
		DebugLocation(74, 4);
		} finally { DebugExitRule(GrammarFileName, "instr"); }
		return;

	}
	// $ANTLR end "instr"

	private sealed partial class operand_return : ParserRuleReturnScope<IToken>
	{
		public operand_return(AssemblerParser grammar) {OnCreated(grammar);}
		partial void OnCreated(AssemblerParser grammar);
	}

	partial void EnterRule_operand();
	partial void LeaveRule_operand();

	// $ANTLR start "operand"
	// Assembler.g:78:1: operand : ( ID | REG | FUNC | INT | STRING | VECTOR | ROTATION | FLOAT | STATE_ID );
	[GrammarRule("operand")]
	private AssemblerParser.operand_return operand()
	{
		EnterRule_operand();
		EnterRule("operand", 7);
		TraceIn("operand", 7);
		AssemblerParser.operand_return retval = new AssemblerParser.operand_return(this);
		retval.Start = (IToken)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "operand");
		DebugLocation(78, 4);
		try
		{
			// Assembler.g:79:5: ( ID | REG | FUNC | INT | STRING | VECTOR | ROTATION | FLOAT | STATE_ID )
			DebugEnterAlt(1);
			// Assembler.g:
			{
			DebugLocation(79, 5);
			if ((input.LA(1)>=FLOAT && input.LA(1)<=INT)||(input.LA(1)>=REG && input.LA(1)<=ROTATION)||(input.LA(1)>=STATE_ID && input.LA(1)<=STRING)||input.LA(1)==VECTOR)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("operand", 7);
			LeaveRule("operand", 7);
			LeaveRule_operand();
		}
		DebugLocation(90, 4);
		} finally { DebugExitRule(GrammarFileName, "operand"); }
		return retval;

	}
	// $ANTLR end "operand"


	partial void EnterRule_label();
	partial void LeaveRule_label();

	// $ANTLR start "label"
	// Assembler.g:92:1: label : ID ':' ;
	[GrammarRule("label")]
	private void label()
	{
		EnterRule_label();
		EnterRule("label", 8);
		TraceIn("label", 8);
		IToken ID7 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "label");
		DebugLocation(92, 4);
		try
		{
			// Assembler.g:93:5: ( ID ':' )
			DebugEnterAlt(1);
			// Assembler.g:93:9: ID ':'
			{
			DebugLocation(93, 9);
			ID7=(IToken)Match(input,ID,Follow._ID_in_label542); 
			DebugLocation(93, 12);
			Match(input,26,Follow._26_in_label544); 
			DebugLocation(93, 16);
			DefineLabel(ID7);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("label", 8);
			LeaveRule("label", 8);
			LeaveRule_label();
		}
		DebugLocation(94, 4);
		} finally { DebugExitRule(GrammarFileName, "label"); }
		return;

	}
	// $ANTLR end "label"
	#endregion Rules


	#region DFA
	private DFA1 dfa1;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa1 = new DFA1( this );
	}

	private class DFA1 : DFA
	{
		private const string DFA1_eotS =
			"\x4\xFFFF";
		private const string DFA1_eofS =
			"\x1\xFFFF\x1\x3\x2\xFFFF";
		private const string DFA1_minS =
			"\x2\x7\x2\xFFFF";
		private const string DFA1_maxS =
			"\x2\x18\x2\xFFFF";
		private const string DFA1_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA1_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA1_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x1\xA\xFFFF\x2\x3\x1\x2\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x1\xA\xFFFF\x2\x3\x1\x2\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA1_eot = DFA.UnpackEncodedString(DFA1_eotS);
		private static readonly short[] DFA1_eof = DFA.UnpackEncodedString(DFA1_eofS);
		private static readonly char[] DFA1_min = DFA.UnpackEncodedStringToUnsignedChars(DFA1_minS);
		private static readonly char[] DFA1_max = DFA.UnpackEncodedStringToUnsignedChars(DFA1_maxS);
		private static readonly short[] DFA1_accept = DFA.UnpackEncodedString(DFA1_acceptS);
		private static readonly short[] DFA1_special = DFA.UnpackEncodedString(DFA1_specialS);
		private static readonly short[][] DFA1_transition;

		static DFA1()
		{
			int numStates = DFA1_transitionS.Length;
			DFA1_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA1_transition[i] = DFA.UnpackEncodedString(DFA1_transitionS[i]);
			}
		}

		public DFA1( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}

		public override string Description { get { return "38:9: ( globals )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _globals_in_program47 = new BitSet(new ulong[]{0x1600480UL});
		public static readonly BitSet _functionDeclaration_in_program60 = new BitSet(new ulong[]{0x1600482UL});
		public static readonly BitSet _eventHandlerDecl_in_program64 = new BitSet(new ulong[]{0x1600482UL});
		public static readonly BitSet _stateDecl_in_program68 = new BitSet(new ulong[]{0x1600482UL});
		public static readonly BitSet _instr_in_program72 = new BitSet(new ulong[]{0x1600482UL});
		public static readonly BitSet _label_in_program76 = new BitSet(new ulong[]{0x1600482UL});
		public static readonly BitSet _NEWLINE_in_program80 = new BitSet(new ulong[]{0x1600482UL});
		public static readonly BitSet _NEWLINE_in_globals111 = new BitSet(new ulong[]{0x800400UL});
		public static readonly BitSet _23_in_globals114 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _INT_in_globals116 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_globals118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _21_in_functionDeclaration138 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _ID_in_functionDeclaration142 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_functionDeclaration144 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _28_in_functionDeclaration146 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_functionDeclaration148 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _INT_in_functionDeclaration152 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_functionDeclaration154 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _29_in_functionDeclaration156 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_functionDeclaration158 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _INT_in_functionDeclaration162 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_functionDeclaration164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _22_in_eventHandlerDecl197 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _ID_in_eventHandlerDecl201 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _25_in_eventHandlerDecl203 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _ID_in_eventHandlerDecl207 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_eventHandlerDecl209 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _28_in_eventHandlerDecl211 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_eventHandlerDecl213 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _INT_in_eventHandlerDecl217 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_eventHandlerDecl219 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _29_in_eventHandlerDecl221 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _27_in_eventHandlerDecl223 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _INT_in_eventHandlerDecl227 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_eventHandlerDecl229 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _24_in_stateDecl259 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _ID_in_stateDecl263 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_stateDecl265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_instr298 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_instr300 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_instr336 = new BitSet(new ulong[]{0x2D9E0UL});
		public static readonly BitSet _operand_in_instr338 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_instr340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_instr368 = new BitSet(new ulong[]{0x2D9E0UL});
		public static readonly BitSet _operand_in_instr372 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_instr374 = new BitSet(new ulong[]{0x2D9E0UL});
		public static readonly BitSet _operand_in_instr378 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_instr380 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_instr392 = new BitSet(new ulong[]{0x2D9E0UL});
		public static readonly BitSet _operand_in_instr396 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_instr398 = new BitSet(new ulong[]{0x2D9E0UL});
		public static readonly BitSet _operand_in_instr402 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _20_in_instr404 = new BitSet(new ulong[]{0x2D9E0UL});
		public static readonly BitSet _operand_in_instr408 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NEWLINE_in_instr410 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_operand437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_label542 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _26_in_label544 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  Halcyon.Phlox.ByteCompiler 
