//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 FuncProtoToShim.g 2011-03-22 21:26:47

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;

namespace  Halcyon.Phlox.Tools 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class FuncProtoToShimParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ID", "NEWLINE", "TYPE", "WS", "'('", "')'", "','"
	};
	public const int EOF=-1;
	public const int ID=4;
	public const int NEWLINE=5;
	public const int TYPE=6;
	public const int WS=7;
	public const int T__8=8;
	public const int T__9=9;
	public const int T__10=10;

	// delegates
	// delegators

	public FuncProtoToShimParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public FuncProtoToShimParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return FuncProtoToShimParser.tokenNames; } }
	public override string GrammarFileName { get { return "FuncProtoToShim.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_list();
	partial void LeaveRule_list();

	// $ANTLR start "list"
	// FuncProtoToShim.g:10:8: public list : ( funcDef )+ ;
	[GrammarRule("list")]
	public void list()
	{
		EnterRule_list();
		EnterRule("list", 1);
		TraceIn("list", 1);
		try { DebugEnterRule(GrammarFileName, "list");
		DebugLocation(10, 1);
		try
		{
			// FuncProtoToShim.g:10:13: ( ( funcDef )+ )
			DebugEnterAlt(1);
			// FuncProtoToShim.g:10:15: ( funcDef )+
			{
			DebugLocation(10, 15);
			// FuncProtoToShim.g:10:15: ( funcDef )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==ID||LA1_0==TYPE))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// FuncProtoToShim.g:10:15: funcDef
					{
					DebugLocation(10, 15);
					PushFollow(Follow._funcDef_in_list33);
					funcDef();
					PopFollow();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("list", 1);
			LeaveRule("list", 1);
			LeaveRule_list();
		}
		DebugLocation(11, 1);
		} finally { DebugExitRule(GrammarFileName, "list"); }
		return;

	}
	// $ANTLR end "list"


	partial void EnterRule_funcDef();
	partial void LeaveRule_funcDef();

	// $ANTLR start "funcDef"
	// FuncProtoToShim.g:13:1: funcDef : ( TYPE )? ID '(' ( parmList )? ')' ( NEWLINE | EOF ) ;
	[GrammarRule("funcDef")]
	private void funcDef()
	{
		EnterRule_funcDef();
		EnterRule("funcDef", 2);
		TraceIn("funcDef", 2);
		IToken TYPE1 = default(IToken);
		IToken ID2 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "funcDef");
		DebugLocation(13, 1);
		try
		{
			// FuncProtoToShim.g:15:3: ( ( TYPE )? ID '(' ( parmList )? ')' ( NEWLINE | EOF ) )
			DebugEnterAlt(1);
			// FuncProtoToShim.g:15:3: ( TYPE )? ID '(' ( parmList )? ')' ( NEWLINE | EOF )
			{
			DebugLocation(15, 3);
			// FuncProtoToShim.g:15:3: ( TYPE )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==TYPE))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// FuncProtoToShim.g:15:3: TYPE
				{
				DebugLocation(15, 3);
				TYPE1=(IToken)Match(input,TYPE,Follow._TYPE_in_funcDef49); 

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(15, 9);
			ID2=(IToken)Match(input,ID,Follow._ID_in_funcDef52); 
			DebugLocation(15, 12);
			Match(input,8,Follow._8_in_funcDef54); 
			DebugLocation(15, 16);
			// FuncProtoToShim.g:15:16: ( parmList )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==TYPE))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// FuncProtoToShim.g:15:16: parmList
				{
				DebugLocation(15, 16);
				PushFollow(Follow._parmList_in_funcDef56);
				parmList();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(15, 26);
			Match(input,9,Follow._9_in_funcDef59); 
			DebugLocation(15, 30);
			if (input.LA(1)==EOF||input.LA(1)==NEWLINE)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(16, 2);
			 
					if (TYPE1 != null) type = (TYPE1!=null?TYPE1.Text:null);
					id = (ID2!=null?ID2.Text:null);
				

			}

			 AddEntry(); 
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcDef", 2);
			LeaveRule("funcDef", 2);
			LeaveRule_funcDef();
		}
		DebugLocation(20, 1);
		} finally { DebugExitRule(GrammarFileName, "funcDef"); }
		return;

	}
	// $ANTLR end "funcDef"


	partial void EnterRule_parmList();
	partial void LeaveRule_parmList();

	// $ANTLR start "parmList"
	// FuncProtoToShim.g:22:1: parmList : parm ( ',' parm )* ;
	[GrammarRule("parmList")]
	private void parmList()
	{
		EnterRule_parmList();
		EnterRule("parmList", 3);
		TraceIn("parmList", 3);
		try { DebugEnterRule(GrammarFileName, "parmList");
		DebugLocation(22, 1);
		try
		{
			// FuncProtoToShim.g:22:9: ( parm ( ',' parm )* )
			DebugEnterAlt(1);
			// FuncProtoToShim.g:22:11: parm ( ',' parm )*
			{
			DebugLocation(22, 11);
			PushFollow(Follow._parm_in_parmList81);
			parm();
			PopFollow();

			DebugLocation(22, 16);
			// FuncProtoToShim.g:22:16: ( ',' parm )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==10))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// FuncProtoToShim.g:22:17: ',' parm
					{
					DebugLocation(22, 17);
					Match(input,10,Follow._10_in_parmList84); 
					DebugLocation(22, 21);
					PushFollow(Follow._parm_in_parmList86);
					parm();
					PopFollow();


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parmList", 3);
			LeaveRule("parmList", 3);
			LeaveRule_parmList();
		}
		DebugLocation(23, 1);
		} finally { DebugExitRule(GrammarFileName, "parmList"); }
		return;

	}
	// $ANTLR end "parmList"


	partial void EnterRule_parm();
	partial void LeaveRule_parm();

	// $ANTLR start "parm"
	// FuncProtoToShim.g:25:1: parm : TYPE ID ;
	[GrammarRule("parm")]
	private void parm()
	{
		EnterRule_parm();
		EnterRule("parm", 4);
		TraceIn("parm", 4);
		IToken ID3 = default(IToken);
		IToken TYPE4 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "parm");
		DebugLocation(25, 1);
		try
		{
			// FuncProtoToShim.g:25:6: ( TYPE ID )
			DebugEnterAlt(1);
			// FuncProtoToShim.g:25:8: TYPE ID
			{
			DebugLocation(25, 8);
			TYPE4=(IToken)Match(input,TYPE,Follow._TYPE_in_parm99); 
			DebugLocation(25, 13);
			ID3=(IToken)Match(input,ID,Follow._ID_in_parm101); 
			DebugLocation(26, 3);

						parmNames.Add((ID3!=null?ID3.Text:null));
						parmTypes.Add((TYPE4!=null?TYPE4.Text:null));
					

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parm", 4);
			LeaveRule("parm", 4);
			LeaveRule_parm();
		}
		DebugLocation(30, 1);
		} finally { DebugExitRule(GrammarFileName, "parm"); }
		return;

	}
	// $ANTLR end "parm"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _funcDef_in_list33 = new BitSet(new ulong[]{0x52UL});
		public static readonly BitSet _TYPE_in_funcDef49 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ID_in_funcDef52 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _8_in_funcDef54 = new BitSet(new ulong[]{0x240UL});
		public static readonly BitSet _parmList_in_funcDef56 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _9_in_funcDef59 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _set_in_funcDef61 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parm_in_parmList81 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _10_in_parmList84 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _parm_in_parmList86 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _TYPE_in_parm99 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ID_in_parm101 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  Halcyon.Phlox.Tools 
